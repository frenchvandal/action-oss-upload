/******/ (() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 3109: /***/ (module, __webpack_exports__, __nccwpck_require__) => {
      "use strict";
      __nccwpck_require__.a(
        module,
        async (__webpack_handle_async_dependencies__, __webpack_async_result__) => {
          try {
            __nccwpck_require__.r(__webpack_exports__);
            /* harmony import */ var _actions_core__WEBPACK_IMPORTED_MODULE_0__ = __nccwpck_require__(2186);
            /* harmony import */ var _actions_core__WEBPACK_IMPORTED_MODULE_0___default =
              /*#__PURE__*/ __nccwpck_require__.n(_actions_core__WEBPACK_IMPORTED_MODULE_0__);
            /* harmony import */ var _actions_exec__WEBPACK_IMPORTED_MODULE_1__ = __nccwpck_require__(1514);
            /* harmony import */ var _actions_exec__WEBPACK_IMPORTED_MODULE_1___default =
              /*#__PURE__*/ __nccwpck_require__.n(_actions_exec__WEBPACK_IMPORTED_MODULE_1__);
            /* harmony import */ var _actions_glob__WEBPACK_IMPORTED_MODULE_2__ = __nccwpck_require__(8090);
            /* harmony import */ var _actions_glob__WEBPACK_IMPORTED_MODULE_2___default =
              /*#__PURE__*/ __nccwpck_require__.n(_actions_glob__WEBPACK_IMPORTED_MODULE_2__);
            /* harmony import */ var ali_oss__WEBPACK_IMPORTED_MODULE_3__ = __nccwpck_require__(2399);
            /* harmony import */ var ali_oss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nccwpck_require__.n(
              ali_oss__WEBPACK_IMPORTED_MODULE_3__
            );
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __nccwpck_require__(1017);
            /* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nccwpck_require__.n(
              path__WEBPACK_IMPORTED_MODULE_4__
            );

            const homeDir = (0, path__WEBPACK_IMPORTED_MODULE_4__.join)(
              process.cwd(),
              (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput)("source"),
              path__WEBPACK_IMPORTED_MODULE_4__.sep
            );
            const credentials = {
              accessKeyId: (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput)("accessKeyId", { required: true }),
              accessKeySecret: (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput)("accessKeySecret", {
                required: true
              }),
              bucket: (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput)("bucket", { required: true }),
              region: (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getInput)("region", { required: true })
            };
            const client = new (ali_oss__WEBPACK_IMPORTED_MODULE_3___default())(credentials);
            const idToken = await (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.getIDToken)();
            (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.info)("id token:");
            (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.info)(idToken);
            (async () => {
              try {
                let index = 0;
                let percent = 0;
                const uploadDir = await (0, _actions_glob__WEBPACK_IMPORTED_MODULE_2__.create)(homeDir, {
                  matchDirectories: false
                });
                const localFiles = uploadDir.globGenerator();
                const size = (await uploadDir.glob()).length;
                (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.info)(`${size} files to upload`);
                for await (const file of localFiles) {
                  const response = await client.put(
                    (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.toPosixPath)(
                      (0, path__WEBPACK_IMPORTED_MODULE_4__.relative)(homeDir, file)
                    ),
                    file
                  );
                  index += 1;
                  percent = (index / size) * 100;
                  (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.info)(
                    `[${index}/${size}, ${percent.toFixed(2)}%] uploaded: ${response.name}`
                  );
                  await (0, _actions_exec__WEBPACK_IMPORTED_MODULE_1__.exec)(
                    `aliyun Cdn RefreshObjectCaches --ObjectPath https://frenchvandal.cn/${(0,
                    _actions_core__WEBPACK_IMPORTED_MODULE_0__.toPosixPath)(
                      (0, path__WEBPACK_IMPORTED_MODULE_4__.relative)(homeDir, file)
                    )} --ObjectType file`
                  );
                  await (0, _actions_exec__WEBPACK_IMPORTED_MODULE_1__.exec)(
                    `aliyun Cdn PushObjectCache --ObjectPath https://frenchvandal.cn/${(0,
                    _actions_core__WEBPACK_IMPORTED_MODULE_0__.toPosixPath)(
                      (0, path__WEBPACK_IMPORTED_MODULE_4__.relative)(homeDir, file)
                    )} --Area overseas --L2Preload true`
                  );
                }
                (0, _actions_core__WEBPACK_IMPORTED_MODULE_0__.info)(`${index} files uploaded`);
              } catch (err) {
                const { warning } = await Promise.resolve(/* import() */).then(
                  __nccwpck_require__.t.bind(__nccwpck_require__, 2186, 23)
                );
                warning(err.message);
              }
            })();
            //# sourceMappingURL=main.js.map

            __webpack_async_result__();
          } catch (e) {
            __webpack_async_result__(e);
          }
        },
        1
      );

      /***/
    },

    /***/ 7351: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.issue = exports.issueCommand = void 0;
      const os = __importStar(__nccwpck_require__(2037));
      const utils_1 = __nccwpck_require__(5278);
      /**
       * Commands
       *
       * Command Format:
       *   ::name key=value,key=value::message
       *
       * Examples:
       *   ::warning::This is the message
       *   ::set-env name=MY_VAR::some value
       */
      function issueCommand(command, properties, message) {
        const cmd = new Command(command, properties, message);
        process.stdout.write(cmd.toString() + os.EOL);
      }
      exports.issueCommand = issueCommand;
      function issue(name, message = "") {
        issueCommand(name, {}, message);
      }
      exports.issue = issue;
      const CMD_STRING = "::";
      class Command {
        constructor(command, properties, message) {
          if (!command) {
            command = "missing.command";
          }
          this.command = command;
          this.properties = properties;
          this.message = message;
        }
        toString() {
          let cmdStr = CMD_STRING + this.command;
          if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += " ";
            let first = true;
            for (const key in this.properties) {
              if (this.properties.hasOwnProperty(key)) {
                const val = this.properties[key];
                if (val) {
                  if (first) {
                    first = false;
                  } else {
                    cmdStr += ",";
                  }
                  cmdStr += `${key}=${escapeProperty(val)}`;
                }
              }
            }
          }
          cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
          return cmdStr;
        }
      }
      function escapeData(s) {
        return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
      }
      function escapeProperty(s) {
        return utils_1
          .toCommandValue(s)
          .replace(/%/g, "%25")
          .replace(/\r/g, "%0D")
          .replace(/\n/g, "%0A")
          .replace(/:/g, "%3A")
          .replace(/,/g, "%2C");
      }
      //# sourceMappingURL=command.js.map

      /***/
    },

    /***/ 2186: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getIDToken =
        exports.getState =
        exports.saveState =
        exports.group =
        exports.endGroup =
        exports.startGroup =
        exports.info =
        exports.notice =
        exports.warning =
        exports.error =
        exports.debug =
        exports.isDebug =
        exports.setFailed =
        exports.setCommandEcho =
        exports.setOutput =
        exports.getBooleanInput =
        exports.getMultilineInput =
        exports.getInput =
        exports.addPath =
        exports.setSecret =
        exports.exportVariable =
        exports.ExitCode =
          void 0;
      const command_1 = __nccwpck_require__(7351);
      const file_command_1 = __nccwpck_require__(717);
      const utils_1 = __nccwpck_require__(5278);
      const os = __importStar(__nccwpck_require__(2037));
      const path = __importStar(__nccwpck_require__(1017));
      const oidc_utils_1 = __nccwpck_require__(8041);
      /**
       * The code to exit an action
       */
      var ExitCode;
      (function (ExitCode) {
        /**
         * A code indicating that the action was successful
         */
        ExitCode[(ExitCode["Success"] = 0)] = "Success";
        /**
         * A code indicating that the action was a failure
         */
        ExitCode[(ExitCode["Failure"] = 1)] = "Failure";
      })((ExitCode = exports.ExitCode || (exports.ExitCode = {})));
      //-----------------------------------------------------------------------
      // Variables
      //-----------------------------------------------------------------------
      /**
       * Sets env variable for this action and future actions in the job
       * @param name the name of the variable to set
       * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function exportVariable(name, val) {
        const convertedVal = utils_1.toCommandValue(val);
        process.env[name] = convertedVal;
        const filePath = process.env["GITHUB_ENV"] || "";
        if (filePath) {
          return file_command_1.issueFileCommand("ENV", file_command_1.prepareKeyValueMessage(name, val));
        }
        command_1.issueCommand("set-env", { name }, convertedVal);
      }
      exports.exportVariable = exportVariable;
      /**
       * Registers a secret which will get masked from logs
       * @param secret value of the secret
       */
      function setSecret(secret) {
        command_1.issueCommand("add-mask", {}, secret);
      }
      exports.setSecret = setSecret;
      /**
       * Prepends inputPath to the PATH (for this action and future actions)
       * @param inputPath
       */
      function addPath(inputPath) {
        const filePath = process.env["GITHUB_PATH"] || "";
        if (filePath) {
          file_command_1.issueFileCommand("PATH", inputPath);
        } else {
          command_1.issueCommand("add-path", {}, inputPath);
        }
        process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
      }
      exports.addPath = addPath;
      /**
       * Gets the value of an input.
       * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
       * Returns an empty string if the value is not defined.
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   string
       */
      function getInput(name, options) {
        const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
        if (options && options.required && !val) {
          throw new Error(`Input required and not supplied: ${name}`);
        }
        if (options && options.trimWhitespace === false) {
          return val;
        }
        return val.trim();
      }
      exports.getInput = getInput;
      /**
       * Gets the values of an multiline input.  Each value is also trimmed.
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   string[]
       *
       */
      function getMultilineInput(name, options) {
        const inputs = getInput(name, options)
          .split("\n")
          .filter((x) => x !== "");
        if (options && options.trimWhitespace === false) {
          return inputs;
        }
        return inputs.map((input) => input.trim());
      }
      exports.getMultilineInput = getMultilineInput;
      /**
       * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
       * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
       * The return value is also in boolean type.
       * ref: https://yaml.org/spec/1.2/spec.html#id2804923
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   boolean
       */
      function getBooleanInput(name, options) {
        const trueValue = ["true", "True", "TRUE"];
        const falseValue = ["false", "False", "FALSE"];
        const val = getInput(name, options);
        if (trueValue.includes(val)) return true;
        if (falseValue.includes(val)) return false;
        throw new TypeError(
          `Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
            `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``
        );
      }
      exports.getBooleanInput = getBooleanInput;
      /**
       * Sets the value of an output.
       *
       * @param     name     name of the output to set
       * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function setOutput(name, value) {
        const filePath = process.env["GITHUB_OUTPUT"] || "";
        if (filePath) {
          return file_command_1.issueFileCommand("OUTPUT", file_command_1.prepareKeyValueMessage(name, value));
        }
        process.stdout.write(os.EOL);
        command_1.issueCommand("set-output", { name }, utils_1.toCommandValue(value));
      }
      exports.setOutput = setOutput;
      /**
       * Enables or disables the echoing of commands into stdout for the rest of the step.
       * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
       *
       */
      function setCommandEcho(enabled) {
        command_1.issue("echo", enabled ? "on" : "off");
      }
      exports.setCommandEcho = setCommandEcho;
      //-----------------------------------------------------------------------
      // Results
      //-----------------------------------------------------------------------
      /**
       * Sets the action status to failed.
       * When the action exits it will be with an exit code of 1
       * @param message add error issue message
       */
      function setFailed(message) {
        process.exitCode = ExitCode.Failure;
        error(message);
      }
      exports.setFailed = setFailed;
      //-----------------------------------------------------------------------
      // Logging Commands
      //-----------------------------------------------------------------------
      /**
       * Gets whether Actions Step Debug is on or not
       */
      function isDebug() {
        return process.env["RUNNER_DEBUG"] === "1";
      }
      exports.isDebug = isDebug;
      /**
       * Writes debug message to user log
       * @param message debug message
       */
      function debug(message) {
        command_1.issueCommand("debug", {}, message);
      }
      exports.debug = debug;
      /**
       * Adds an error issue
       * @param message error issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function error(message, properties = {}) {
        command_1.issueCommand(
          "error",
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        );
      }
      exports.error = error;
      /**
       * Adds a warning issue
       * @param message warning issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function warning(message, properties = {}) {
        command_1.issueCommand(
          "warning",
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        );
      }
      exports.warning = warning;
      /**
       * Adds a notice issue
       * @param message notice issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function notice(message, properties = {}) {
        command_1.issueCommand(
          "notice",
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        );
      }
      exports.notice = notice;
      /**
       * Writes info to log with console.log.
       * @param message info message
       */
      function info(message) {
        process.stdout.write(message + os.EOL);
      }
      exports.info = info;
      /**
       * Begin an output group.
       *
       * Output until the next `groupEnd` will be foldable in this group
       *
       * @param name The name of the output group
       */
      function startGroup(name) {
        command_1.issue("group", name);
      }
      exports.startGroup = startGroup;
      /**
       * End an output group.
       */
      function endGroup() {
        command_1.issue("endgroup");
      }
      exports.endGroup = endGroup;
      /**
       * Wrap an asynchronous function call in a group.
       *
       * Returns the same type as the function itself.
       *
       * @param name The name of the group
       * @param fn The function to wrap in the group
       */
      function group(name, fn) {
        return __awaiter(this, void 0, void 0, function* () {
          startGroup(name);
          let result;
          try {
            result = yield fn();
          } finally {
            endGroup();
          }
          return result;
        });
      }
      exports.group = group;
      //-----------------------------------------------------------------------
      // Wrapper action state
      //-----------------------------------------------------------------------
      /**
       * Saves state for current action, the state can only be retrieved by this action's post job execution.
       *
       * @param     name     name of the state to store
       * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function saveState(name, value) {
        const filePath = process.env["GITHUB_STATE"] || "";
        if (filePath) {
          return file_command_1.issueFileCommand("STATE", file_command_1.prepareKeyValueMessage(name, value));
        }
        command_1.issueCommand("save-state", { name }, utils_1.toCommandValue(value));
      }
      exports.saveState = saveState;
      /**
       * Gets the value of an state set by this action's main execution.
       *
       * @param     name     name of the state to get
       * @returns   string
       */
      function getState(name) {
        return process.env[`STATE_${name}`] || "";
      }
      exports.getState = getState;
      function getIDToken(aud) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield oidc_utils_1.OidcClient.getIDToken(aud);
        });
      }
      exports.getIDToken = getIDToken;
      /**
       * Summary exports
       */
      var summary_1 = __nccwpck_require__(1327);
      Object.defineProperty(exports, "summary", {
        enumerable: true,
        get: function () {
          return summary_1.summary;
        }
      });
      /**
       * @deprecated use core.summary
       */
      var summary_2 = __nccwpck_require__(1327);
      Object.defineProperty(exports, "markdownSummary", {
        enumerable: true,
        get: function () {
          return summary_2.markdownSummary;
        }
      });
      /**
       * Path exports
       */
      var path_utils_1 = __nccwpck_require__(2981);
      Object.defineProperty(exports, "toPosixPath", {
        enumerable: true,
        get: function () {
          return path_utils_1.toPosixPath;
        }
      });
      Object.defineProperty(exports, "toWin32Path", {
        enumerable: true,
        get: function () {
          return path_utils_1.toWin32Path;
        }
      });
      Object.defineProperty(exports, "toPlatformPath", {
        enumerable: true,
        get: function () {
          return path_utils_1.toPlatformPath;
        }
      });
      //# sourceMappingURL=core.js.map

      /***/
    },

    /***/ 717: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      // For internal use, subject to change.
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
      // We use any as a valid input type
      /* eslint-disable @typescript-eslint/no-explicit-any */
      const fs = __importStar(__nccwpck_require__(7147));
      const os = __importStar(__nccwpck_require__(2037));
      const uuid_1 = __nccwpck_require__(5840);
      const utils_1 = __nccwpck_require__(5278);
      function issueFileCommand(command, message) {
        const filePath = process.env[`GITHUB_${command}`];
        if (!filePath) {
          throw new Error(`Unable to find environment variable for file command ${command}`);
        }
        if (!fs.existsSync(filePath)) {
          throw new Error(`Missing file at path: ${filePath}`);
        }
        fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
          encoding: "utf8"
        });
      }
      exports.issueFileCommand = issueFileCommand;
      function prepareKeyValueMessage(key, value) {
        const delimiter = `ghadelimiter_${uuid_1.v4()}`;
        const convertedValue = utils_1.toCommandValue(value);
        // These should realistically never happen, but just in case someone finds a
        // way to exploit uuid generation let's not allow keys or values that contain
        // the delimiter.
        if (key.includes(delimiter)) {
          throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
        }
        if (convertedValue.includes(delimiter)) {
          throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
        }
        return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
      }
      exports.prepareKeyValueMessage = prepareKeyValueMessage;
      //# sourceMappingURL=file-command.js.map

      /***/
    },

    /***/ 8041: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OidcClient = void 0;
      const http_client_1 = __nccwpck_require__(6255);
      const auth_1 = __nccwpck_require__(5526);
      const core_1 = __nccwpck_require__(2186);
      class OidcClient {
        static createHttpClient(allowRetry = true, maxRetry = 10) {
          const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
          };
          return new http_client_1.HttpClient(
            "actions/oidc-client",
            [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())],
            requestOptions
          );
        }
        static getRequestToken() {
          const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
          if (!token) {
            throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
          }
          return token;
        }
        static getIDTokenUrl() {
          const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
          if (!runtimeUrl) {
            throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
          }
          return runtimeUrl;
        }
        static getCall(id_token_url) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient.getJson(id_token_url).catch((error) => {
              throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
              throw new Error("Response json body do not have ID Token field");
            }
            return id_token;
          });
        }
        static getIDToken(audience) {
          return __awaiter(this, void 0, void 0, function* () {
            try {
              // New ID Token is requested from action service
              let id_token_url = OidcClient.getIDTokenUrl();
              if (audience) {
                const encodedAudience = encodeURIComponent(audience);
                id_token_url = `${id_token_url}&audience=${encodedAudience}`;
              }
              core_1.debug(`ID token url is ${id_token_url}`);
              const id_token = yield OidcClient.getCall(id_token_url);
              core_1.setSecret(id_token);
              return id_token;
            } catch (error) {
              throw new Error(`Error message: ${error.message}`);
            }
          });
        }
      }
      exports.OidcClient = OidcClient;
      //# sourceMappingURL=oidc-utils.js.map

      /***/
    },

    /***/ 2981: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
      const path = __importStar(__nccwpck_require__(1017));
      /**
       * toPosixPath converts the given path to the posix form. On Windows, \\ will be
       * replaced with /.
       *
       * @param pth. Path to transform.
       * @return string Posix path.
       */
      function toPosixPath(pth) {
        return pth.replace(/[\\]/g, "/");
      }
      exports.toPosixPath = toPosixPath;
      /**
       * toWin32Path converts the given path to the win32 form. On Linux, / will be
       * replaced with \\.
       *
       * @param pth. Path to transform.
       * @return string Win32 path.
       */
      function toWin32Path(pth) {
        return pth.replace(/[/]/g, "\\");
      }
      exports.toWin32Path = toWin32Path;
      /**
       * toPlatformPath converts the given path to a platform-specific path. It does
       * this by replacing instances of / and \ with the platform-specific path
       * separator.
       *
       * @param pth The path to platformize.
       * @return string The platform-specific path.
       */
      function toPlatformPath(pth) {
        return pth.replace(/[/\\]/g, path.sep);
      }
      exports.toPlatformPath = toPlatformPath;
      //# sourceMappingURL=path-utils.js.map

      /***/
    },

    /***/ 1327: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
      const os_1 = __nccwpck_require__(2037);
      const fs_1 = __nccwpck_require__(7147);
      const { access, appendFile, writeFile } = fs_1.promises;
      exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
      exports.SUMMARY_DOCS_URL =
        "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
      class Summary {
        constructor() {
          this._buffer = "";
        }
        /**
         * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
         * Also checks r/w permissions.
         *
         * @returns step summary file path
         */
        filePath() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
              return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
              throw new Error(
                `Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`
              );
            }
            try {
              yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            } catch (_a) {
              throw new Error(
                `Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`
              );
            }
            this._filePath = pathFromEnv;
            return this._filePath;
          });
        }
        /**
         * Wraps content in an HTML tag, adding any HTML attributes
         *
         * @param {string} tag HTML tag to wrap
         * @param {string | null} content content within the tag
         * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
         *
         * @returns {string} content wrapped in HTML element
         */
        wrap(tag, content, attrs = {}) {
          const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join("");
          if (!content) {
            return `<${tag}${htmlAttrs}>`;
          }
          return `<${tag}${htmlAttrs}>${content}</${tag}>`;
        }
        /**
         * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
         *
         * @param {SummaryWriteOptions} [options] (optional) options for write operation
         *
         * @returns {Promise<Summary>} summary instance
         */
        write(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
            return this.emptyBuffer();
          });
        }
        /**
         * Clears the summary buffer and wipes the summary file
         *
         * @returns {Summary} summary instance
         */
        clear() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
          });
        }
        /**
         * Returns the current summary buffer as a string
         *
         * @returns {string} string of summary buffer
         */
        stringify() {
          return this._buffer;
        }
        /**
         * If the summary buffer is empty
         *
         * @returns {boolen} true if the buffer is empty
         */
        isEmptyBuffer() {
          return this._buffer.length === 0;
        }
        /**
         * Resets the summary buffer without writing to summary file
         *
         * @returns {Summary} summary instance
         */
        emptyBuffer() {
          this._buffer = "";
          return this;
        }
        /**
         * Adds raw text to the summary buffer
         *
         * @param {string} text content to add
         * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
         *
         * @returns {Summary} summary instance
         */
        addRaw(text, addEOL = false) {
          this._buffer += text;
          return addEOL ? this.addEOL() : this;
        }
        /**
         * Adds the operating system-specific end-of-line marker to the buffer
         *
         * @returns {Summary} summary instance
         */
        addEOL() {
          return this.addRaw(os_1.EOL);
        }
        /**
         * Adds an HTML codeblock to the summary buffer
         *
         * @param {string} code content to render within fenced code block
         * @param {string} lang (optional) language to syntax highlight code
         *
         * @returns {Summary} summary instance
         */
        addCodeBlock(code, lang) {
          const attrs = Object.assign({}, lang && { lang });
          const element = this.wrap("pre", this.wrap("code", code), attrs);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML list to the summary buffer
         *
         * @param {string[]} items list of items to render
         * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
         *
         * @returns {Summary} summary instance
         */
        addList(items, ordered = false) {
          const tag = ordered ? "ol" : "ul";
          const listItems = items.map((item) => this.wrap("li", item)).join("");
          const element = this.wrap(tag, listItems);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML table to the summary buffer
         *
         * @param {SummaryTableCell[]} rows table rows
         *
         * @returns {Summary} summary instance
         */
        addTable(rows) {
          const tableBody = rows
            .map((row) => {
              const cells = row
                .map((cell) => {
                  if (typeof cell === "string") {
                    return this.wrap("td", cell);
                  }
                  const { header, data, colspan, rowspan } = cell;
                  const tag = header ? "th" : "td";
                  const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
                  return this.wrap(tag, data, attrs);
                })
                .join("");
              return this.wrap("tr", cells);
            })
            .join("");
          const element = this.wrap("table", tableBody);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds a collapsable HTML details element to the summary buffer
         *
         * @param {string} label text for the closed state
         * @param {string} content collapsable content
         *
         * @returns {Summary} summary instance
         */
        addDetails(label, content) {
          const element = this.wrap("details", this.wrap("summary", label) + content);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML image tag to the summary buffer
         *
         * @param {string} src path to the image you to embed
         * @param {string} alt text description of the image
         * @param {SummaryImageOptions} options (optional) addition image attributes
         *
         * @returns {Summary} summary instance
         */
        addImage(src, alt, options) {
          const { width, height } = options || {};
          const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
          const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML section heading element
         *
         * @param {string} text heading text
         * @param {number | string} [level=1] (optional) the heading level, default: 1
         *
         * @returns {Summary} summary instance
         */
        addHeading(text, level) {
          const tag = `h${level}`;
          const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
          const element = this.wrap(allowedTag, text);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML thematic break (<hr>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addSeparator() {
          const element = this.wrap("hr", null);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML line break (<br>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addBreak() {
          const element = this.wrap("br", null);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML blockquote to the summary buffer
         *
         * @param {string} text quote text
         * @param {string} cite (optional) citation url
         *
         * @returns {Summary} summary instance
         */
        addQuote(text, cite) {
          const attrs = Object.assign({}, cite && { cite });
          const element = this.wrap("blockquote", text, attrs);
          return this.addRaw(element).addEOL();
        }
        /**
         * Adds an HTML anchor tag to the summary buffer
         *
         * @param {string} text link text/content
         * @param {string} href hyperlink
         *
         * @returns {Summary} summary instance
         */
        addLink(text, href) {
          const element = this.wrap("a", text, { href });
          return this.addRaw(element).addEOL();
        }
      }
      const _summary = new Summary();
      /**
       * @deprecated use `core.summary`
       */
      exports.markdownSummary = _summary;
      exports.summary = _summary;
      //# sourceMappingURL=summary.js.map

      /***/
    },

    /***/ 5278: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      // We use any as a valid input type
      /* eslint-disable @typescript-eslint/no-explicit-any */
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCommandProperties = exports.toCommandValue = void 0;
      /**
       * Sanitizes an input into a string so it can be passed into issueCommand safely
       * @param input input to sanitize into a string
       */
      function toCommandValue(input) {
        if (input === null || input === undefined) {
          return "";
        } else if (typeof input === "string" || input instanceof String) {
          return input;
        }
        return JSON.stringify(input);
      }
      exports.toCommandValue = toCommandValue;
      /**
       *
       * @param annotationProperties
       * @returns The command properties to send with the actual annotation command
       * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
       */
      function toCommandProperties(annotationProperties) {
        if (!Object.keys(annotationProperties).length) {
          return {};
        }
        return {
          title: annotationProperties.title,
          file: annotationProperties.file,
          line: annotationProperties.startLine,
          endLine: annotationProperties.endLine,
          col: annotationProperties.startColumn,
          endColumn: annotationProperties.endColumn
        };
      }
      exports.toCommandProperties = toCommandProperties;
      //# sourceMappingURL=utils.js.map

      /***/
    },

    /***/ 1514: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getExecOutput = exports.exec = void 0;
      const string_decoder_1 = __nccwpck_require__(1576);
      const tr = __importStar(__nccwpck_require__(8159));
      /**
       * Exec a command.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
       * @param     args               optional arguments for tool. Escaping is handled by the lib.
       * @param     options            optional exec options.  See ExecOptions
       * @returns   Promise<number>    exit code
       */
      function exec(commandLine, args, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const commandArgs = tr.argStringToArray(commandLine);
          if (commandArgs.length === 0) {
            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
          }
          // Path to tool to execute should be first arg
          const toolPath = commandArgs[0];
          args = commandArgs.slice(1).concat(args || []);
          const runner = new tr.ToolRunner(toolPath, args, options);
          return runner.exec();
        });
      }
      exports.exec = exec;
      /**
       * Exec a command and get the output.
       * Output will be streamed to the live console.
       * Returns promise with the exit code and collected stdout and stderr
       *
       * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
       * @param     args                  optional arguments for tool. Escaping is handled by the lib.
       * @param     options               optional exec options.  See ExecOptions
       * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
       */
      function getExecOutput(commandLine, args, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          let stdout = "";
          let stderr = "";
          //Using string decoder covers the case where a mult-byte character is split
          const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
          const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
          const originalStdoutListener =
            (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0
              ? void 0
              : _a.stdout;
          const originalStdErrListener =
            (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0
              ? void 0
              : _b.stderr;
          const stdErrListener = (data) => {
            stderr += stderrDecoder.write(data);
            if (originalStdErrListener) {
              originalStdErrListener(data);
            }
          };
          const stdOutListener = (data) => {
            stdout += stdoutDecoder.write(data);
            if (originalStdoutListener) {
              originalStdoutListener(data);
            }
          };
          const listeners = Object.assign(
            Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners),
            { stdout: stdOutListener, stderr: stdErrListener }
          );
          const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
          //flush any remaining characters
          stdout += stdoutDecoder.end();
          stderr += stderrDecoder.end();
          return {
            exitCode,
            stdout,
            stderr
          };
        });
      }
      exports.getExecOutput = getExecOutput;
      //# sourceMappingURL=exec.js.map

      /***/
    },

    /***/ 8159: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argStringToArray = exports.ToolRunner = void 0;
      const os = __importStar(__nccwpck_require__(2037));
      const events = __importStar(__nccwpck_require__(2361));
      const child = __importStar(__nccwpck_require__(2081));
      const path = __importStar(__nccwpck_require__(1017));
      const io = __importStar(__nccwpck_require__(7436));
      const ioUtil = __importStar(__nccwpck_require__(1962));
      const timers_1 = __nccwpck_require__(9512);
      /* eslint-disable @typescript-eslint/unbound-method */
      const IS_WINDOWS = process.platform === "win32";
      /*
       * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
       */
      class ToolRunner extends events.EventEmitter {
        constructor(toolPath, args, options) {
          super();
          if (!toolPath) {
            throw new Error("Parameter 'toolPath' cannot be null or empty.");
          }
          this.toolPath = toolPath;
          this.args = args || [];
          this.options = options || {};
        }
        _debug(message) {
          if (this.options.listeners && this.options.listeners.debug) {
            this.options.listeners.debug(message);
          }
        }
        _getCommandString(options, noPrefix) {
          const toolPath = this._getSpawnFileName();
          const args = this._getSpawnArgs(options);
          let cmd = noPrefix ? "" : "[command]"; // omit prefix when piped to a second tool
          if (IS_WINDOWS) {
            // Windows + cmd file
            if (this._isCmdFile()) {
              cmd += toolPath;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            }
            // Windows + verbatim
            else if (options.windowsVerbatimArguments) {
              cmd += `"${toolPath}"`;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            }
            // Windows (regular)
            else {
              cmd += this._windowsQuoteCmdArg(toolPath);
              for (const a of args) {
                cmd += ` ${this._windowsQuoteCmdArg(a)}`;
              }
            }
          } else {
            // OSX/Linux - this can likely be improved with some form of quoting.
            // creating processes on Unix is fundamentally different than Windows.
            // on Unix, execvp() takes an arg array.
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          }
          return cmd;
        }
        _processLineBuffer(data, strBuffer, onLine) {
          try {
            let s = strBuffer + data.toString();
            let n = s.indexOf(os.EOL);
            while (n > -1) {
              const line = s.substring(0, n);
              onLine(line);
              // the rest of the string ...
              s = s.substring(n + os.EOL.length);
              n = s.indexOf(os.EOL);
            }
            return s;
          } catch (err) {
            // streaming lines to console is best effort.  Don't fail a build.
            this._debug(`error processing line. Failed with error ${err}`);
            return "";
          }
        }
        _getSpawnFileName() {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              return process.env["COMSPEC"] || "cmd.exe";
            }
          }
          return this.toolPath;
        }
        _getSpawnArgs(options) {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
              for (const a of this.args) {
                argline += " ";
                argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
              }
              argline += '"';
              return [argline];
            }
          }
          return this.args;
        }
        _endsWith(str, end) {
          return str.endsWith(end);
        }
        _isCmdFile() {
          const upperToolPath = this.toolPath.toUpperCase();
          return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
        }
        _windowsQuoteCmdArg(arg) {
          // for .exe, apply the normal quoting rules that libuv applies
          if (!this._isCmdFile()) {
            return this._uvQuoteCmdArg(arg);
          }
          // otherwise apply quoting rules specific to the cmd.exe command line parser.
          // the libuv rules are generic and are not designed specifically for cmd.exe
          // command line parser.
          //
          // for a detailed description of the cmd.exe command line parser, refer to
          // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
          // need quotes for empty arg
          if (!arg) {
            return '""';
          }
          // determine whether the arg needs to be quoted
          const cmdSpecialChars = [
            " ",
            "\t",
            "&",
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            "^",
            "=",
            ";",
            "!",
            "'",
            "+",
            ",",
            "`",
            "~",
            "|",
            "<",
            ">",
            '"'
          ];
          let needsQuotes = false;
          for (const char of arg) {
            if (cmdSpecialChars.some((x) => x === char)) {
              needsQuotes = true;
              break;
            }
          }
          // short-circuit if quotes not needed
          if (!needsQuotes) {
            return arg;
          }
          // the following quoting rules are very similar to the rules that by libuv applies.
          //
          // 1) wrap the string in quotes
          //
          // 2) double-up quotes - i.e. " => ""
          //
          //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
          //    doesn't work well with a cmd.exe command line.
          //
          //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
          //    for example, the command line:
          //          foo.exe "myarg:""my val"""
          //    is parsed by a .NET console app into an arg array:
          //          [ "myarg:\"my val\"" ]
          //    which is the same end result when applying libuv quoting rules. although the actual
          //    command line from libuv quoting rules would look like:
          //          foo.exe "myarg:\"my val\""
          //
          // 3) double-up slashes that precede a quote,
          //    e.g.  hello \world    => "hello \world"
          //          hello\"world    => "hello\\""world"
          //          hello\\"world   => "hello\\\\""world"
          //          hello world\    => "hello world\\"
          //
          //    technically this is not required for a cmd.exe command line, or the batch argument parser.
          //    the reasons for including this as a .cmd quoting rule are:
          //
          //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
          //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
          //
          //    b) it's what we've been doing previously (by deferring to node default behavior) and we
          //       haven't heard any complaints about that aspect.
          //
          // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
          // escaped when used on the command line directly - even though within a .cmd file % can be escaped
          // by using %%.
          //
          // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
          // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
          //
          // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
          // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
          // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
          // to an external program.
          //
          // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
          // % can be escaped within a .cmd file.
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\"; // double the slash
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += '"'; // double the quote
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _uvQuoteCmdArg(arg) {
          // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
          // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
          // is used.
          //
          // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
          // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
          // pasting copyright notice from Node within this function:
          //
          //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
          //
          //      Permission is hereby granted, free of charge, to any person obtaining a copy
          //      of this software and associated documentation files (the "Software"), to
          //      deal in the Software without restriction, including without limitation the
          //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          //      sell copies of the Software, and to permit persons to whom the Software is
          //      furnished to do so, subject to the following conditions:
          //
          //      The above copyright notice and this permission notice shall be included in
          //      all copies or substantial portions of the Software.
          //
          //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
          //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
          //      IN THE SOFTWARE.
          if (!arg) {
            // Need double quotation for empty argument
            return '""';
          }
          if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
            // No quotation needed
            return arg;
          }
          if (!arg.includes('"') && !arg.includes("\\")) {
            // No embedded double quotes or backslashes, so I can just wrap
            // quote marks around the whole thing.
            return `"${arg}"`;
          }
          // Expected input/output:
          //   input : hello"world
          //   output: "hello\"world"
          //   input : hello""world
          //   output: "hello\"\"world"
          //   input : hello\world
          //   output: hello\world
          //   input : hello\\world
          //   output: hello\\world
          //   input : hello\"world
          //   output: "hello\\\"world"
          //   input : hello\\"world
          //   output: "hello\\\\\"world"
          //   input : hello world\
          //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
          //                             but it appears the comment is wrong, it should be "hello world\\"
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\";
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += "\\";
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _cloneExecOptions(options) {
          options = options || {};
          const result = {
            cwd: options.cwd || process.cwd(),
            env: options.env || process.env,
            silent: options.silent || false,
            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
            failOnStdErr: options.failOnStdErr || false,
            ignoreReturnCode: options.ignoreReturnCode || false,
            delay: options.delay || 10000
          };
          result.outStream = options.outStream || process.stdout;
          result.errStream = options.errStream || process.stderr;
          return result;
        }
        _getSpawnOptions(options, toolPath) {
          options = options || {};
          const result = {};
          result.cwd = options.cwd;
          result.env = options.env;
          result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
          if (options.windowsVerbatimArguments) {
            result.argv0 = `"${toolPath}"`;
          }
          return result;
        }
        /**
         * Exec a tool.
         * Output will be streamed to the live console.
         * Returns promise with return code
         *
         * @param     tool     path to tool to exec
         * @param     options  optional exec options.  See ExecOptions
         * @returns   number
         */
        exec() {
          return __awaiter(this, void 0, void 0, function* () {
            // root the tool path if it is unrooted and contains relative pathing
            if (
              !ioUtil.isRooted(this.toolPath) &&
              (this.toolPath.includes("/") || (IS_WINDOWS && this.toolPath.includes("\\")))
            ) {
              // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
              this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
            }
            // if the tool is only a file name, then resolve it from the PATH
            // otherwise verify it exists (add extension on Windows if necessary)
            this.toolPath = yield io.which(this.toolPath, true);
            return new Promise((resolve, reject) =>
              __awaiter(this, void 0, void 0, function* () {
                this._debug(`exec tool: ${this.toolPath}`);
                this._debug("arguments:");
                for (const arg of this.args) {
                  this._debug(`   ${arg}`);
                }
                const optionsNonNull = this._cloneExecOptions(this.options);
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
                }
                const state = new ExecState(optionsNonNull, this.toolPath);
                state.on("debug", (message) => {
                  this._debug(message);
                });
                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
                  return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
                }
                const fileName = this._getSpawnFileName();
                const cp = child.spawn(
                  fileName,
                  this._getSpawnArgs(optionsNonNull),
                  this._getSpawnOptions(this.options, fileName)
                );
                let stdbuffer = "";
                if (cp.stdout) {
                  cp.stdout.on("data", (data) => {
                    if (this.options.listeners && this.options.listeners.stdout) {
                      this.options.listeners.stdout(data);
                    }
                    if (!optionsNonNull.silent && optionsNonNull.outStream) {
                      optionsNonNull.outStream.write(data);
                    }
                    stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                      if (this.options.listeners && this.options.listeners.stdline) {
                        this.options.listeners.stdline(line);
                      }
                    });
                  });
                }
                let errbuffer = "";
                if (cp.stderr) {
                  cp.stderr.on("data", (data) => {
                    state.processStderr = true;
                    if (this.options.listeners && this.options.listeners.stderr) {
                      this.options.listeners.stderr(data);
                    }
                    if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                      const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                      s.write(data);
                    }
                    errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                      if (this.options.listeners && this.options.listeners.errline) {
                        this.options.listeners.errline(line);
                      }
                    });
                  });
                }
                cp.on("error", (err) => {
                  state.processError = err.message;
                  state.processExited = true;
                  state.processClosed = true;
                  state.CheckComplete();
                });
                cp.on("exit", (code) => {
                  state.processExitCode = code;
                  state.processExited = true;
                  this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
                  state.CheckComplete();
                });
                cp.on("close", (code) => {
                  state.processExitCode = code;
                  state.processExited = true;
                  state.processClosed = true;
                  this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
                  state.CheckComplete();
                });
                state.on("done", (error, exitCode) => {
                  if (stdbuffer.length > 0) {
                    this.emit("stdline", stdbuffer);
                  }
                  if (errbuffer.length > 0) {
                    this.emit("errline", errbuffer);
                  }
                  cp.removeAllListeners();
                  if (error) {
                    reject(error);
                  } else {
                    resolve(exitCode);
                  }
                });
                if (this.options.input) {
                  if (!cp.stdin) {
                    throw new Error("child process missing stdin");
                  }
                  cp.stdin.end(this.options.input);
                }
              })
            );
          });
        }
      }
      exports.ToolRunner = ToolRunner;
      /**
       * Convert an arg string to an array of args. Handles escaping
       *
       * @param    argString   string of arguments
       * @returns  string[]    array of arguments
       */
      function argStringToArray(argString) {
        const args = [];
        let inQuotes = false;
        let escaped = false;
        let arg = "";
        function append(c) {
          // we only escape double quotes.
          if (escaped && c !== '"') {
            arg += "\\";
          }
          arg += c;
          escaped = false;
        }
        for (let i = 0; i < argString.length; i++) {
          const c = argString.charAt(i);
          if (c === '"') {
            if (!escaped) {
              inQuotes = !inQuotes;
            } else {
              append(c);
            }
            continue;
          }
          if (c === "\\" && escaped) {
            append(c);
            continue;
          }
          if (c === "\\" && inQuotes) {
            escaped = true;
            continue;
          }
          if (c === " " && !inQuotes) {
            if (arg.length > 0) {
              args.push(arg);
              arg = "";
            }
            continue;
          }
          append(c);
        }
        if (arg.length > 0) {
          args.push(arg.trim());
        }
        return args;
      }
      exports.argStringToArray = argStringToArray;
      class ExecState extends events.EventEmitter {
        constructor(options, toolPath) {
          super();
          this.processClosed = false; // tracks whether the process has exited and stdio is closed
          this.processError = "";
          this.processExitCode = 0;
          this.processExited = false; // tracks whether the process has exited
          this.processStderr = false; // tracks whether stderr was written to
          this.delay = 10000; // 10 seconds
          this.done = false;
          this.timeout = null;
          if (!toolPath) {
            throw new Error("toolPath must not be empty");
          }
          this.options = options;
          this.toolPath = toolPath;
          if (options.delay) {
            this.delay = options.delay;
          }
        }
        CheckComplete() {
          if (this.done) {
            return;
          }
          if (this.processClosed) {
            this._setResult();
          } else if (this.processExited) {
            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
          }
        }
        _debug(message) {
          this.emit("debug", message);
        }
        _setResult() {
          // determine whether there is an error
          let error;
          if (this.processExited) {
            if (this.processError) {
              error = new Error(
                `There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`
              );
            } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
              error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
            } else if (this.processStderr && this.options.failOnStdErr) {
              error = new Error(
                `The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`
              );
            }
          }
          // clear the timeout
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.done = true;
          this.emit("done", error, this.processExitCode);
        }
        static HandleTimeout(state) {
          if (state.done) {
            return;
          }
          if (!state.processClosed && state.processExited) {
            const message = `The STDIO streams did not close within ${
              state.delay / 1000
            } seconds of the exit event from process '${
              state.toolPath
            }'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
            state._debug(message);
          }
          state._setResult();
        }
      }
      //# sourceMappingURL=toolrunner.js.map

      /***/
    },

    /***/ 8090: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hashFiles = exports.create = void 0;
      const internal_globber_1 = __nccwpck_require__(8298);
      const internal_hash_files_1 = __nccwpck_require__(2448);
      /**
       * Constructs a globber
       *
       * @param patterns  Patterns separated by newlines
       * @param options   Glob options
       */
      function create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield internal_globber_1.DefaultGlobber.create(patterns, options);
        });
      }
      exports.create = create;
      /**
       * Computes the sha256 hash of a glob
       *
       * @param patterns  Patterns separated by newlines
       * @param currentWorkspace  Workspace used when matching files
       * @param options   Glob options
       * @param verbose   Enables verbose logging
       */
      function hashFiles(patterns, currentWorkspace = "", options, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
          let followSymbolicLinks = true;
          if (options && typeof options.followSymbolicLinks === "boolean") {
            followSymbolicLinks = options.followSymbolicLinks;
          }
          const globber = yield create(patterns, { followSymbolicLinks });
          return internal_hash_files_1.hashFiles(globber, currentWorkspace, verbose);
        });
      }
      exports.hashFiles = hashFiles;
      //# sourceMappingURL=glob.js.map

      /***/
    },

    /***/ 1026: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getOptions = void 0;
      const core = __importStar(__nccwpck_require__(2186));
      /**
       * Returns a copy with defaults filled in.
       */
      function getOptions(copy) {
        const result = {
          followSymbolicLinks: true,
          implicitDescendants: true,
          matchDirectories: true,
          omitBrokenSymbolicLinks: true
        };
        if (copy) {
          if (typeof copy.followSymbolicLinks === "boolean") {
            result.followSymbolicLinks = copy.followSymbolicLinks;
            core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
          }
          if (typeof copy.implicitDescendants === "boolean") {
            result.implicitDescendants = copy.implicitDescendants;
            core.debug(`implicitDescendants '${result.implicitDescendants}'`);
          }
          if (typeof copy.matchDirectories === "boolean") {
            result.matchDirectories = copy.matchDirectories;
            core.debug(`matchDirectories '${result.matchDirectories}'`);
          }
          if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
            result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
            core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
          }
        }
        return result;
      }
      exports.getOptions = getOptions;
      //# sourceMappingURL=internal-glob-options-helper.js.map

      /***/
    },

    /***/ 8298: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __asyncValues =
        (this && this.__asyncValues) ||
        function (o) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator],
            i;
          return m
            ? m.call(o)
            : ((o = typeof __values === "function" ? __values(o) : o[Symbol.iterator]()),
              (i = {}),
              verb("next"),
              verb("throw"),
              verb("return"),
              (i[Symbol.asyncIterator] = function () {
                return this;
              }),
              i);
          function verb(n) {
            i[n] =
              o[n] &&
              function (v) {
                return new Promise(function (resolve, reject) {
                  (v = o[n](v)), settle(resolve, reject, v.done, v.value);
                });
              };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function (v) {
              resolve({ value: v, done: d });
            }, reject);
          }
        };
      var __await =
        (this && this.__await) ||
        function (v) {
          return this instanceof __await ? ((this.v = v), this) : new __await(v);
        };
      var __asyncGenerator =
        (this && this.__asyncGenerator) ||
        function (thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []),
            i,
            q = [];
          return (
            (i = {}),
            verb("next"),
            verb("throw"),
            verb("return"),
            (i[Symbol.asyncIterator] = function () {
              return this;
            }),
            i
          );
          function verb(n) {
            if (g[n])
              i[n] = function (v) {
                return new Promise(function (a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
          }
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultGlobber = void 0;
      const core = __importStar(__nccwpck_require__(2186));
      const fs = __importStar(__nccwpck_require__(7147));
      const globOptionsHelper = __importStar(__nccwpck_require__(1026));
      const path = __importStar(__nccwpck_require__(1017));
      const patternHelper = __importStar(__nccwpck_require__(9005));
      const internal_match_kind_1 = __nccwpck_require__(1063);
      const internal_pattern_1 = __nccwpck_require__(4536);
      const internal_search_state_1 = __nccwpck_require__(9117);
      const IS_WINDOWS = process.platform === "win32";
      class DefaultGlobber {
        constructor(options) {
          this.patterns = [];
          this.searchPaths = [];
          this.options = globOptionsHelper.getOptions(options);
        }
        getSearchPaths() {
          // Return a copy
          return this.searchPaths.slice();
        }
        glob() {
          var e_1, _a;
          return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
              for (var _b = __asyncValues(this.globGenerator()), _c; (_c = yield _b.next()), !_c.done; ) {
                const itemPath = _c.value;
                result.push(itemPath);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return result;
          });
        }
        globGenerator() {
          return __asyncGenerator(this, arguments, function* globGenerator_1() {
            // Fill in defaults options
            const options = globOptionsHelper.getOptions(this.options);
            // Implicit descendants?
            const patterns = [];
            for (const pattern of this.patterns) {
              patterns.push(pattern);
              if (
                options.implicitDescendants &&
                (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")
              ) {
                patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
              }
            }
            // Push the search paths
            const stack = [];
            for (const searchPath of patternHelper.getSearchPaths(patterns)) {
              core.debug(`Search path '${searchPath}'`);
              // Exists?
              try {
                // Intentionally using lstat. Detection for broken symlink
                // will be performed later (if following symlinks).
                yield __await(fs.promises.lstat(searchPath));
              } catch (err) {
                if (err.code === "ENOENT") {
                  continue;
                }
                throw err;
              }
              stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
            }
            // Search
            const traversalChain = []; // used to detect cycles
            while (stack.length) {
              // Pop
              const item = stack.pop();
              // Match?
              const match = patternHelper.match(patterns, item.path);
              const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
              if (!match && !partialMatch) {
                continue;
              }
              // Stat
              const stats = yield __await(
                DefaultGlobber.stat(item, options, traversalChain)
                // Broken symlink, or symlink cycle detected, or no longer exists
              );
              // Broken symlink, or symlink cycle detected, or no longer exists
              if (!stats) {
                continue;
              }
              // Directory
              if (stats.isDirectory()) {
                // Matched
                if (match & internal_match_kind_1.MatchKind.Directory && options.matchDirectories) {
                  yield yield __await(item.path);
                }
                // Descend?
                else if (!partialMatch) {
                  continue;
                }
                // Push the child items in reverse
                const childLevel = item.level + 1;
                const childItems = (yield __await(fs.promises.readdir(item.path))).map(
                  (x) => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel)
                );
                stack.push(...childItems.reverse());
              }
              // File
              else if (match & internal_match_kind_1.MatchKind.File) {
                yield yield __await(item.path);
              }
            }
          });
        }
        /**
         * Constructs a DefaultGlobber
         */
        static create(patterns, options) {
          return __awaiter(this, void 0, void 0, function* () {
            const result = new DefaultGlobber(options);
            if (IS_WINDOWS) {
              patterns = patterns.replace(/\r\n/g, "\n");
              patterns = patterns.replace(/\r/g, "\n");
            }
            const lines = patterns.split("\n").map((x) => x.trim());
            for (const line of lines) {
              // Empty or comment
              if (!line || line.startsWith("#")) {
                continue;
              }
              // Pattern
              else {
                result.patterns.push(new internal_pattern_1.Pattern(line));
              }
            }
            result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
            return result;
          });
        }
        static stat(item, options, traversalChain) {
          return __awaiter(this, void 0, void 0, function* () {
            // Note:
            // `stat` returns info about the target of a symlink (or symlink chain)
            // `lstat` returns info about a symlink itself
            let stats;
            if (options.followSymbolicLinks) {
              try {
                // Use `stat` (following symlinks)
                stats = yield fs.promises.stat(item.path);
              } catch (err) {
                if (err.code === "ENOENT") {
                  if (options.omitBrokenSymbolicLinks) {
                    core.debug(`Broken symlink '${item.path}'`);
                    return undefined;
                  }
                  throw new Error(
                    `No information found for the path '${item.path}'. This may indicate a broken symbolic link.`
                  );
                }
                throw err;
              }
            } else {
              // Use `lstat` (not following symlinks)
              stats = yield fs.promises.lstat(item.path);
            }
            // Note, isDirectory() returns false for the lstat of a symlink
            if (stats.isDirectory() && options.followSymbolicLinks) {
              // Get the realpath
              const realPath = yield fs.promises.realpath(item.path);
              // Fixup the traversal chain to match the item level
              while (traversalChain.length >= item.level) {
                traversalChain.pop();
              }
              // Test for a cycle
              if (traversalChain.some((x) => x === realPath)) {
                core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                return undefined;
              }
              // Update the traversal chain
              traversalChain.push(realPath);
            }
            return stats;
          });
        }
      }
      exports.DefaultGlobber = DefaultGlobber;
      //# sourceMappingURL=internal-globber.js.map

      /***/
    },

    /***/ 2448: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __asyncValues =
        (this && this.__asyncValues) ||
        function (o) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator],
            i;
          return m
            ? m.call(o)
            : ((o = typeof __values === "function" ? __values(o) : o[Symbol.iterator]()),
              (i = {}),
              verb("next"),
              verb("throw"),
              verb("return"),
              (i[Symbol.asyncIterator] = function () {
                return this;
              }),
              i);
          function verb(n) {
            i[n] =
              o[n] &&
              function (v) {
                return new Promise(function (resolve, reject) {
                  (v = o[n](v)), settle(resolve, reject, v.done, v.value);
                });
              };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function (v) {
              resolve({ value: v, done: d });
            }, reject);
          }
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hashFiles = void 0;
      const crypto = __importStar(__nccwpck_require__(6113));
      const core = __importStar(__nccwpck_require__(2186));
      const fs = __importStar(__nccwpck_require__(7147));
      const stream = __importStar(__nccwpck_require__(2781));
      const util = __importStar(__nccwpck_require__(3837));
      const path = __importStar(__nccwpck_require__(1017));
      function hashFiles(globber, currentWorkspace, verbose = false) {
        var e_1, _a;
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
          const writeDelegate = verbose ? core.info : core.debug;
          let hasMatch = false;
          const githubWorkspace = currentWorkspace
            ? currentWorkspace
            : (_b = process.env["GITHUB_WORKSPACE"]) !== null && _b !== void 0
            ? _b
            : process.cwd();
          const result = crypto.createHash("sha256");
          let count = 0;
          try {
            for (var _c = __asyncValues(globber.globGenerator()), _d; (_d = yield _c.next()), !_d.done; ) {
              const file = _d.value;
              writeDelegate(file);
              if (!file.startsWith(`${githubWorkspace}${path.sep}`)) {
                writeDelegate(`Ignore '${file}' since it is not under GITHUB_WORKSPACE.`);
                continue;
              }
              if (fs.statSync(file).isDirectory()) {
                writeDelegate(`Skip directory '${file}'.`);
                continue;
              }
              const hash = crypto.createHash("sha256");
              const pipeline = util.promisify(stream.pipeline);
              yield pipeline(fs.createReadStream(file), hash);
              result.write(hash.digest());
              count++;
              if (!hasMatch) {
                hasMatch = true;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d && !_d.done && (_a = _c.return)) yield _a.call(_c);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          result.end();
          if (hasMatch) {
            writeDelegate(`Found ${count} files to hash.`);
            return result.digest("hex");
          } else {
            writeDelegate(`No matches found for glob`);
            return "";
          }
        });
      }
      exports.hashFiles = hashFiles;
      //# sourceMappingURL=internal-hash-files.js.map

      /***/
    },

    /***/ 1063: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MatchKind = void 0;
      /**
       * Indicates whether a pattern matches a path
       */
      var MatchKind;
      (function (MatchKind) {
        /** Not matched */
        MatchKind[(MatchKind["None"] = 0)] = "None";
        /** Matched if the path is a directory */
        MatchKind[(MatchKind["Directory"] = 1)] = "Directory";
        /** Matched if the path is a regular file */
        MatchKind[(MatchKind["File"] = 2)] = "File";
        /** Matched */
        MatchKind[(MatchKind["All"] = 3)] = "All";
      })((MatchKind = exports.MatchKind || (exports.MatchKind = {})));
      //# sourceMappingURL=internal-match-kind.js.map

      /***/
    },

    /***/ 1849: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.safeTrimTrailingSeparator =
        exports.normalizeSeparators =
        exports.hasRoot =
        exports.hasAbsoluteRoot =
        exports.ensureAbsoluteRoot =
        exports.dirname =
          void 0;
      const path = __importStar(__nccwpck_require__(1017));
      const assert_1 = __importDefault(__nccwpck_require__(9491));
      const IS_WINDOWS = process.platform === "win32";
      /**
       * Similar to path.dirname except normalizes the path separators and slightly better handling for Windows UNC paths.
       *
       * For example, on Linux/macOS:
       * - `/               => /`
       * - `/hello          => /`
       *
       * For example, on Windows:
       * - `C:\             => C:\`
       * - `C:\hello        => C:\`
       * - `C:              => C:`
       * - `C:hello         => C:`
       * - `\               => \`
       * - `\hello          => \`
       * - `\\hello         => \\hello`
       * - `\\hello\world   => \\hello\world`
       */
      function dirname(p) {
        // Normalize slashes and trim unnecessary trailing slash
        p = safeTrimTrailingSeparator(p);
        // Windows UNC root, e.g. \\hello or \\hello\world
        if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
          return p;
        }
        // Get dirname
        let result = path.dirname(p);
        // Trim trailing slash for Windows UNC root, e.g. \\hello\world\
        if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
          result = safeTrimTrailingSeparator(result);
        }
        return result;
      }
      exports.dirname = dirname;
      /**
       * Roots the path if not already rooted. On Windows, relative roots like `\`
       * or `C:` are expanded based on the current working directory.
       */
      function ensureAbsoluteRoot(root, itemPath) {
        assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
        assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
        // Already rooted
        if (hasAbsoluteRoot(itemPath)) {
          return itemPath;
        }
        // Windows
        if (IS_WINDOWS) {
          // Check for itemPath like C: or C:foo
          if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
            let cwd = process.cwd();
            assert_1.default(
              cwd.match(/^[A-Z]:\\/i),
              `Expected current directory to start with an absolute drive root. Actual '${cwd}'`
            );
            // Drive letter matches cwd? Expand to cwd
            if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
              // Drive only, e.g. C:
              if (itemPath.length === 2) {
                // Preserve specified drive letter case (upper or lower)
                return `${itemPath[0]}:\\${cwd.substr(3)}`;
              }
              // Drive + path, e.g. C:foo
              else {
                if (!cwd.endsWith("\\")) {
                  cwd += "\\";
                }
                // Preserve specified drive letter case (upper or lower)
                return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
              }
            }
            // Different drive
            else {
              return `${itemPath[0]}:\\${itemPath.substr(2)}`;
            }
          }
          // Check for itemPath like \ or \foo
          else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
            const cwd = process.cwd();
            assert_1.default(
              cwd.match(/^[A-Z]:\\/i),
              `Expected current directory to start with an absolute drive root. Actual '${cwd}'`
            );
            return `${cwd[0]}:\\${itemPath.substr(1)}`;
          }
        }
        assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
        // Otherwise ensure root ends with a separator
        if (root.endsWith("/") || (IS_WINDOWS && root.endsWith("\\"))) {
          // Intentionally empty
        } else {
          // Append separator
          root += path.sep;
        }
        return root + itemPath;
      }
      exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
      /**
       * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
       * `\\hello\share` and `C:\hello` (and using alternate separator).
       */
      function hasAbsoluteRoot(itemPath) {
        assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
        // Normalize separators
        itemPath = normalizeSeparators(itemPath);
        // Windows
        if (IS_WINDOWS) {
          // E.g. \\hello\share or C:\hello
          return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
        }
        // E.g. /hello
        return itemPath.startsWith("/");
      }
      exports.hasAbsoluteRoot = hasAbsoluteRoot;
      /**
       * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
       * `\`, `\hello`, `\\hello\share`, `C:`, and `C:\hello` (and using alternate separator).
       */
      function hasRoot(itemPath) {
        assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
        // Normalize separators
        itemPath = normalizeSeparators(itemPath);
        // Windows
        if (IS_WINDOWS) {
          // E.g. \ or \hello or \\hello
          // E.g. C: or C:\hello
          return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
        }
        // E.g. /hello
        return itemPath.startsWith("/");
      }
      exports.hasRoot = hasRoot;
      /**
       * Removes redundant slashes and converts `/` to `\` on Windows
       */
      function normalizeSeparators(p) {
        p = p || "";
        // Windows
        if (IS_WINDOWS) {
          // Convert slashes on Windows
          p = p.replace(/\//g, "\\");
          // Remove redundant slashes
          const isUnc = /^\\\\+[^\\]/.test(p); // e.g. \\hello
          return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\"); // preserve leading \\ for UNC
        }
        // Remove redundant slashes
        return p.replace(/\/\/+/g, "/");
      }
      exports.normalizeSeparators = normalizeSeparators;
      /**
       * Normalizes the path separators and trims the trailing separator (when safe).
       * For example, `/foo/ => /foo` but `/ => /`
       */
      function safeTrimTrailingSeparator(p) {
        // Short-circuit if empty
        if (!p) {
          return "";
        }
        // Normalize separators
        p = normalizeSeparators(p);
        // No trailing slash
        if (!p.endsWith(path.sep)) {
          return p;
        }
        // Check '/' on Linux/macOS and '\' on Windows
        if (p === path.sep) {
          return p;
        }
        // On Windows check if drive root. E.g. C:\
        if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
          return p;
        }
        // Otherwise trim trailing slash
        return p.substr(0, p.length - 1);
      }
      exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
      //# sourceMappingURL=internal-path-helper.js.map

      /***/
    },

    /***/ 6836: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Path = void 0;
      const path = __importStar(__nccwpck_require__(1017));
      const pathHelper = __importStar(__nccwpck_require__(1849));
      const assert_1 = __importDefault(__nccwpck_require__(9491));
      const IS_WINDOWS = process.platform === "win32";
      /**
       * Helper class for parsing paths into segments
       */
      class Path {
        /**
         * Constructs a Path
         * @param itemPath Path or array of segments
         */
        constructor(itemPath) {
          this.segments = [];
          // String
          if (typeof itemPath === "string") {
            assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
            // Not rooted
            if (!pathHelper.hasRoot(itemPath)) {
              this.segments = itemPath.split(path.sep);
            }
            // Rooted
            else {
              // Add all segments, while not at the root
              let remaining = itemPath;
              let dir = pathHelper.dirname(remaining);
              while (dir !== remaining) {
                // Add the segment
                const basename = path.basename(remaining);
                this.segments.unshift(basename);
                // Truncate the last segment
                remaining = dir;
                dir = pathHelper.dirname(remaining);
              }
              // Remainder is the root
              this.segments.unshift(remaining);
            }
          }
          // Array
          else {
            // Must not be empty
            assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
            // Each segment
            for (let i = 0; i < itemPath.length; i++) {
              let segment = itemPath[i];
              // Must not be empty
              assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
              // Normalize slashes
              segment = pathHelper.normalizeSeparators(itemPath[i]);
              // Root segment
              if (i === 0 && pathHelper.hasRoot(segment)) {
                segment = pathHelper.safeTrimTrailingSeparator(segment);
                assert_1.default(
                  segment === pathHelper.dirname(segment),
                  `Parameter 'itemPath' root segment contains information for multiple segments`
                );
                this.segments.push(segment);
              }
              // All other segments
              else {
                // Must not contain slash
                assert_1.default(
                  !segment.includes(path.sep),
                  `Parameter 'itemPath' contains unexpected path separators`
                );
                this.segments.push(segment);
              }
            }
          }
        }
        /**
         * Converts the path to it's string representation
         */
        toString() {
          // First segment
          let result = this.segments[0];
          // All others
          let skipSlash = result.endsWith(path.sep) || (IS_WINDOWS && /^[A-Z]:$/i.test(result));
          for (let i = 1; i < this.segments.length; i++) {
            if (skipSlash) {
              skipSlash = false;
            } else {
              result += path.sep;
            }
            result += this.segments[i];
          }
          return result;
        }
      }
      exports.Path = Path;
      //# sourceMappingURL=internal-path.js.map

      /***/
    },

    /***/ 9005: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partialMatch = exports.match = exports.getSearchPaths = void 0;
      const pathHelper = __importStar(__nccwpck_require__(1849));
      const internal_match_kind_1 = __nccwpck_require__(1063);
      const IS_WINDOWS = process.platform === "win32";
      /**
       * Given an array of patterns, returns an array of paths to search.
       * Duplicates and paths under other included paths are filtered out.
       */
      function getSearchPaths(patterns) {
        // Ignore negate patterns
        patterns = patterns.filter((x) => !x.negate);
        // Create a map of all search paths
        const searchPathMap = {};
        for (const pattern of patterns) {
          const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
          searchPathMap[key] = "candidate";
        }
        const result = [];
        for (const pattern of patterns) {
          // Check if already included
          const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
          if (searchPathMap[key] === "included") {
            continue;
          }
          // Check for an ancestor search path
          let foundAncestor = false;
          let tempKey = key;
          let parent = pathHelper.dirname(tempKey);
          while (parent !== tempKey) {
            if (searchPathMap[parent]) {
              foundAncestor = true;
              break;
            }
            tempKey = parent;
            parent = pathHelper.dirname(tempKey);
          }
          // Include the search pattern in the result
          if (!foundAncestor) {
            result.push(pattern.searchPath);
            searchPathMap[key] = "included";
          }
        }
        return result;
      }
      exports.getSearchPaths = getSearchPaths;
      /**
       * Matches the patterns against the path
       */
      function match(patterns, itemPath) {
        let result = internal_match_kind_1.MatchKind.None;
        for (const pattern of patterns) {
          if (pattern.negate) {
            result &= ~pattern.match(itemPath);
          } else {
            result |= pattern.match(itemPath);
          }
        }
        return result;
      }
      exports.match = match;
      /**
       * Checks whether to descend further into the directory
       */
      function partialMatch(patterns, itemPath) {
        return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
      }
      exports.partialMatch = partialMatch;
      //# sourceMappingURL=internal-pattern-helper.js.map

      /***/
    },

    /***/ 4536: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Pattern = void 0;
      const os = __importStar(__nccwpck_require__(2037));
      const path = __importStar(__nccwpck_require__(1017));
      const pathHelper = __importStar(__nccwpck_require__(1849));
      const assert_1 = __importDefault(__nccwpck_require__(9491));
      const minimatch_1 = __nccwpck_require__(3973);
      const internal_match_kind_1 = __nccwpck_require__(1063);
      const internal_path_1 = __nccwpck_require__(6836);
      const IS_WINDOWS = process.platform === "win32";
      class Pattern {
        constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
          /**
           * Indicates whether matches should be excluded from the result set
           */
          this.negate = false;
          // Pattern overload
          let pattern;
          if (typeof patternOrNegate === "string") {
            pattern = patternOrNegate.trim();
          }
          // Segments overload
          else {
            // Convert to pattern
            segments = segments || [];
            assert_1.default(segments.length, `Parameter 'segments' must not empty`);
            const root = Pattern.getLiteral(segments[0]);
            assert_1.default(
              root && pathHelper.hasAbsoluteRoot(root),
              `Parameter 'segments' first element must be a root path`
            );
            pattern = new internal_path_1.Path(segments).toString().trim();
            if (patternOrNegate) {
              pattern = `!${pattern}`;
            }
          }
          // Negate
          while (pattern.startsWith("!")) {
            this.negate = !this.negate;
            pattern = pattern.substr(1).trim();
          }
          // Normalize slashes and ensures absolute root
          pattern = Pattern.fixupPattern(pattern, homedir);
          // Segments
          this.segments = new internal_path_1.Path(pattern).segments;
          // Trailing slash indicates the pattern should only match directories, not regular files
          this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path.sep);
          pattern = pathHelper.safeTrimTrailingSeparator(pattern);
          // Search path (literal path prior to the first glob segment)
          let foundGlob = false;
          const searchSegments = this.segments
            .map((x) => Pattern.getLiteral(x))
            .filter((x) => !foundGlob && !(foundGlob = x === ""));
          this.searchPath = new internal_path_1.Path(searchSegments).toString();
          // Root RegExp (required when determining partial match)
          this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
          this.isImplicitPattern = isImplicitPattern;
          // Create minimatch
          const minimatchOptions = {
            dot: true,
            nobrace: true,
            nocase: IS_WINDOWS,
            nocomment: true,
            noext: true,
            nonegate: true
          };
          pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
          this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
        }
        /**
         * Matches the pattern against the specified path
         */
        match(itemPath) {
          // Last segment is globstar?
          if (this.segments[this.segments.length - 1] === "**") {
            // Normalize slashes
            itemPath = pathHelper.normalizeSeparators(itemPath);
            // Append a trailing slash. Otherwise Minimatch will not match the directory immediately
            // preceding the globstar. For example, given the pattern `/foo/**`, Minimatch returns
            // false for `/foo` but returns true for `/foo/`. Append a trailing slash to handle that quirk.
            if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
              // Note, this is safe because the constructor ensures the pattern has an absolute root.
              // For example, formats like C: and C:foo on Windows are resolved to an absolute root.
              itemPath = `${itemPath}${path.sep}`;
            }
          } else {
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
          }
          // Match
          if (this.minimatch.match(itemPath)) {
            return this.trailingSeparator
              ? internal_match_kind_1.MatchKind.Directory
              : internal_match_kind_1.MatchKind.All;
          }
          return internal_match_kind_1.MatchKind.None;
        }
        /**
         * Indicates whether the pattern may match descendants of the specified path
         */
        partialMatch(itemPath) {
          // Normalize slashes and trim unnecessary trailing slash
          itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
          // matchOne does not handle root path correctly
          if (pathHelper.dirname(itemPath) === itemPath) {
            return this.rootRegExp.test(itemPath);
          }
          return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
        }
        /**
         * Escapes glob patterns within a path
         */
        static globEscape(s) {
          return (IS_WINDOWS ? s : s.replace(/\\/g, "\\\\")) // escape '\' on Linux/macOS
            .replace(/(\[)(?=[^/]+\])/g, "[[]") // escape '[' when ']' follows within the path segment
            .replace(/\?/g, "[?]") // escape '?'
            .replace(/\*/g, "[*]"); // escape '*'
        }
        /**
         * Normalizes slashes and ensures absolute root
         */
        static fixupPattern(pattern, homedir) {
          // Empty
          assert_1.default(pattern, "pattern cannot be empty");
          // Must not contain `.` segment, unless first segment
          // Must not contain `..` segment
          const literalSegments = new internal_path_1.Path(pattern).segments.map((x) => Pattern.getLiteral(x));
          assert_1.default(
            literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."),
            `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`
          );
          // Must not contain globs in root, e.g. Windows UNC path \\foo\b*r
          assert_1.default(
            !pathHelper.hasRoot(pattern) || literalSegments[0],
            `Invalid pattern '${pattern}'. Root segment must not contain globs.`
          );
          // Normalize slashes
          pattern = pathHelper.normalizeSeparators(pattern);
          // Replace leading `.` segment
          if (pattern === "." || pattern.startsWith(`.${path.sep}`)) {
            pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
          }
          // Replace leading `~` segment
          else if (pattern === "~" || pattern.startsWith(`~${path.sep}`)) {
            homedir = homedir || os.homedir();
            assert_1.default(homedir, "Unable to determine HOME directory");
            assert_1.default(
              pathHelper.hasAbsoluteRoot(homedir),
              `Expected HOME directory to be a rooted path. Actual '${homedir}'`
            );
            pattern = Pattern.globEscape(homedir) + pattern.substr(1);
          }
          // Replace relative drive root, e.g. pattern is C: or C:foo
          else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
            let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
            if (pattern.length > 2 && !root.endsWith("\\")) {
              root += "\\";
            }
            pattern = Pattern.globEscape(root) + pattern.substr(2);
          }
          // Replace relative root, e.g. pattern is \ or \foo
          else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
            let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
            if (!root.endsWith("\\")) {
              root += "\\";
            }
            pattern = Pattern.globEscape(root) + pattern.substr(1);
          }
          // Otherwise ensure absolute root
          else {
            pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
          }
          return pathHelper.normalizeSeparators(pattern);
        }
        /**
         * Attempts to unescape a pattern segment to create a literal path segment.
         * Otherwise returns empty string.
         */
        static getLiteral(segment) {
          let literal = "";
          for (let i = 0; i < segment.length; i++) {
            const c = segment[i];
            // Escape
            if (c === "\\" && !IS_WINDOWS && i + 1 < segment.length) {
              literal += segment[++i];
              continue;
            }
            // Wildcard
            else if (c === "*" || c === "?") {
              return "";
            }
            // Character set
            else if (c === "[" && i + 1 < segment.length) {
              let set = "";
              let closed = -1;
              for (let i2 = i + 1; i2 < segment.length; i2++) {
                const c2 = segment[i2];
                // Escape
                if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
                  set += segment[++i2];
                  continue;
                }
                // Closed
                else if (c2 === "]") {
                  closed = i2;
                  break;
                }
                // Otherwise
                else {
                  set += c2;
                }
              }
              // Closed?
              if (closed >= 0) {
                // Cannot convert
                if (set.length > 1) {
                  return "";
                }
                // Convert to literal
                if (set) {
                  literal += set;
                  i = closed;
                  continue;
                }
              }
              // Otherwise fall thru
            }
            // Append
            literal += c;
          }
          return literal;
        }
        /**
         * Escapes regexp special characters
         * https://javascript.info/regexp-escaping
         */
        static regExpEscape(s) {
          return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
        }
      }
      exports.Pattern = Pattern;
      //# sourceMappingURL=internal-pattern.js.map

      /***/
    },

    /***/ 9117: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SearchState = void 0;
      class SearchState {
        constructor(path, level) {
          this.path = path;
          this.level = level;
        }
      }
      exports.SearchState = SearchState;
      //# sourceMappingURL=internal-search-state.js.map

      /***/
    },

    /***/ 5526: /***/ function (__unused_webpack_module, exports) {
      "use strict";

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PersonalAccessTokenCredentialHandler =
        exports.BearerCredentialHandler =
        exports.BasicCredentialHandler =
          void 0;
      class BasicCredentialHandler {
        constructor(username, password) {
          this.username = username;
          this.password = password;
        }
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString(
            "base64"
          )}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      }
      exports.BasicCredentialHandler = BasicCredentialHandler;
      class BearerCredentialHandler {
        constructor(token) {
          this.token = token;
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Bearer ${this.token}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      }
      exports.BearerCredentialHandler = BearerCredentialHandler;
      class PersonalAccessTokenCredentialHandler {
        constructor(token) {
          this.token = token;
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error("The request has no headers");
          }
          options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false;
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error("not implemented");
          });
        }
      }
      exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
      //# sourceMappingURL=auth.js.map

      /***/
    },

    /***/ 6255: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      /* eslint-disable @typescript-eslint/no-explicit-any */
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpClient =
        exports.isHttps =
        exports.HttpClientResponse =
        exports.HttpClientError =
        exports.getProxyUrl =
        exports.MediaTypes =
        exports.Headers =
        exports.HttpCodes =
          void 0;
      const http = __importStar(__nccwpck_require__(3685));
      const https = __importStar(__nccwpck_require__(5687));
      const pm = __importStar(__nccwpck_require__(9835));
      const tunnel = __importStar(__nccwpck_require__(4294));
      var HttpCodes;
      (function (HttpCodes) {
        HttpCodes[(HttpCodes["OK"] = 200)] = "OK";
        HttpCodes[(HttpCodes["MultipleChoices"] = 300)] = "MultipleChoices";
        HttpCodes[(HttpCodes["MovedPermanently"] = 301)] = "MovedPermanently";
        HttpCodes[(HttpCodes["ResourceMoved"] = 302)] = "ResourceMoved";
        HttpCodes[(HttpCodes["SeeOther"] = 303)] = "SeeOther";
        HttpCodes[(HttpCodes["NotModified"] = 304)] = "NotModified";
        HttpCodes[(HttpCodes["UseProxy"] = 305)] = "UseProxy";
        HttpCodes[(HttpCodes["SwitchProxy"] = 306)] = "SwitchProxy";
        HttpCodes[(HttpCodes["TemporaryRedirect"] = 307)] = "TemporaryRedirect";
        HttpCodes[(HttpCodes["PermanentRedirect"] = 308)] = "PermanentRedirect";
        HttpCodes[(HttpCodes["BadRequest"] = 400)] = "BadRequest";
        HttpCodes[(HttpCodes["Unauthorized"] = 401)] = "Unauthorized";
        HttpCodes[(HttpCodes["PaymentRequired"] = 402)] = "PaymentRequired";
        HttpCodes[(HttpCodes["Forbidden"] = 403)] = "Forbidden";
        HttpCodes[(HttpCodes["NotFound"] = 404)] = "NotFound";
        HttpCodes[(HttpCodes["MethodNotAllowed"] = 405)] = "MethodNotAllowed";
        HttpCodes[(HttpCodes["NotAcceptable"] = 406)] = "NotAcceptable";
        HttpCodes[(HttpCodes["ProxyAuthenticationRequired"] = 407)] = "ProxyAuthenticationRequired";
        HttpCodes[(HttpCodes["RequestTimeout"] = 408)] = "RequestTimeout";
        HttpCodes[(HttpCodes["Conflict"] = 409)] = "Conflict";
        HttpCodes[(HttpCodes["Gone"] = 410)] = "Gone";
        HttpCodes[(HttpCodes["TooManyRequests"] = 429)] = "TooManyRequests";
        HttpCodes[(HttpCodes["InternalServerError"] = 500)] = "InternalServerError";
        HttpCodes[(HttpCodes["NotImplemented"] = 501)] = "NotImplemented";
        HttpCodes[(HttpCodes["BadGateway"] = 502)] = "BadGateway";
        HttpCodes[(HttpCodes["ServiceUnavailable"] = 503)] = "ServiceUnavailable";
        HttpCodes[(HttpCodes["GatewayTimeout"] = 504)] = "GatewayTimeout";
      })((HttpCodes = exports.HttpCodes || (exports.HttpCodes = {})));
      var Headers;
      (function (Headers) {
        Headers["Accept"] = "accept";
        Headers["ContentType"] = "content-type";
      })((Headers = exports.Headers || (exports.Headers = {})));
      var MediaTypes;
      (function (MediaTypes) {
        MediaTypes["ApplicationJson"] = "application/json";
      })((MediaTypes = exports.MediaTypes || (exports.MediaTypes = {})));
      /**
       * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      function getProxyUrl(serverUrl) {
        const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
        return proxyUrl ? proxyUrl.href : "";
      }
      exports.getProxyUrl = getProxyUrl;
      const HttpRedirectCodes = [
        HttpCodes.MovedPermanently,
        HttpCodes.ResourceMoved,
        HttpCodes.SeeOther,
        HttpCodes.TemporaryRedirect,
        HttpCodes.PermanentRedirect
      ];
      const HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];
      const RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
      const ExponentialBackoffCeiling = 10;
      const ExponentialBackoffTimeSlice = 5;
      class HttpClientError extends Error {
        constructor(message, statusCode) {
          super(message);
          this.name = "HttpClientError";
          this.statusCode = statusCode;
          Object.setPrototypeOf(this, HttpClientError.prototype);
        }
      }
      exports.HttpClientError = HttpClientError;
      class HttpClientResponse {
        constructor(message) {
          this.message = message;
        }
        readBody() {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) =>
              __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on("data", (chunk) => {
                  output = Buffer.concat([output, chunk]);
                });
                this.message.on("end", () => {
                  resolve(output.toString());
                });
              })
            );
          });
        }
        readBodyBuffer() {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) =>
              __awaiter(this, void 0, void 0, function* () {
                const chunks = [];
                this.message.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                this.message.on("end", () => {
                  resolve(Buffer.concat(chunks));
                });
              })
            );
          });
        }
      }
      exports.HttpClientResponse = HttpClientResponse;
      function isHttps(requestUrl) {
        const parsedUrl = new URL(requestUrl);
        return parsedUrl.protocol === "https:";
      }
      exports.isHttps = isHttps;
      class HttpClient {
        constructor(userAgent, handlers, requestOptions) {
          this._ignoreSslError = false;
          this._allowRedirects = true;
          this._allowRedirectDowngrade = false;
          this._maxRedirects = 50;
          this._allowRetries = false;
          this._maxRetries = 1;
          this._keepAlive = false;
          this._disposed = false;
          this.userAgent = userAgent;
          this.handlers = handlers || [];
          this.requestOptions = requestOptions;
          if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
              this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
              this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
              this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
              this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
              this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
              this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
              this._maxRetries = requestOptions.maxRetries;
            }
          }
        }
        options(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
          });
        }
        get(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("GET", requestUrl, null, additionalHeaders || {});
          });
        }
        del(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("DELETE", requestUrl, null, additionalHeaders || {});
          });
        }
        post(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("POST", requestUrl, data, additionalHeaders || {});
          });
        }
        patch(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("PATCH", requestUrl, data, additionalHeaders || {});
          });
        }
        put(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("PUT", requestUrl, data, additionalHeaders || {});
          });
        }
        head(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request("HEAD", requestUrl, null, additionalHeaders || {});
          });
        }
        sendStream(verb, requestUrl, stream, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
          });
        }
        /**
         * Gets a typed object from an endpoint
         * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
         */
        getJson(requestUrl, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.Accept,
              MediaTypes.ApplicationJson
            );
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        postJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.Accept,
              MediaTypes.ApplicationJson
            );
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        putJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.Accept,
              MediaTypes.ApplicationJson
            );
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        patchJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.Accept,
              MediaTypes.ApplicationJson
            );
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(
              additionalHeaders,
              Headers.ContentType,
              MediaTypes.ApplicationJson
            );
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
          });
        }
        /**
         * Makes a raw http request.
         * All other methods such as get, post, patch, and request ultimately call this.
         * Prefer get, del, post and patch
         */
        request(verb, requestUrl, data, headers) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
              throw new Error("Client has already been disposed.");
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
            let numTries = 0;
            let response;
            do {
              response = yield this.requestRaw(info, data);
              // Check if it's an authentication challenge
              if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (const handler of this.handlers) {
                  if (handler.canHandleAuthentication(response)) {
                    authenticationHandler = handler;
                    break;
                  }
                }
                if (authenticationHandler) {
                  return authenticationHandler.handleAuthentication(this, info, data);
                } else {
                  // We have received an unauthorized response but have no handlers to handle it.
                  // Let the response return to the caller.
                  return response;
                }
              }
              let redirectsRemaining = this._maxRedirects;
              while (
                response.message.statusCode &&
                HttpRedirectCodes.includes(response.message.statusCode) &&
                this._allowRedirects &&
                redirectsRemaining > 0
              ) {
                const redirectUrl = response.message.headers["location"];
                if (!redirectUrl) {
                  // if there's no location to redirect to, we won't
                  break;
                }
                const parsedRedirectUrl = new URL(redirectUrl);
                if (
                  parsedUrl.protocol === "https:" &&
                  parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                  !this._allowRedirectDowngrade
                ) {
                  throw new Error(
                    "Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true."
                  );
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                yield response.readBody();
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                  for (const header in headers) {
                    // header names are case insensitive
                    if (header.toLowerCase() === "authorization") {
                      delete headers[header];
                    }
                  }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = yield this.requestRaw(info, data);
                redirectsRemaining--;
              }
              if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                // If not a retry code, return immediately instead of retrying
                return response;
              }
              numTries += 1;
              if (numTries < maxTries) {
                yield response.readBody();
                yield this._performExponentialBackoff(numTries);
              }
            } while (numTries < maxTries);
            return response;
          });
        }
        /**
         * Needs to be called if keepAlive is set to true in request options.
         */
        dispose() {
          if (this._agent) {
            this._agent.destroy();
          }
          this._disposed = true;
        }
        /**
         * Raw request.
         * @param info
         * @param data
         */
        requestRaw(info, data) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
              function callbackForResult(err, res) {
                if (err) {
                  reject(err);
                } else if (!res) {
                  // If `err` is not passed, then `res` must be passed.
                  reject(new Error("Unknown error"));
                } else {
                  resolve(res);
                }
              }
              this.requestRawWithCallback(info, data, callbackForResult);
            });
          });
        }
        /**
         * Raw request with callback.
         * @param info
         * @param data
         * @param onResult
         */
        requestRawWithCallback(info, data, onResult) {
          if (typeof data === "string") {
            if (!info.options.headers) {
              info.options.headers = {};
            }
            info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
          }
          let callbackCalled = false;
          function handleResult(err, res) {
            if (!callbackCalled) {
              callbackCalled = true;
              onResult(err, res);
            }
          }
          const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
          });
          let socket;
          req.on("socket", (sock) => {
            socket = sock;
          });
          // If we ever get disconnected, we want the socket to timeout eventually
          req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
              socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
          });
          req.on("error", function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
          });
          if (data && typeof data === "string") {
            req.write(data, "utf8");
          }
          if (data && typeof data !== "string") {
            data.on("close", function () {
              req.end();
            });
            data.pipe(req);
          } else {
            req.end();
          }
        }
        /**
         * Gets an http agent. This function is useful when you need an http agent that handles
         * routing through a proxy server - depending upon the url and proxy environment variables.
         * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
         */
        getAgent(serverUrl) {
          const parsedUrl = new URL(serverUrl);
          return this._getAgent(parsedUrl);
        }
        _prepareRequest(method, requestUrl, headers) {
          const info = {};
          info.parsedUrl = requestUrl;
          const usingSsl = info.parsedUrl.protocol === "https:";
          info.httpModule = usingSsl ? https : http;
          const defaultPort = usingSsl ? 443 : 80;
          info.options = {};
          info.options.host = info.parsedUrl.hostname;
          info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
          info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
          info.options.method = method;
          info.options.headers = this._mergeHeaders(headers);
          if (this.userAgent != null) {
            info.options.headers["user-agent"] = this.userAgent;
          }
          info.options.agent = this._getAgent(info.parsedUrl);
          // gives handlers an opportunity to participate
          if (this.handlers) {
            for (const handler of this.handlers) {
              handler.prepareRequest(info.options);
            }
          }
          return info;
        }
        _mergeHeaders(headers) {
          if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
          }
          return lowercaseKeys(headers || {});
        }
        _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
          let clientHeader;
          if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
          }
          return additionalHeaders[header] || clientHeader || _default;
        }
        _getAgent(parsedUrl) {
          let agent;
          const proxyUrl = pm.getProxyUrl(parsedUrl);
          const useProxy = proxyUrl && proxyUrl.hostname;
          if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
          }
          if (this._keepAlive && !useProxy) {
            agent = this._agent;
          }
          // if agent is already assigned use that agent.
          if (agent) {
            return agent;
          }
          const usingSsl = parsedUrl.protocol === "https:";
          let maxSockets = 100;
          if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
          }
          // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
          if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
              maxSockets,
              keepAlive: this._keepAlive,
              proxy: Object.assign(
                Object.assign(
                  {},
                  (proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                  }
                ),
                { host: proxyUrl.hostname, port: proxyUrl.port }
              )
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === "https:";
            if (usingSsl) {
              tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            } else {
              tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
          }
          // if reusing agent across request and tunneling agent isn't assigned create a new agent
          if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
          }
          // if not using private agent and tunnel agent isn't setup then use global agent
          if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
          }
          if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
              rejectUnauthorized: false
            });
          }
          return agent;
        }
        _performExponentialBackoff(retryNumber) {
          return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise((resolve) => setTimeout(() => resolve(), ms));
          });
        }
        _processResponse(res, options) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) =>
              __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                  statusCode,
                  result: null,
                  headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                  resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                  if (typeof value === "string") {
                    const a = new Date(value);
                    if (!isNaN(a.valueOf())) {
                      return a;
                    }
                  }
                  return value;
                }
                let obj;
                let contents;
                try {
                  contents = yield res.readBody();
                  if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                      obj = JSON.parse(contents, dateTimeDeserializer);
                    } else {
                      obj = JSON.parse(contents);
                    }
                    response.result = obj;
                  }
                  response.headers = res.message.headers;
                } catch (err) {
                  // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                  let msg;
                  // if exception/error in body, attempt to get better error
                  if (obj && obj.message) {
                    msg = obj.message;
                  } else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents;
                  } else {
                    msg = `Failed request: (${statusCode})`;
                  }
                  const err = new HttpClientError(msg, statusCode);
                  err.result = response.result;
                  reject(err);
                } else {
                  resolve(response);
                }
              })
            );
          });
        }
      }
      exports.HttpClient = HttpClient;
      const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 9835: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkBypass = exports.getProxyUrl = void 0;
      function getProxyUrl(reqUrl) {
        const usingSsl = reqUrl.protocol === "https:";
        if (checkBypass(reqUrl)) {
          return undefined;
        }
        const proxyVar = (() => {
          if (usingSsl) {
            return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
          } else {
            return process.env["http_proxy"] || process.env["HTTP_PROXY"];
          }
        })();
        if (proxyVar) {
          try {
            return new URL(proxyVar);
          } catch (_a) {
            if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
              return new URL(`http://${proxyVar}`);
          }
        } else {
          return undefined;
        }
      }
      exports.getProxyUrl = getProxyUrl;
      function checkBypass(reqUrl) {
        if (!reqUrl.hostname) {
          return false;
        }
        const reqHost = reqUrl.hostname;
        if (isLoopbackAddress(reqHost)) {
          return true;
        }
        const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
        if (!noProxy) {
          return false;
        }
        // Determine the request port
        let reqPort;
        if (reqUrl.port) {
          reqPort = Number(reqUrl.port);
        } else if (reqUrl.protocol === "http:") {
          reqPort = 80;
        } else if (reqUrl.protocol === "https:") {
          reqPort = 443;
        }
        // Format the request hostname and hostname with port
        const upperReqHosts = [reqUrl.hostname.toUpperCase()];
        if (typeof reqPort === "number") {
          upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
        }
        // Compare request host against noproxy
        for (const upperNoProxyItem of noProxy
          .split(",")
          .map((x) => x.trim().toUpperCase())
          .filter((x) => x)) {
          if (
            upperNoProxyItem === "*" ||
            upperReqHosts.some(
              (x) =>
                x === upperNoProxyItem ||
                x.endsWith(`.${upperNoProxyItem}`) ||
                (upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))
            )
          ) {
            return true;
          }
        }
        return false;
      }
      exports.checkBypass = checkBypass;
      function isLoopbackAddress(host) {
        const hostLower = host.toLowerCase();
        return (
          hostLower === "localhost" ||
          hostLower.startsWith("127.") ||
          hostLower.startsWith("[::1]") ||
          hostLower.startsWith("[0:0:0:0:0:0:0:1]")
        );
      }
      //# sourceMappingURL=proxy.js.map

      /***/
    },

    /***/ 1962: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getCmdPath =
        exports.tryGetExecutablePath =
        exports.isRooted =
        exports.isDirectory =
        exports.exists =
        exports.READONLY =
        exports.UV_FS_O_EXLOCK =
        exports.IS_WINDOWS =
        exports.unlink =
        exports.symlink =
        exports.stat =
        exports.rmdir =
        exports.rm =
        exports.rename =
        exports.readlink =
        exports.readdir =
        exports.open =
        exports.mkdir =
        exports.lstat =
        exports.copyFile =
        exports.chmod =
          void 0;
      const fs = __importStar(__nccwpck_require__(7147));
      const path = __importStar(__nccwpck_require__(1017));
      (_a = fs.promises),
        // export const {open} = 'fs'
        (exports.chmod = _a.chmod),
        (exports.copyFile = _a.copyFile),
        (exports.lstat = _a.lstat),
        (exports.mkdir = _a.mkdir),
        (exports.open = _a.open),
        (exports.readdir = _a.readdir),
        (exports.readlink = _a.readlink),
        (exports.rename = _a.rename),
        (exports.rm = _a.rm),
        (exports.rmdir = _a.rmdir),
        (exports.stat = _a.stat),
        (exports.symlink = _a.symlink),
        (exports.unlink = _a.unlink);
      // export const {open} = 'fs'
      exports.IS_WINDOWS = process.platform === "win32";
      // See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691
      exports.UV_FS_O_EXLOCK = 0x10000000;
      exports.READONLY = fs.constants.O_RDONLY;
      function exists(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            yield exports.stat(fsPath);
          } catch (err) {
            if (err.code === "ENOENT") {
              return false;
            }
            throw err;
          }
          return true;
        });
      }
      exports.exists = exists;
      function isDirectory(fsPath, useStat = false) {
        return __awaiter(this, void 0, void 0, function* () {
          const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
          return stats.isDirectory();
        });
      }
      exports.isDirectory = isDirectory;
      /**
       * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
       * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
       */
      function isRooted(p) {
        p = normalizeSeparators(p);
        if (!p) {
          throw new Error('isRooted() parameter "p" cannot be empty');
        }
        if (exports.IS_WINDOWS) {
          return (
            p.startsWith("\\") || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
          ); // e.g. C: or C:\hello
        }
        return p.startsWith("/");
      }
      exports.isRooted = isRooted;
      /**
       * Best effort attempt to determine whether a file exists and is executable.
       * @param filePath    file path to check
       * @param extensions  additional file extensions to try
       * @return if file exists and is executable, returns the file path. otherwise empty string.
       */
      function tryGetExecutablePath(filePath, extensions) {
        return __awaiter(this, void 0, void 0, function* () {
          let stats = undefined;
          try {
            // test file exists
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              // eslint-disable-next-line no-console
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              // on Windows, test for valid extension
              const upperExt = path.extname(filePath).toUpperCase();
              if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
                return filePath;
              }
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
          // try each extension
          const originalFilePath = filePath;
          for (const extension of extensions) {
            filePath = originalFilePath + extension;
            stats = undefined;
            try {
              stats = yield exports.stat(filePath);
            } catch (err) {
              if (err.code !== "ENOENT") {
                // eslint-disable-next-line no-console
                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
              }
            }
            if (stats && stats.isFile()) {
              if (exports.IS_WINDOWS) {
                // preserve the case of the actual file (since an extension was appended)
                try {
                  const directory = path.dirname(filePath);
                  const upperName = path.basename(filePath).toUpperCase();
                  for (const actualName of yield exports.readdir(directory)) {
                    if (upperName === actualName.toUpperCase()) {
                      filePath = path.join(directory, actualName);
                      break;
                    }
                  }
                } catch (err) {
                  // eslint-disable-next-line no-console
                  console.log(
                    `Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`
                  );
                }
                return filePath;
              } else {
                if (isUnixExecutable(stats)) {
                  return filePath;
                }
              }
            }
          }
          return "";
        });
      }
      exports.tryGetExecutablePath = tryGetExecutablePath;
      function normalizeSeparators(p) {
        p = p || "";
        if (exports.IS_WINDOWS) {
          // convert slashes on Windows
          p = p.replace(/\//g, "\\");
          // remove redundant slashes
          return p.replace(/\\\\+/g, "\\");
        }
        // remove redundant slashes
        return p.replace(/\/\/+/g, "/");
      }
      // on Mac/Linux, test the execute bit
      //     R   W  X  R  W X R W X
      //   256 128 64 32 16 8 4 2 1
      function isUnixExecutable(stats) {
        return (
          (stats.mode & 1) > 0 ||
          ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
          ((stats.mode & 64) > 0 && stats.uid === process.getuid())
        );
      }
      // Get the path of cmd.exe in windows
      function getCmdPath() {
        var _a;
        return (_a = process.env["COMSPEC"]) !== null && _a !== void 0 ? _a : `cmd.exe`;
      }
      exports.getCmdPath = getCmdPath;
      //# sourceMappingURL=io-util.js.map

      /***/
    },

    /***/ 7436: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                }
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
      const assert_1 = __nccwpck_require__(9491);
      const path = __importStar(__nccwpck_require__(1017));
      const ioUtil = __importStar(__nccwpck_require__(1962));
      /**
       * Copies a file or folder.
       * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
       *
       * @param     source    source path
       * @param     dest      destination path
       * @param     options   optional. See CopyOptions.
       */
      function cp(source, dest, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const { force, recursive, copySourceDirectory } = readCopyOptions(options);
          const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
          // Dest is an existing file, but not forcing
          if (destStat && destStat.isFile() && !force) {
            return;
          }
          // If dest is an existing directory, should copy inside.
          const newDest =
            destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
          if (!(yield ioUtil.exists(source))) {
            throw new Error(`no such file or directory: ${source}`);
          }
          const sourceStat = yield ioUtil.stat(source);
          if (sourceStat.isDirectory()) {
            if (!recursive) {
              throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
            } else {
              yield cpDirRecursive(source, newDest, 0, force);
            }
          } else {
            if (path.relative(source, newDest) === "") {
              // a file cannot be copied to itself
              throw new Error(`'${newDest}' and '${source}' are the same file`);
            }
            yield copyFile(source, newDest, force);
          }
        });
      }
      exports.cp = cp;
      /**
       * Moves a path.
       *
       * @param     source    source path
       * @param     dest      destination path
       * @param     options   optional. See MoveOptions.
       */
      function mv(source, dest, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (yield ioUtil.exists(dest)) {
            let destExists = true;
            if (yield ioUtil.isDirectory(dest)) {
              // If dest is directory copy src into dest
              dest = path.join(dest, path.basename(source));
              destExists = yield ioUtil.exists(dest);
            }
            if (destExists) {
              if (options.force == null || options.force) {
                yield rmRF(dest);
              } else {
                throw new Error("Destination already exists");
              }
            }
          }
          yield mkdirP(path.dirname(dest));
          yield ioUtil.rename(source, dest);
        });
      }
      exports.mv = mv;
      /**
       * Remove a path recursively with force
       *
       * @param inputPath path to remove
       */
      function rmRF(inputPath) {
        return __awaiter(this, void 0, void 0, function* () {
          if (ioUtil.IS_WINDOWS) {
            // Check for invalid characters
            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
            if (/[*"<>|]/.test(inputPath)) {
              throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
            }
          }
          try {
            // note if path does not exist, error is silent
            yield ioUtil.rm(inputPath, {
              force: true,
              maxRetries: 3,
              recursive: true,
              retryDelay: 300
            });
          } catch (err) {
            throw new Error(`File was unable to be removed ${err}`);
          }
        });
      }
      exports.rmRF = rmRF;
      /**
       * Make a directory.  Creates the full path with folders in between
       * Will throw if it fails
       *
       * @param   fsPath        path to create
       * @returns Promise<void>
       */
      function mkdirP(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          assert_1.ok(fsPath, "a path argument must be provided");
          yield ioUtil.mkdir(fsPath, { recursive: true });
        });
      }
      exports.mkdirP = mkdirP;
      /**
       * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
       * If you check and the tool does not exist, it will throw.
       *
       * @param     tool              name of the tool
       * @param     check             whether to check if tool exists
       * @returns   Promise<string>   path to tool
       */
      function which(tool, check) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          // recursive when check=true
          if (check) {
            const result = yield which(tool, false);
            if (!result) {
              if (ioUtil.IS_WINDOWS) {
                throw new Error(
                  `Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`
                );
              } else {
                throw new Error(
                  `Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`
                );
              }
            }
            return result;
          }
          const matches = yield findInPath(tool);
          if (matches && matches.length > 0) {
            return matches[0];
          }
          return "";
        });
      }
      exports.which = which;
      /**
       * Returns a list of all occurrences of the given tool on the system path.
       *
       * @returns   Promise<string[]>  the paths of the tool
       */
      function findInPath(tool) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          // build the list of extensions to try
          const extensions = [];
          if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
            for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
              if (extension) {
                extensions.push(extension);
              }
            }
          }
          // if it's rooted, return it if exists. otherwise return empty.
          if (ioUtil.isRooted(tool)) {
            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
            if (filePath) {
              return [filePath];
            }
            return [];
          }
          // if any path separators, return empty
          if (tool.includes(path.sep)) {
            return [];
          }
          // build the list of directories
          //
          // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
          // it feels like we should not do this. Checking the current directory seems like more of a use
          // case of a shell, and the which() function exposed by the toolkit should strive for consistency
          // across platforms.
          const directories = [];
          if (process.env.PATH) {
            for (const p of process.env.PATH.split(path.delimiter)) {
              if (p) {
                directories.push(p);
              }
            }
          }
          // find all matches
          const matches = [];
          for (const directory of directories) {
            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
            if (filePath) {
              matches.push(filePath);
            }
          }
          return matches;
        });
      }
      exports.findInPath = findInPath;
      function readCopyOptions(options) {
        const force = options.force == null ? true : options.force;
        const recursive = Boolean(options.recursive);
        const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
        return { force, recursive, copySourceDirectory };
      }
      function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
        return __awaiter(this, void 0, void 0, function* () {
          // Ensure there is not a run away recursive copy
          if (currentDepth >= 255) return;
          currentDepth++;
          yield mkdirP(destDir);
          const files = yield ioUtil.readdir(sourceDir);
          for (const fileName of files) {
            const srcFile = `${sourceDir}/${fileName}`;
            const destFile = `${destDir}/${fileName}`;
            const srcFileStat = yield ioUtil.lstat(srcFile);
            if (srcFileStat.isDirectory()) {
              // Recurse
              yield cpDirRecursive(srcFile, destFile, currentDepth, force);
            } else {
              yield copyFile(srcFile, destFile, force);
            }
          }
          // Change the mode for the newly created directory
          yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
        });
      }
      // Buffered file copy
      function copyFile(srcFile, destFile, force) {
        return __awaiter(this, void 0, void 0, function* () {
          if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
            // unlink/re-link it
            try {
              yield ioUtil.lstat(destFile);
              yield ioUtil.unlink(destFile);
            } catch (e) {
              // Try to override file permission
              if (e.code === "EPERM") {
                yield ioUtil.chmod(destFile, "0666");
                yield ioUtil.unlink(destFile);
              }
              // other errors = it doesn't exist, no work to do
            }
            // Copy over symlink
            const symlinkFull = yield ioUtil.readlink(srcFile);
            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
          } else if (!(yield ioUtil.exists(destFile)) || force) {
            yield ioUtil.copyFile(srcFile, destFile);
          }
        });
      }
      //# sourceMappingURL=io.js.map

      /***/
    },

    /***/ 777: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var os = __nccwpck_require__(2037);
      var fs = __nccwpck_require__(7147);
      var child = __nccwpck_require__(2081);

      var DEFAULT_RESOLV_FILE = "/etc/resolv.conf";

      function getInterfaceName() {
        var val = "eth";
        var platform = os.platform();
        if (platform === "darwin") {
          val = "en";
        } else if (platform === "win32") {
          val = null;
        }
        return val;
      }

      function getIfconfigCMD() {
        if (os.platform() === "win32") {
          return "ipconfig/all";
        }
        return "/sbin/ifconfig";
      }

      // typeof os.networkInterfaces family is a number (v18.0.0)
      // types: 'IPv4' | 'IPv6' => 4 | 6
      // @see https://github.com/nodejs/node/issues/42861
      function matchName(actualFamily, expectedFamily) {
        if (expectedFamily === "IPv4") {
          return actualFamily === "IPv4" || actualFamily === 4;
        }
        if (expectedFamily === "IPv6") {
          return actualFamily === "IPv6" || actualFamily === 6;
        }
        return actualFamily === expectedFamily;
      }

      /**
       * Get all addresses.
       *
       * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
       * @param {Function(err, addr)} callback
       *  - {Object} addr {
       *    - {String} ip
       *    - {String} ipv6
       *    - {String} mac
       *  }
       */
      function address(interfaceName, callback) {
        if (typeof interfaceName === "function") {
          callback = interfaceName;
          interfaceName = null;
        }

        var addr = {
          ip: address.ip(interfaceName),
          ipv6: address.ipv6(interfaceName),
          mac: null
        };
        address.mac(interfaceName, function (err, mac) {
          if (mac) {
            addr.mac = mac;
          }
          callback(err, addr);
        });
      }

      address.interface = function (family, name) {
        var interfaces = os.networkInterfaces();
        var noName = !name;
        name = name || getInterfaceName();
        family = family || "IPv4";
        for (var i = -1; i < 8; i++) {
          var interfaceName = name + (i >= 0 ? i : ""); // support 'lo' and 'lo0'
          var items = interfaces[interfaceName];
          if (items) {
            for (var j = 0; j < items.length; j++) {
              var item = items[j];
              if (matchName(item.family, family)) {
                return item;
              }
            }
          }
        }

        if (noName) {
          // filter all loopback or local addresses
          for (var k in interfaces) {
            var items = interfaces[k];
            for (var i = 0; i < items.length; i++) {
              var item = items[i];
              // all 127 addresses are local and should be ignored
              if (matchName(item.family, family) && !item.address.startsWith("127.")) {
                return item;
              }
            }
          }
        }
        return;
      };

      /**
       * Get current machine IPv4
       *
       * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
       * @return {String} IP address
       */
      address.ip = function (interfaceName) {
        var item = address.interface("IPv4", interfaceName);
        return item && item.address;
      };

      /**
       * Get current machine IPv6
       *
       * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
       * @return {String} IP address
       */
      address.ipv6 = function (interfaceName) {
        var item = address.interface("IPv6", interfaceName);
        return item && item.address;
      };

      // osx start line 'en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500'
      // linux start line 'eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:0A:29  '
      var MAC_OSX_START_LINE = /^(\w+)\:\s+flags=/;
      var MAC_LINUX_START_LINE = /^(\w+)\s{2,}link encap:\w+/i;

      // ether 78:ca:39:b0:e6:7d
      // HWaddr 00:16:3E:00:0A:29
      var MAC_RE = (address.MAC_RE = /(?:ether|HWaddr)\s+((?:[a-z0-9]{2}\:){5}[a-z0-9]{2})/i);

      // osx: inet 192.168.2.104 netmask 0xffffff00 broadcast 192.168.2.255
      // linux: inet addr:10.125.5.202  Bcast:10.125.15.255  Mask:255.255.240.0
      var MAC_IP_RE = (address.MAC_IP_RE = /inet\s(?:addr\:)?(\d+\.\d+\.\d+\.\d+)/);

      function getMAC(content, interfaceName, matchIP) {
        var lines = content.split("\n");
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i].trimRight();
          var m = MAC_OSX_START_LINE.exec(line) || MAC_LINUX_START_LINE.exec(line);
          if (!m) {
            continue;
          }

          // check interface name
          var name = m[1];
          if (name.indexOf(interfaceName) !== 0) {
            continue;
          }

          var ip = null;
          var mac = null;
          var match = MAC_RE.exec(line);
          if (match) {
            mac = match[1];
          }

          i++;
          while (true) {
            line = lines[i];
            if (!line || MAC_OSX_START_LINE.exec(line) || MAC_LINUX_START_LINE.exec(line)) {
              i--;
              break; // hit next interface, handle next interface
            }
            if (!mac) {
              match = MAC_RE.exec(line);
              if (match) {
                mac = match[1];
              }
            }

            if (!ip) {
              match = MAC_IP_RE.exec(line);
              if (match) {
                ip = match[1];
              }
            }

            i++;
          }

          if (ip === matchIP) {
            return mac;
          }
        }
      }

      /**
       * Get current machine MAC address
       *
       * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
       * @param {Function(err, address)} callback
       */
      address.mac = function (interfaceName, callback) {
        if (typeof interfaceName === "function") {
          callback = interfaceName;
          interfaceName = null;
        }
        interfaceName = interfaceName || getInterfaceName();
        var item = address.interface("IPv4", interfaceName);
        if (!item) {
          return callback();
        }

        // https://github.com/nodejs/node/issues/13581
        // bug in node 7.x and <= 8.4.0
        if (!process.env.CI && (item.mac === "ff:00:00:00:00:00" || item.mac === "00:00:00:00:00:00")) {
          // wrong address, ignore it
          item.mac = "";
        }

        if (item.mac) {
          return callback(null, item.mac);
        }

        child.exec(getIfconfigCMD(), { timeout: 5000 }, function (err, stdout, stderr) {
          if (err || !stdout) {
            return callback(err);
          }

          var mac = getMAC(stdout || "", interfaceName, item.address);
          callback(null, mac);
        });
      };

      // nameserver 172.24.102.254
      var DNS_SERVER_RE = /^nameserver\s+(\d+\.\d+\.\d+\.\d+)$/i;

      /**
       * Get DNS servers.
       *
       * @param {String} [filepath] resolv config file path. default is '/etc/resolv.conf'.
       * @param {Function(err, servers)} callback
       */
      address.dns = function (filepath, callback) {
        if (typeof filepath === "function") {
          callback = filepath;
          filepath = null;
        }
        filepath = filepath || DEFAULT_RESOLV_FILE;
        fs.readFile(filepath, "utf8", function (err, content) {
          if (err) {
            return callback(err);
          }
          var servers = [];
          content = content || "";
          var lines = content.split("\n");
          for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            var m = DNS_SERVER_RE.exec(line);
            if (m) {
              servers.push(m[1]);
            }
          }

          callback(null, servers);
        });
      };

      module.exports = address;

      /***/
    },

    /***/ 4623: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      module.exports = __nccwpck_require__(5006);
      module.exports.HttpsAgent = __nccwpck_require__(5500);

      /***/
    },

    /***/ 1256: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var __webpack_unused_export__;
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      // patch from https://github.com/nodejs/node/blob/v7.2.1/lib/_http_agent.js

      const net = __nccwpck_require__(1808);
      const util = __nccwpck_require__(3837);
      const EventEmitter = __nccwpck_require__(2361);
      const debug = util.debuglog("http");

      // New Agent code.

      // The largest departure from the previous implementation is that
      // an Agent instance holds connections for a variable number of host:ports.
      // Surprisingly, this is still API compatible as far as third parties are
      // concerned. The only code that really notices the difference is the
      // request object.

      // Another departure is that all code related to HTTP parsing is in
      // ClientRequest.onSocket(). The Agent is now *strictly*
      // concerned with managing a connection pool.

      function Agent(options) {
        if (!(this instanceof Agent)) return new Agent(options);

        EventEmitter.call(this);

        var self = this;

        self.defaultPort = 80;
        self.protocol = "http:";

        self.options = util._extend({}, options);

        // don't confuse net and make it think that we're connecting to a pipe
        self.options.path = null;
        self.requests = {};
        self.sockets = {};
        self.freeSockets = {};
        self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;
        self.keepAlive = self.options.keepAlive || false;
        self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
        self.maxFreeSockets = self.options.maxFreeSockets || 256;

        // [patch start]
        // free keep-alive socket timeout. By default free socket do not have a timeout.
        self.freeSocketKeepAliveTimeout = self.options.freeSocketKeepAliveTimeout || 0;
        // working socket timeout. By default working socket do not have a timeout.
        self.timeout = self.options.timeout || 0;
        // the socket active time to live, even if it's in use
        this.socketActiveTTL = this.options.socketActiveTTL || null;
        // [patch end]

        self.on("free", function (socket, options) {
          var name = self.getName(options);
          debug("agent.on(free)", name);

          if (socket.writable && self.requests[name] && self.requests[name].length) {
            // [patch start]
            debug("continue handle next request");
            // [patch end]
            self.requests[name].shift().onSocket(socket);
            if (self.requests[name].length === 0) {
              // don't leak
              delete self.requests[name];
            }
          } else {
            // If there are no pending requests, then put it in
            // the freeSockets pool, but only if we're allowed to do so.
            var req = socket._httpMessage;
            if (req && req.shouldKeepAlive && socket.writable && self.keepAlive) {
              var freeSockets = self.freeSockets[name];
              var freeLen = freeSockets ? freeSockets.length : 0;
              var count = freeLen;
              if (self.sockets[name]) count += self.sockets[name].length;

              if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {
                socket.destroy();
              } else {
                freeSockets = freeSockets || [];
                self.freeSockets[name] = freeSockets;
                socket.setKeepAlive(true, self.keepAliveMsecs);
                socket.unref();
                socket._httpMessage = null;
                self.removeSocket(socket, options);
                freeSockets.push(socket);

                // [patch start]
                // Add a default error handler to avoid Unhandled 'error' event throw on idle socket
                // https://github.com/node-modules/agentkeepalive/issues/25
                // https://github.com/nodejs/node/pull/4482 (fixed in >= 4.4.0 and >= 5.4.0)
                if (socket.listeners("error").length === 0) {
                  socket.once("error", freeSocketErrorListener);
                }
                // set free keepalive timer
                // try to use socket custom freeSocketKeepAliveTimeout first
                const freeSocketKeepAliveTimeout = socket.freeSocketKeepAliveTimeout || self.freeSocketKeepAliveTimeout;
                socket.setTimeout(freeSocketKeepAliveTimeout);
                debug(`push to free socket queue and wait for ${freeSocketKeepAliveTimeout}ms`);
                // [patch end]
              }
            } else {
              socket.destroy();
            }
          }
        });
      }

      util.inherits(Agent, EventEmitter);
      exports.P = Agent;

      // [patch start]
      function freeSocketErrorListener(err) {
        var socket = this;
        debug("SOCKET ERROR on FREE socket:", err.message, err.stack);
        socket.destroy();
        socket.emit("agentRemove");
      }
      // [patch end]

      Agent.defaultMaxSockets = Infinity;

      Agent.prototype.createConnection = net.createConnection;

      // Get the key for a given set of request options
      Agent.prototype.getName = function getName(options) {
        var name = options.host || "localhost";

        name += ":";
        if (options.port) name += options.port;

        name += ":";
        if (options.localAddress) name += options.localAddress;

        // Pacify parallel/test-http-agent-getname by only appending
        // the ':' when options.family is set.
        if (options.family === 4 || options.family === 6) name += ":" + options.family;

        return name;
      };

      // [patch start]
      function handleSocketCreation(req) {
        return function (err, newSocket) {
          if (err) {
            process.nextTick(function () {
              req.emit("error", err);
            });
            return;
          }
          req.onSocket(newSocket);
        };
      }
      // [patch end]

      Agent.prototype.addRequest = function addRequest(req, options, port /*legacy*/, localAddress /*legacy*/) {
        // Legacy API: addRequest(req, host, port, localAddress)
        if (typeof options === "string") {
          options = {
            host: options,
            port,
            localAddress
          };
        }

        options = util._extend({}, options);
        options = util._extend(options, this.options);

        if (!options.servername) options.servername = calculateServerName(options, req);

        var name = this.getName(options);
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }

        var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
        var sockLen = freeLen + this.sockets[name].length;

        if (freeLen) {
          // we have a free socket, so use that.
          var socket = this.freeSockets[name].shift();
          debug("have free socket");

          // [patch start]
          // remove free socket error event handler
          socket.removeListener("error", freeSocketErrorListener);
          // restart the default timer
          socket.setTimeout(this.timeout);

          if (this.socketActiveTTL && Date.now() - socket.createdTime > this.socketActiveTTL) {
            debug(`socket ${socket.createdTime} expired`);
            socket.destroy();
            return this.createSocket(req, options, handleSocketCreation(req));
          }
          // [patch end]

          // don't leak
          if (!this.freeSockets[name].length) delete this.freeSockets[name];

          socket.ref();
          req.onSocket(socket);
          this.sockets[name].push(socket);
        } else if (sockLen < this.maxSockets) {
          debug("call onSocket", sockLen, freeLen);
          // If we are under maxSockets create a new one.
          // [patch start]
          this.createSocket(req, options, handleSocketCreation(req));
          // [patch end]
        } else {
          debug("wait for socket");
          // We are over limit so we'll add it to the queue.
          if (!this.requests[name]) {
            this.requests[name] = [];
          }
          this.requests[name].push(req);
        }
      };

      Agent.prototype.createSocket = function createSocket(req, options, cb) {
        var self = this;
        options = util._extend({}, options);
        options = util._extend(options, self.options);

        if (!options.servername) options.servername = calculateServerName(options, req);

        var name = self.getName(options);
        options._agentKey = name;

        debug("createConnection", name, options);
        options.encoding = null;
        var called = false;
        const newSocket = self.createConnection(options, oncreate);
        // [patch start]
        if (newSocket) {
          oncreate(null, Object.assign(newSocket, { createdTime: Date.now() }));
        }
        // [patch end]
        function oncreate(err, s) {
          if (called) return;
          called = true;
          if (err) return cb(err);
          if (!self.sockets[name]) {
            self.sockets[name] = [];
          }
          self.sockets[name].push(s);
          debug("sockets", name, self.sockets[name].length);

          function onFree() {
            self.emit("free", s, options);
          }
          s.on("free", onFree);

          function onClose(err) {
            debug("CLIENT socket onClose");
            // This is the only place where sockets get removed from the Agent.
            // If you want to remove a socket from the pool, just close it.
            // All socket errors end in a close event anyway.
            self.removeSocket(s, options);

            // [patch start]
            self.emit("close");
            // [patch end]
          }
          s.on("close", onClose);

          // [patch start]
          // start socket timeout handler
          function onTimeout() {
            debug("CLIENT socket onTimeout");
            s.destroy();
            // Remove it from freeSockets immediately to prevent new requests from being sent through this socket.
            self.removeSocket(s, options);
            self.emit("timeout");
          }
          s.on("timeout", onTimeout);
          // set the default timer
          s.setTimeout(self.timeout);
          // [patch end]

          function onRemove() {
            // We need this function for cases like HTTP 'upgrade'
            // (defined by WebSockets) where we need to remove a socket from the
            // pool because it'll be locked up indefinitely
            debug("CLIENT socket onRemove");
            self.removeSocket(s, options);
            s.removeListener("close", onClose);
            s.removeListener("free", onFree);
            s.removeListener("agentRemove", onRemove);

            // [patch start]
            // remove socket timeout handler
            s.setTimeout(0, onTimeout);
            // [patch end]
          }
          s.on("agentRemove", onRemove);
          cb(null, s);
        }
      };

      function calculateServerName(options, req) {
        let servername = options.host;
        const hostHeader = req.getHeader("host");
        if (hostHeader) {
          // abc => abc
          // abc:123 => abc
          // [::1] => ::1
          // [::1]:123 => ::1
          if (hostHeader.startsWith("[")) {
            const index = hostHeader.indexOf("]");
            if (index === -1) {
              // Leading '[', but no ']'. Need to do something...
              servername = hostHeader;
            } else {
              servername = hostHeader.substr(1, index - 1);
            }
          } else {
            servername = hostHeader.split(":", 1)[0];
          }
        }
        return servername;
      }

      Agent.prototype.removeSocket = function removeSocket(s, options) {
        var name = this.getName(options);
        debug("removeSocket", name, "writable:", s.writable);
        var sets = [this.sockets];

        // If the socket was destroyed, remove it from the free buffers too.
        if (!s.writable) sets.push(this.freeSockets);

        for (var sk = 0; sk < sets.length; sk++) {
          var sockets = sets[sk];

          if (sockets[name]) {
            var index = sockets[name].indexOf(s);
            if (index !== -1) {
              sockets[name].splice(index, 1);
              // Don't leak
              if (sockets[name].length === 0) delete sockets[name];
            }
          }
        }

        // [patch start]
        var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
        var sockLen = freeLen + (this.sockets[name] ? this.sockets[name].length : 0);
        // [patch end]

        if (this.requests[name] && this.requests[name].length && sockLen < this.maxSockets) {
          debug("removeSocket, have a request, make a socket");
          var req = this.requests[name][0];
          // If we have pending requests and a socket gets closed make a new one
          this.createSocket(req, options, function (err, newSocket) {
            if (err) {
              process.nextTick(function () {
                req.emit("error", err);
              });
              return;
            }
            newSocket.emit("free");
          });
        }
      };

      Agent.prototype.destroy = function destroy() {
        var sets = [this.freeSockets, this.sockets];
        for (var s = 0; s < sets.length; s++) {
          var set = sets[s];
          var keys = Object.keys(set);
          for (var v = 0; v < keys.length; v++) {
            var setName = set[keys[v]];
            for (var n = 0; n < setName.length; n++) {
              setName[n].destroy();
            }
          }
        }
      };

      __webpack_unused_export__ = new Agent();

      /***/
    },

    /***/ 5006: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /**
       * refer:
       *   * @atimb "Real keep-alive HTTP agent": https://gist.github.com/2963672
       *   * https://github.com/joyent/node/blob/master/lib/http.js
       *   * https://github.com/joyent/node/blob/master/lib/https.js
       *   * https://github.com/joyent/node/blob/master/lib/_http_agent.js
       */

      const OriginalAgent = __nccwpck_require__(1256) /* .Agent */.P;
      const ms = __nccwpck_require__(845);

      class Agent extends OriginalAgent {
        constructor(options) {
          options = options || {};
          options.keepAlive = options.keepAlive !== false;
          // default is keep-alive and 15s free socket timeout
          if (options.freeSocketKeepAliveTimeout === undefined) {
            options.freeSocketKeepAliveTimeout = 15000;
          }
          // Legacy API: keepAliveTimeout should be rename to `freeSocketKeepAliveTimeout`
          if (options.keepAliveTimeout) {
            options.freeSocketKeepAliveTimeout = options.keepAliveTimeout;
          }
          options.freeSocketKeepAliveTimeout = ms(options.freeSocketKeepAliveTimeout);

          // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.
          // By default is double free socket keepalive timeout.
          if (options.timeout === undefined) {
            options.timeout = options.freeSocketKeepAliveTimeout * 2;
            // make sure socket default inactivity timeout >= 30s
            if (options.timeout < 30000) {
              options.timeout = 30000;
            }
          }
          options.timeout = ms(options.timeout);

          super(options);

          this.createSocketCount = 0;
          this.createSocketCountLastCheck = 0;

          this.createSocketErrorCount = 0;
          this.createSocketErrorCountLastCheck = 0;

          this.closeSocketCount = 0;
          this.closeSocketCountLastCheck = 0;

          // socket error event count
          this.errorSocketCount = 0;
          this.errorSocketCountLastCheck = 0;

          this.requestCount = 0;
          this.requestCountLastCheck = 0;

          this.timeoutSocketCount = 0;
          this.timeoutSocketCountLastCheck = 0;

          this.on("free", (s) => {
            this.requestCount++;
            // last enter free queue timestamp
            s.lastFreeTime = Date.now();
          });
          this.on("timeout", () => {
            this.timeoutSocketCount++;
          });
          this.on("close", () => {
            this.closeSocketCount++;
          });
          this.on("error", () => {
            this.errorSocketCount++;
          });
        }

        createSocket(req, options, cb) {
          super.createSocket(req, options, (err, socket) => {
            if (err) {
              this.createSocketErrorCount++;
              return cb(err);
            }
            if (this.keepAlive) {
              // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/
              // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html
              socket.setNoDelay(true);
            }
            this.createSocketCount++;
            cb(null, socket);
          });
        }

        get statusChanged() {
          const changed =
            this.createSocketCount !== this.createSocketCountLastCheck ||
            this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||
            this.closeSocketCount !== this.closeSocketCountLastCheck ||
            this.errorSocketCount !== this.errorSocketCountLastCheck ||
            this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||
            this.requestCount !== this.requestCountLastCheck;
          if (changed) {
            this.createSocketCountLastCheck = this.createSocketCount;
            this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
            this.closeSocketCountLastCheck = this.closeSocketCount;
            this.errorSocketCountLastCheck = this.errorSocketCount;
            this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
            this.requestCountLastCheck = this.requestCount;
          }
          return changed;
        }

        getCurrentStatus() {
          return {
            createSocketCount: this.createSocketCount,
            createSocketErrorCount: this.createSocketErrorCount,
            closeSocketCount: this.closeSocketCount,
            errorSocketCount: this.errorSocketCount,
            timeoutSocketCount: this.timeoutSocketCount,
            requestCount: this.requestCount,
            freeSockets: inspect(this.freeSockets),
            sockets: inspect(this.sockets),
            requests: inspect(this.requests)
          };
        }
      }

      module.exports = Agent;

      function inspect(obj) {
        const res = {};
        for (const key in obj) {
          res[key] = obj[key].length;
        }
        return res;
      }

      /***/
    },

    /***/ 5500: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /**
       * Https Agent base on custom http agent
       */

      const https = __nccwpck_require__(5687);
      const HttpAgent = __nccwpck_require__(5006);
      const OriginalHttpsAgent = https.Agent;

      class HttpsAgent extends HttpAgent {
        constructor(options) {
          super(options);

          this.defaultPort = 443;
          this.protocol = "https:";
          this.maxCachedSessions = this.options.maxCachedSessions;
          if (this.maxCachedSessions === undefined) {
            this.maxCachedSessions = 100;
          }

          this._sessionCache = {
            map: {},
            list: []
          };
        }
      }

      [
        "createConnection",
        "getName",
        "_getSession",
        "_cacheSession",
        // https://github.com/nodejs/node/pull/4982
        "_evictSession"
      ].forEach(function (method) {
        if (typeof OriginalHttpsAgent.prototype[method] === "function") {
          HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
        }
      });

      module.exports = HttpsAgent;

      /***/
    },

    /***/ 3775: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const assert = __nccwpck_require__(9491);
      const { isArray } = __nccwpck_require__(1954);
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { formatTag } = __nccwpck_require__(7115);

      const proto = exports;

      function toArray(obj) {
        if (!obj) return [];
        if (isArray(obj)) return obj;
        return [obj];
      }

      /**
       * Bucket opertaions
       */

      proto.listBuckets = async function listBuckets(query = {}, options = {}) {
        // prefix, marker, max-keys

        const { subres = {} } = query;
        const rest = {};
        for (const key in query) {
          if (key !== "subres") {
            rest[key] = query[key];
          }
        }
        const params = this._bucketRequestParams("GET", "", Object.assign(subres, options.subres), options);

        params.query = rest;

        const result = await this.request(params);

        if (result.status === 200) {
          const data = await this.parseXML(result.data);
          let buckets = data.Buckets || null;
          if (buckets) {
            if (buckets.Bucket) {
              buckets = buckets.Bucket;
            }
            if (!isArray(buckets)) {
              buckets = [buckets];
            }
            buckets = buckets.map((item) => ({
              name: item.Name,
              region: item.Location,
              creationDate: item.CreationDate,
              storageClass: item.StorageClass,
              StorageClass: item.StorageClass,
              tag: formatTag(item)
            }));
          }
          return {
            buckets,
            owner: {
              id: data.Owner.ID,
              displayName: data.Owner.DisplayName
            },
            isTruncated: data.IsTruncated === "true",
            nextMarker: data.NextMarker || null,
            res: result.res
          };
        }

        throw await this.requestError(result);
      };

      proto.useBucket = function useBucket(name) {
        _checkBucketName(name);
        return this.setBucket(name);
      };

      proto.setBucket = function useBucket(name) {
        _checkBucketName(name);
        this.options.bucket = name;
        return this;
      };

      proto.getBucket = function getBucket() {
        return this.options.bucket;
      };

      proto.getBucketLocation = async function getBucketLocation(name, options) {
        _checkBucketName(name);
        name = name || this.getBucket();
        const params = this._bucketRequestParams("GET", name, "location", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          location: result.data,
          res: result.res
        };
      };

      proto.getBucketInfo = async function getBucketInfo(name, options) {
        _checkBucketName(name);
        name = name || this.getBucket();
        const params = this._bucketRequestParams("GET", name, "bucketInfo", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          bucket: result.data.Bucket,
          res: result.res
        };
      };

      proto.deleteBucket = async function deleteBucket(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "", options);
        const result = await this.request(params);
        if (result.status === 200 || result.status === 204) {
          return {
            res: result.res
          };
        }
        throw await this.requestError(result);
      };

      // acl

      proto.putBucketACL = async function putBucketACL(name, acl, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("PUT", name, "acl", options);
        params.headers = {
          "x-oss-acl": acl
        };
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          bucket: (result.headers.location && result.headers.location.substring(1)) || null,
          res: result.res
        };
      };

      proto.getBucketACL = async function getBucketACL(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "acl", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          acl: result.data.AccessControlList.Grant,
          owner: {
            id: result.data.Owner.ID,
            displayName: result.data.Owner.DisplayName
          },
          res: result.res
        };
      };

      // logging

      proto.putBucketLogging = async function putBucketLogging(name, prefix, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("PUT", name, "logging", options);
        let xml = `${'<?xml version="1.0" encoding="UTF-8"?>\n<BucketLoggingStatus>\n<LoggingEnabled>\n<TargetBucket>'}${name}</TargetBucket>\n`;
        if (prefix) {
          xml += `<TargetPrefix>${prefix}</TargetPrefix>\n`;
        }
        xml += "</LoggingEnabled>\n</BucketLoggingStatus>";
        params.content = xml;
        params.mime = "xml";
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      proto.getBucketLogging = async function getBucketLogging(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "logging", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        const enable = result.data.LoggingEnabled;
        return {
          enable: !!enable,
          prefix: (enable && enable.TargetPrefix) || null,
          res: result.res
        };
      };

      proto.deleteBucketLogging = async function deleteBucketLogging(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "logging", options);
        params.successStatuses = [204, 200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      proto.putBucketCORS = async function putBucketCORS(name, rules, options) {
        _checkBucketName(name);
        rules = rules || [];
        assert(rules.length, "rules is required");
        rules.forEach((rule) => {
          assert(rule.allowedOrigin, "allowedOrigin is required");
          assert(rule.allowedMethod, "allowedMethod is required");
        });

        const params = this._bucketRequestParams("PUT", name, "cors", options);
        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CORSConfiguration>';
        const parseOrigin = (val) => {
          xml += `<AllowedOrigin>${val}</AllowedOrigin>`;
        };
        const parseMethod = (val) => {
          xml += `<AllowedMethod>${val}</AllowedMethod>`;
        };
        const parseHeader = (val) => {
          xml += `<AllowedHeader>${val}</AllowedHeader>`;
        };
        const parseExposeHeader = (val) => {
          xml += `<ExposeHeader>${val}</ExposeHeader>`;
        };
        for (let i = 0, l = rules.length; i < l; i++) {
          const rule = rules[i];
          xml += "<CORSRule>";

          toArray(rule.allowedOrigin).forEach(parseOrigin);
          toArray(rule.allowedMethod).forEach(parseMethod);
          toArray(rule.allowedHeader).forEach(parseHeader);
          toArray(rule.exposeHeader).forEach(parseExposeHeader);
          if (rule.maxAgeSeconds) {
            xml += `<MaxAgeSeconds>${rule.maxAgeSeconds}</MaxAgeSeconds>`;
          }
          xml += "</CORSRule>";
        }
        xml += "</CORSConfiguration>";
        params.content = xml;
        params.mime = "xml";
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      proto.getBucketCORS = async function getBucketCORS(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "cors", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        const rules = [];
        if (result.data && result.data.CORSRule) {
          let { CORSRule } = result.data;
          if (!isArray(CORSRule)) CORSRule = [CORSRule];
          CORSRule.forEach((rule) => {
            const r = {};
            Object.keys(rule).forEach((key) => {
              r[key.slice(0, 1).toLowerCase() + key.slice(1, key.length)] = rule[key];
            });
            rules.push(r);
          });
        }
        return {
          rules,
          res: result.res
        };
      };

      proto.deleteBucketCORS = async function deleteBucketCORS(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "cors", options);
        params.successStatuses = [204];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      // referer

      proto.putBucketReferer = async function putBucketReferer(name, allowEmpty, referers, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("PUT", name, "referer", options);
        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<RefererConfiguration>\n';
        xml += `  <AllowEmptyReferer>${allowEmpty ? "true" : "false"}</AllowEmptyReferer>\n`;
        if (referers && referers.length > 0) {
          xml += "  <RefererList>\n";
          for (let i = 0; i < referers.length; i++) {
            xml += `    <Referer>${referers[i]}</Referer>\n`;
          }
          xml += "  </RefererList>\n";
        } else {
          xml += "  <RefererList />\n";
        }
        xml += "</RefererConfiguration>";
        params.content = xml;
        params.mime = "xml";
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      proto.getBucketReferer = async function getBucketReferer(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "referer", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        let referers = result.data.RefererList.Referer || null;
        if (referers) {
          if (!isArray(referers)) {
            referers = [referers];
          }
        }
        return {
          allowEmpty: result.data.AllowEmptyReferer === "true",
          referers,
          res: result.res
        };
      };

      proto.deleteBucketReferer = async function deleteBucketReferer(name, options) {
        _checkBucketName(name);
        return await this.putBucketReferer(name, true, null, options);
      };

      // private apis

      proto._bucketRequestParams = function _bucketRequestParams(method, bucket, subres, options) {
        return {
          method,
          bucket,
          subres,
          timeout: options && options.timeout,
          ctx: options && options.ctx
        };
      };

      /***/
    },

    /***/ 2399: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      const debug = __nccwpck_require__(8237)("ali-oss");
      const sendToWormhole = __nccwpck_require__(8751);
      const xml = __nccwpck_require__(6189);
      const AgentKeepalive = __nccwpck_require__(4623);
      const HttpsAgentKeepalive = __nccwpck_require__(4623).HttpsAgent;
      const merge = __nccwpck_require__(1149);
      const platform = __nccwpck_require__(8208);
      const utility = __nccwpck_require__(3877);
      const urllib = __nccwpck_require__(4783);
      const pkg = __nccwpck_require__(2818);
      const bowser = __nccwpck_require__(1686);
      const signUtils = __nccwpck_require__(5150);
      const _initOptions = __nccwpck_require__(9221);
      const { createRequest } = __nccwpck_require__(1828);
      const { encoder } = __nccwpck_require__(3240);
      const { getReqUrl } = __nccwpck_require__(6783);
      const { setSTSToken } = __nccwpck_require__(4622);
      const { retry } = __nccwpck_require__(8263);
      const { isFunction } = __nccwpck_require__(8818);

      const globalHttpAgent = new AgentKeepalive();
      const globalHttpsAgent = new HttpsAgentKeepalive();

      function Client(options, ctx) {
        if (!(this instanceof Client)) {
          return new Client(options, ctx);
        }

        if (options && options.inited) {
          this.options = options;
        } else {
          this.options = Client.initOptions(options);
        }

        // support custom agent and urllib client
        if (this.options.urllib) {
          this.urllib = this.options.urllib;
        } else {
          this.urllib = urllib;
          if (this.options.maxSockets) {
            globalHttpAgent.maxSockets = this.options.maxSockets;
            globalHttpsAgent.maxSockets = this.options.maxSockets;
          }
          this.agent = this.options.agent || globalHttpAgent;
          this.httpsAgent = this.options.httpsAgent || globalHttpsAgent;
        }
        this.ctx = ctx;
        this.userAgent = this._getUserAgent();
        this.stsTokenFreshTime = new Date();
      }

      /**
       * Expose `Client`
       */

      module.exports = Client;

      Client.initOptions = function initOptions(options) {
        return _initOptions(options);
      };

      /**
       * prototype
       */

      const proto = Client.prototype;

      /**
       * Object operations
       */
      merge(proto, __nccwpck_require__(8417));
      merge(proto, __nccwpck_require__(2557));
      merge(proto, __nccwpck_require__(2341));
      /**
       * Bucket operations
       */
      merge(proto, __nccwpck_require__(2715));
      merge(proto, __nccwpck_require__(3775));
      // multipart upload
      merge(proto, __nccwpck_require__(107));
      /**
       * RTMP operations
       */
      merge(proto, __nccwpck_require__(9164));

      /**
       * common multipart-copy support node and browser
       */
      merge(proto, __nccwpck_require__(5944));
      /**
       * Common module parallel
       */
      merge(proto, __nccwpck_require__(986));
      /**
       * Multipart operations
       */
      merge(proto, __nccwpck_require__(5976));
      /**
       * ImageClient class
       */
      Client.ImageClient = __nccwpck_require__(628)(Client);
      /**
       * Cluster Client class
       */
      Client.ClusterClient = __nccwpck_require__(5262)(Client);

      /**
       * STS Client class
       */
      Client.STS = __nccwpck_require__(4418);

      /**
       * get OSS signature
       * @param {String} stringToSign
       * @return {String} the signature
       */
      proto.signature = function signature(stringToSign) {
        debug("authorization stringToSign: %s", stringToSign);

        return signUtils.computeSignature(this.options.accessKeySecret, stringToSign, this.options.headerEncoding);
      };

      proto._getReqUrl = getReqUrl;

      /**
       * get author header
       *
       * "Authorization: OSS " + Access Key Id + ":" + Signature
       *
       * Signature = base64(hmac-sha1(Access Key Secret + "\n"
       *  + VERB + "\n"
       *  + CONTENT-MD5 + "\n"
       *  + CONTENT-TYPE + "\n"
       *  + DATE + "\n"
       *  + CanonicalizedOSSHeaders
       *  + CanonicalizedResource))
       *
       * @param {String} method
       * @param {String} resource
       * @param {Object} header
       * @return {String}
       *
       * @api private
       */

      proto.authorization = function authorization(method, resource, subres, headers) {
        const stringToSign = signUtils.buildCanonicalString(method.toUpperCase(), resource, {
          headers,
          parameters: subres
        });

        return signUtils.authorization(
          this.options.accessKeyId,
          this.options.accessKeySecret,
          stringToSign,
          this.options.headerEncoding
        );
      };

      /**
       * request oss server
       * @param {Object} params
       *   - {String} object
       *   - {String} bucket
       *   - {Object} [headers]
       *   - {Object} [query]
       *   - {Buffer} [content]
       *   - {Stream} [stream]
       *   - {Stream} [writeStream]
       *   - {String} [mime]
       *   - {Boolean} [xmlResponse]
       *   - {Boolean} [customResponse]
       *   - {Number} [timeout]
       *   - {Object} [ctx] request context, default is `this.ctx`
       *
       * @api private
       */

      proto.request = async function (params) {
        if (this.options.retryMax) {
          return await retry(request.bind(this), this.options.retryMax, {
            errorHandler: (err) => {
              const _errHandle = (_err) => {
                if (params.stream) return false;
                const statusErr = [-1, -2].includes(_err.status);
                const requestErrorRetryHandle = this.options.requestErrorRetryHandle || (() => true);
                return statusErr && requestErrorRetryHandle(_err);
              };
              if (_errHandle(err)) return true;
              return false;
            }
          })(params);
        } else {
          return await request.call(this, params);
        }
      };

      async function request(params) {
        if (this.options.stsToken && isFunction(this.options.refreshSTSToken)) {
          await setSTSToken.call(this);
        }
        const reqParams = createRequest.call(this, params);
        let result;
        let reqErr;
        try {
          result = await this.urllib.request(reqParams.url, reqParams.params);
          debug("response %s %s, got %s, headers: %j", params.method, reqParams.url, result.status, result.headers);
        } catch (err) {
          reqErr = err;
        }
        let err;
        if (result && params.successStatuses && params.successStatuses.indexOf(result.status) === -1) {
          err = await this.requestError(result);
          err.params = params;
        } else if (reqErr) {
          err = await this.requestError(reqErr);
        }

        if (err) {
          if (params.customResponse && result && result.res) {
            // consume the response stream
            await sendToWormhole(result.res);
          }

          if (err.name === "ResponseTimeoutError") {
            err.message = `${
              err.message.split(",")[0]
            }, please increase the timeout, see more details at https://github.com/ali-sdk/ali-oss#responsetimeouterror`;
          }
          if (err.name === "ConnectionTimeoutError") {
            err.message = `${
              err.message.split(",")[0]
            }, please increase the timeout or reduce the partSize, see more details at https://github.com/ali-sdk/ali-oss#connectiontimeouterror`;
          }
          throw err;
        }

        if (params.xmlResponse) {
          result.data = await this.parseXML(result.data);
        }
        return result;
      }

      proto._getResource = function _getResource(params) {
        let resource = "/";
        if (params.bucket) resource += `${params.bucket}/`;
        if (params.object) resource += encoder(params.object, this.options.headerEncoding);

        return resource;
      };

      proto._escape = function _escape(name) {
        return utility.encodeURIComponent(name).replace(/%2F/g, "/");
      };

      /*
       * Get User-Agent for browser & node.js
       * @example
       *   aliyun-sdk-nodejs/4.1.2 Node.js 5.3.0 on Darwin 64-bit
       *   aliyun-sdk-js/4.1.2 Safari 9.0 on Apple iPhone(iOS 9.2.1)
       *   aliyun-sdk-js/4.1.2 Chrome 43.0.2357.134 32-bit on Windows Server 2008 R2 / 7 64-bit
       */

      proto._getUserAgent = function _getUserAgent() {
        const agent = process && process.browser ? "js" : "nodejs";
        const sdk = `aliyun-sdk-${agent}/${pkg.version}`;
        let plat = platform.description;
        if (!plat && process) {
          plat = `Node.js ${process.version.slice(1)} on ${process.platform} ${process.arch}`;
        }

        return this._checkUserAgent(`${sdk} ${plat}`);
      };

      proto._checkUserAgent = function _checkUserAgent(ua) {
        const userAgent = ua.replace(/\u03b1/, "alpha").replace(/\u03b2/, "beta");
        return userAgent;
      };

      /*
       * Check Browser And Version
       * @param {String} [name] browser name: like IE, Chrome, Firefox
       * @param {String} [version] browser major version: like 10(IE 10.x), 55(Chrome 55.x), 50(Firefox 50.x)
       * @return {Bool} true or false
       * @api private
       */

      proto.checkBrowserAndVersion = function checkBrowserAndVersion(name, version) {
        return bowser.name === name && bowser.version.split(".")[0] === version;
      };

      /**
       * thunkify xml.parseString
       * @param {String|Buffer} str
       *
       * @api private
       */

      proto.parseXML = function parseXMLThunk(str) {
        return new Promise((resolve, reject) => {
          if (Buffer.isBuffer(str)) {
            str = str.toString();
          }
          xml.parseString(
            str,
            {
              explicitRoot: false,
              explicitArray: false
            },
            (err, result) => {
              if (err) {
                reject(err);
              } else {
                resolve(result);
              }
            }
          );
        });
      };

      /**
       * generater a request error with request response
       * @param {Object} result
       *
       * @api private
       */

      proto.requestError = async function requestError(result) {
        let err = null;
        if (result.name === "ResponseTimeoutError") {
          err = new Error(result.message);
          err.name = result.name;
        } else if (!result.data || !result.data.length) {
          if (result.status === -1 || result.status === -2) {
            // -1 is net error , -2 is timeout
            err = new Error(result.message);
            err.name = result.name;
            err.status = result.status;
            err.code = result.name;
          } else {
            // HEAD not exists resource
            if (result.status === 404) {
              err = new Error("Object not exists");
              err.name = "NoSuchKeyError";
              err.status = 404;
              err.code = "NoSuchKey";
            } else if (result.status === 412) {
              err = new Error("Pre condition failed");
              err.name = "PreconditionFailedError";
              err.status = 412;
              err.code = "PreconditionFailed";
            } else {
              err = new Error(`Unknow error, status: ${result.status}`);
              err.name = "UnknownError";
              err.status = result.status;
            }
            err.requestId = result.headers["x-oss-request-id"];
            err.host = "";
          }
        } else {
          const message = String(result.data);
          debug("request response error data: %s", message);

          let info;
          try {
            info = (await this.parseXML(message)) || {};
          } catch (error) {
            debug(message);
            error.message += `\nraw xml: ${message}`;
            error.status = result.status;
            error.requestId = result.headers["x-oss-request-id"];
            return error;
          }

          let msg = info.Message || `unknow request error, status: ${result.status}`;
          if (info.Condition) {
            msg += ` (condition: ${info.Condition})`;
          }
          err = new Error(msg);
          err.name = info.Code ? `${info.Code}Error` : "UnknownError";
          err.status = result.status;
          err.code = info.Code;
          err.requestId = info.RequestId;
          err.hostId = info.HostId;
        }

        debug("generate error %j", err);
        return err;
      };

      proto.setSLDEnabled = function setSLDEnabled(enable) {
        this.options.sldEnable = !!enable;
        return this;
      };

      /***/
    },

    /***/ 5262: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Base = __nccwpck_require__(9100);
      const util = __nccwpck_require__(3837);
      const ready = __nccwpck_require__(5284);
      const copy = __nccwpck_require__(952);
      const currentIP = __nccwpck_require__(777).ip();

      const RR = "roundRobin";
      const MS = "masterSlave";

      module.exports = function (OssClient) {
        function Client(options) {
          if (!(this instanceof Client)) {
            return new Client(options);
          }

          if (!options || !Array.isArray(options.cluster)) {
            throw new Error("require options.cluster to be an array");
          }

          Base.call(this);

          this.clients = [];
          this.availables = {};

          for (let i = 0; i < options.cluster.length; i++) {
            const opt = options.cluster[i];
            copy(options).pick("timeout", "agent", "urllib").to(opt);
            this.clients.push(new OssClient(opt));
            this.availables[i] = true;
          }

          this.schedule = options.schedule || RR;
          // only read from master, default is false
          this.masterOnly = !!options.masterOnly;
          this.index = 0;

          const heartbeatInterval = options.heartbeatInterval || 10000;
          this._checkAvailableLock = false;
          this._timerId = this._deferInterval(this._checkAvailable.bind(this, true), heartbeatInterval);
          this._ignoreStatusFile = options.ignoreStatusFile || false;
          this._init();
        }

        util.inherits(Client, Base);
        const proto = Client.prototype;
        ready.mixin(proto);

        const GET_METHODS = ["head", "get", "getStream", "list", "getACL"];

        const PUT_METHODS = ["put", "putStream", "delete", "deleteMulti", "copy", "putMeta", "putACL"];

        GET_METHODS.forEach((method) => {
          proto[method] = async function (...args) {
            const client = this.chooseAvailable();
            let lastError;
            try {
              return await client[method](...args);
            } catch (err) {
              if (err.status && err.status >= 200 && err.status < 500) {
                // 200 ~ 499 belong to normal response, don't try again
                throw err;
              }
              // < 200 || >= 500 need to retry from other cluser node
              lastError = err;
            }

            for (let i = 0; i < this.clients.length; i++) {
              const c = this.clients[i];
              if (c !== client) {
                try {
                  return await c[method].apply(client, args);
                } catch (err) {
                  if (err.status && err.status >= 200 && err.status < 500) {
                    // 200 ~ 499 belong to normal response, don't try again
                    throw err;
                  }
                  // < 200 || >= 500 need to retry from other cluser node
                  lastError = err;
                }
              }
            }

            lastError.message += " (all clients are down)";
            throw lastError;
          };
        });

        // must cluster node write success
        PUT_METHODS.forEach((method) => {
          proto[method] = async function (...args) {
            const res = await Promise.all(this.clients.map((client) => client[method](...args)));
            return res[0];
          };
        });

        proto.signatureUrl = function signatureUrl(/* name */ ...args) {
          const client = this.chooseAvailable();
          return client.signatureUrl(...args);
        };

        proto.getObjectUrl = function getObjectUrl(/* name, baseUrl */ ...args) {
          const client = this.chooseAvailable();
          return client.getObjectUrl(...args);
        };

        proto._init = function _init() {
          const that = this;
          (async () => {
            await that._checkAvailable(that._ignoreStatusFile);
            that.ready(true);
          })().catch((err) => {
            that.emit("error", err);
          });
        };

        proto._checkAvailable = async function _checkAvailable(ignoreStatusFile) {
          const name = `._ali-oss/check.status.${currentIP}.txt`;
          if (!ignoreStatusFile) {
            // only start will try to write the file
            await this.put(name, Buffer.from(`check available started at ${Date()}`));
          }

          if (this._checkAvailableLock) {
            return;
          }
          this._checkAvailableLock = true;
          const downStatusFiles = [];
          for (let i = 0; i < this.clients.length; i++) {
            const client = this.clients[i];
            // check 3 times
            let available = await this._checkStatus(client, name);
            if (!available) {
              // check again
              available = await this._checkStatus(client, name);
            }
            if (!available) {
              // check again
              /* eslint no-await-in-loop: [0] */
              available = await this._checkStatus(client, name);
              if (!available) {
                downStatusFiles.push(client._objectUrl(name));
              }
            }
            this.availables[i] = available;
          }
          this._checkAvailableLock = false;

          if (downStatusFiles.length > 0) {
            const err = new Error(
              `${downStatusFiles.length} data node down, please check status file: ${downStatusFiles.join(", ")}`
            );
            err.name = "CheckAvailableError";
            this.emit("error", err);
          }
        };

        proto._checkStatus = async function _checkStatus(client, name) {
          let available = true;
          try {
            await client.head(name);
          } catch (err) {
            // 404 will be available too
            if (!err.status || err.status >= 500 || err.status < 200) {
              available = false;
            }
          }
          return available;
        };

        proto.chooseAvailable = function chooseAvailable() {
          if (this.schedule === MS) {
            // only read from master
            if (this.masterOnly) {
              return this.clients[0];
            }
            for (let i = 0; i < this.clients.length; i++) {
              if (this.availables[i]) {
                return this.clients[i];
              }
            }
            // all down, try to use this first one
            return this.clients[0];
          }

          // RR
          let n = this.clients.length;
          while (n > 0) {
            const i = this._nextRRIndex();
            if (this.availables[i]) {
              return this.clients[i];
            }
            n--;
          }
          // all down, try to use this first one
          return this.clients[0];
        };

        proto._nextRRIndex = function _nextRRIndex() {
          const index = this.index++;
          if (this.index >= this.clients.length) {
            this.index = 0;
          }
          return index;
        };

        proto._error = function error(err) {
          if (err) throw err;
        };

        proto._createCallback = function _createCallback(ctx, gen, cb) {
          return () => {
            cb = cb || this._error;
            gen.call(ctx).then(() => {
              cb();
            }, cb);
          };
        };
        proto._deferInterval = function _deferInterval(gen, timeout, cb) {
          return setInterval(this._createCallback(this, gen, cb), timeout);
        };

        proto.close = function close() {
          clearInterval(this._timerId);
          this._timerId = null;
        };

        return Client;
      };

      /***/
    },

    /***/ 8072: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.abortBucketWorm = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      async function abortBucketWorm(name, options) {
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "worm", options);
        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      }
      exports.abortBucketWorm = abortBucketWorm;

      /***/
    },

    /***/ 2498: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.completeBucketWorm = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      async function completeBucketWorm(name, wormId, options) {
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("POST", name, { wormId }, options);
        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      }
      exports.completeBucketWorm = completeBucketWorm;

      /***/
    },

    /***/ 9017: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      // const jstoxml = require('jstoxml');
      /**
       * deleteBucketEncryption
       * @param {String} bucketName - bucket name
       */

      proto.deleteBucketEncryption = async function deleteBucketEncryption(bucketName) {
        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("DELETE", bucketName, "encryption");
        params.successStatuses = [204];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 6956: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deleteBucketInventory = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      /**
       * deleteBucketInventory
       * @param {String} bucketName - bucket name
       * @param {String} inventoryId
       * @param {Object} options
       */
      async function deleteBucketInventory(bucketName, inventoryId, options = {}) {
        const subres = Object.assign({ inventory: "", inventoryId }, options.subres);
        checkBucketName_1.checkBucketName(bucketName);
        const params = this._bucketRequestParams("DELETE", bucketName, subres, options);
        params.successStatuses = [204];
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      }
      exports.deleteBucketInventory = deleteBucketInventory;

      /***/
    },

    /***/ 1888: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;

      proto.deleteBucketLifecycle = async function deleteBucketLifecycle(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "lifecycle", options);
        params.successStatuses = [204];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 8585: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * deleteBucketPolicy
       * @param {String} bucketName - bucket name
       * @param {Object} options
       */

      proto.deleteBucketPolicy = async function deleteBucketPolicy(bucketName, options = {}) {
        _checkBucketName(bucketName);

        const params = this._bucketRequestParams("DELETE", bucketName, "policy", options);
        params.successStatuses = [204];
        const result = await this.request(params);

        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 6130: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * deleteBucketTags
       * @param {String} name - bucket name
       * @param {Object} options
       */

      proto.deleteBucketTags = async function deleteBucketTags(name, options = {}) {
        _checkBucketName(name);

        const params = this._bucketRequestParams("DELETE", name, "tagging", options);
        params.successStatuses = [204];
        const result = await this.request(params);

        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 3069: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;

      proto.deleteBucketWebsite = async function deleteBucketWebsite(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("DELETE", name, "website", options);
        params.successStatuses = [204];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 4262: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendBucketWorm = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      const obj2xml_1 = __nccwpck_require__(6846);
      async function extendBucketWorm(name, wormId, days, options) {
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("POST", name, { wormExtend: "", wormId }, options);
        const paramlXMLObJ = {
          ExtendWormConfiguration: {
            RetentionPeriodInDays: days
          }
        };
        params.mime = "xml";
        params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      }
      exports.extendBucketWorm = extendBucketWorm;

      /***/
    },

    /***/ 6639: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * getBucketEncryption
       * @param {String} bucketName - bucket name
       */

      proto.getBucketEncryption = async function getBucketEncryption(bucketName) {
        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("GET", bucketName, "encryption");
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        const encryption = result.data.ApplyServerSideEncryptionByDefault;
        return {
          encryption,
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 7743: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBucketInventory = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      const formatInventoryConfig_1 = __nccwpck_require__(5708);
      /**
       * getBucketInventory
       * @param {String} bucketName - bucket name
       * @param {String} inventoryId
       * @param {Object} options
       */
      async function getBucketInventory(bucketName, inventoryId, options = {}) {
        const subres = Object.assign({ inventory: "", inventoryId }, options.subres);
        checkBucketName_1.checkBucketName(bucketName);
        const params = this._bucketRequestParams("GET", bucketName, subres, options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res,
          inventory: formatInventoryConfig_1.formatInventoryConfig(result.data)
        };
      }
      exports.getBucketInventory = getBucketInventory;

      /***/
    },

    /***/ 4331: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { isArray } = __nccwpck_require__(1954);
      const { formatObjKey } = __nccwpck_require__(2095);

      const proto = exports;

      proto.getBucketLifecycle = async function getBucketLifecycle(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "lifecycle", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        let rules = result.data.Rule || null;
        if (rules) {
          if (!isArray(rules)) {
            rules = [rules];
          }
          rules = rules.map((_) => {
            if (_.ID) {
              _.id = _.ID;
              delete _.ID;
            }
            if (_.Tag && !isArray(_.Tag)) {
              _.Tag = [_.Tag];
            }
            return formatObjKey(_, "firstLowerCase");
          });
        }
        return {
          rules,
          res: result.res
        };
      };

      /***/
    },

    /***/ 8221: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * getBucketPolicy
       * @param {String} bucketName - bucket name
       * @param {Object} options
       */

      proto.getBucketPolicy = async function getBucketPolicy(bucketName, options = {}) {
        _checkBucketName(bucketName);

        const params = this._bucketRequestParams("GET", bucketName, "policy", options);

        const result = await this.request(params);
        params.successStatuses = [200];
        let policy = null;

        if (result.res.status === 200) {
          policy = JSON.parse(result.res.data.toString());
        }

        return {
          policy,
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 768: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * getBucketRequestPayment
       * @param {String} bucketName - bucket name
       * @param {Object} options
       */

      proto.getBucketRequestPayment = async function getBucketRequestPayment(bucketName, options) {
        options = options || {};

        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("GET", bucketName, "requestPayment", options);
        params.successStatuses = [200];
        params.xmlResponse = true;

        const result = await this.request(params);

        return {
          status: result.status,
          res: result.res,
          payer: result.data.Payer
        };
      };

      /***/
    },

    /***/ 5629: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBucketStat = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      async function getBucketStat(name, options) {
        name = name || this.options.bucket;
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "stat", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        return {
          res: result.res,
          stat: result.data
        };
      }
      exports.getBucketStat = getBucketStat;

      /***/
    },

    /***/ 7103: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const proto = exports;
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { formatTag } = __nccwpck_require__(7115);
      /**
       * getBucketTags
       * @param {String} name - bucket name
       * @param {Object} options
       * @return {Object}
       */

      proto.getBucketTags = async function getBucketTags(name, options = {}) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "tagging", options);
        params.successStatuses = [200];
        const result = await this.request(params);
        const Tagging = await this.parseXML(result.data);

        return {
          status: result.status,
          res: result.res,
          tag: formatTag(Tagging)
        };
      };

      /***/
    },

    /***/ 3607: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;
      /**
       * getBucketVersioning
       * @param {String} bucketName - bucket name
       */

      proto.getBucketVersioning = async function getBucketVersioning(bucketName, options) {
        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("GET", bucketName, "versioning", options);
        params.xmlResponse = true;
        params.successStatuses = [200];
        const result = await this.request(params);

        const versionStatus = result.data.Status;
        return {
          status: result.status,
          versionStatus,
          res: result.res
        };
      };

      /***/
    },

    /***/ 3570: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { isObject } = __nccwpck_require__(1269);

      const proto = exports;

      proto.getBucketWebsite = async function getBucketWebsite(name, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "website", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        let routingRules = [];
        if (result.data.RoutingRules && result.data.RoutingRules.RoutingRule) {
          if (isObject(result.data.RoutingRules.RoutingRule)) {
            routingRules = [result.data.RoutingRules.RoutingRule];
          } else {
            routingRules = result.data.RoutingRules.RoutingRule;
          }
        }
        return {
          index: (result.data.IndexDocument && result.data.IndexDocument.Suffix) || "",
          supportSubDir: (result.data.IndexDocument && result.data.IndexDocument.SupportSubDir) || "false",
          type: result.data.IndexDocument && result.data.IndexDocument.Type,
          routingRules,
          error: (result.data.ErrorDocument && result.data.ErrorDocument.Key) || null,
          res: result.res
        };
      };

      /***/
    },

    /***/ 1539: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getBucketWorm = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      const dataFix_1 = __nccwpck_require__(1615);
      async function getBucketWorm(name, options) {
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("GET", name, "worm", options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        dataFix_1.dataFix(result.data, {
          lowerFirst: true,
          rename: {
            RetentionPeriodInDays: "days"
          }
        });
        return Object.assign(Object.assign({}, result.data), { res: result.res, status: result.status });
      }
      exports.getBucketWorm = getBucketWorm;

      /***/
    },

    /***/ 2715: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const merge = __nccwpck_require__(1149);

      const proto = exports;

      merge(proto, __nccwpck_require__(768));
      merge(proto, __nccwpck_require__(4392));
      merge(proto, __nccwpck_require__(3530));
      merge(proto, __nccwpck_require__(6639));
      merge(proto, __nccwpck_require__(9017));
      merge(proto, __nccwpck_require__(7103));
      merge(proto, __nccwpck_require__(5149));
      merge(proto, __nccwpck_require__(6130));
      merge(proto, __nccwpck_require__(979));
      merge(proto, __nccwpck_require__(3570));
      merge(proto, __nccwpck_require__(4979));
      merge(proto, __nccwpck_require__(3069));
      merge(proto, __nccwpck_require__(4331));
      merge(proto, __nccwpck_require__(7812));
      merge(proto, __nccwpck_require__(1888));
      merge(proto, __nccwpck_require__(8221));
      merge(proto, __nccwpck_require__(9663));
      merge(proto, __nccwpck_require__(8585));
      merge(proto, __nccwpck_require__(3607));
      merge(proto, __nccwpck_require__(1372));
      merge(proto, __nccwpck_require__(7743));
      merge(proto, __nccwpck_require__(6956));
      merge(proto, __nccwpck_require__(7981));
      merge(proto, __nccwpck_require__(113));
      merge(proto, __nccwpck_require__(8072));
      merge(proto, __nccwpck_require__(2498));
      merge(proto, __nccwpck_require__(4262));
      merge(proto, __nccwpck_require__(1539));
      merge(proto, __nccwpck_require__(3874));
      merge(proto, __nccwpck_require__(5629));

      /***/
    },

    /***/ 3874: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.initiateBucketWorm = void 0;
      const obj2xml_1 = __nccwpck_require__(6846);
      const checkBucketName_1 = __nccwpck_require__(922);
      async function initiateBucketWorm(name, days, options) {
        checkBucketName_1.checkBucketName(name);
        const params = this._bucketRequestParams("POST", name, "worm", options);
        const paramlXMLObJ = {
          InitiateWormConfiguration: {
            RetentionPeriodInDays: days
          }
        };
        params.mime = "xml";
        params.content = obj2xml_1.obj2xml(paramlXMLObJ, { headers: true });
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res,
          wormId: result.res.headers["x-oss-worm-id"],
          status: result.status
        };
      }
      exports.initiateBucketWorm = initiateBucketWorm;

      /***/
    },

    /***/ 7981: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.listBucketInventory = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      const formatInventoryConfig_1 = __nccwpck_require__(5708);
      /**
       * listBucketInventory
       * @param {String} bucketName - bucket name
       * @param {String} inventoryId
       * @param {Object} options
       */
      async function listBucketInventory(bucketName, options = {}) {
        const { continuationToken } = options;
        const subres = Object.assign(
          { inventory: "" },
          continuationToken && { "continuation-token": continuationToken },
          options.subres
        );
        checkBucketName_1.checkBucketName(bucketName);
        const params = this._bucketRequestParams("GET", bucketName, subres, options);
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        const { data, res, status } = result;
        return {
          isTruncated: data.IsTruncated === "true",
          nextContinuationToken: data.NextContinuationToken,
          inventoryList: formatInventoryConfig_1.formatInventoryConfig(data.InventoryConfiguration, true),
          status,
          res
        };
      }
      exports.listBucketInventory = listBucketInventory;

      /***/
    },

    /***/ 979: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const proto = exports;
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);

      proto.putBucket = async function putBucket(name, options = {}) {
        _checkBucketName(name, true);
        const params = this._bucketRequestParams("PUT", name, "", options);

        const CreateBucketConfiguration = {};
        const paramlXMLObJ = {
          CreateBucketConfiguration
        };

        const storageClass = options.StorageClass || options.storageClass;
        const dataRedundancyType = options.DataRedundancyType || options.dataRedundancyType;
        if (storageClass || dataRedundancyType) {
          storageClass && (CreateBucketConfiguration.StorageClass = storageClass);
          dataRedundancyType && (CreateBucketConfiguration.DataRedundancyType = dataRedundancyType);
          params.mime = "xml";
          params.content = obj2xml(paramlXMLObJ, { headers: true });
        }
        const { acl, headers = {} } = options;
        acl && (headers["x-oss-acl"] = acl);
        params.headers = headers;
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          bucket: (result.headers.location && result.headers.location.substring(1)) || null,
          res: result.res
        };
      };

      /***/
    },

    /***/ 3530: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const proto = exports;
      // const jstoxml = require('jstoxml');
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);
      /**
       * putBucketEncryption
       * @param {String} bucketName - bucket name
       * @param {Object} options
       */

      proto.putBucketEncryption = async function putBucketEncryption(bucketName, options) {
        options = options || {};
        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("PUT", bucketName, "encryption", options);
        params.successStatuses = [200];
        const paramXMLObj = {
          ServerSideEncryptionRule: {
            ApplyServerSideEncryptionByDefault: {
              SSEAlgorithm: options.SSEAlgorithm
            }
          }
        };
        if (options.KMSMasterKeyID !== undefined) {
          paramXMLObj.ServerSideEncryptionRule.ApplyServerSideEncryptionByDefault.KMSMasterKeyID =
            options.KMSMasterKeyID;
        }
        const paramXML = obj2xml(paramXMLObj, {
          headers: true
        });
        params.mime = "xml";
        params.content = paramXML;
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 113: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.putBucketInventory = void 0;
      const checkBucketName_1 = __nccwpck_require__(922);
      const obj2xml_1 = __nccwpck_require__(6846);
      /**
       * putBucketInventory
       * @param {String} bucketName - bucket name
       * @param {Inventory} inventory
       * @param {Object} options
       */
      async function putBucketInventory(bucketName, inventory, options = {}) {
        const subres = Object.assign({ inventory: "", inventoryId: inventory.id }, options.subres);
        checkBucketName_1.checkBucketName(bucketName);
        const { OSSBucketDestination, optionalFields, includedObjectVersions } = inventory;
        const destinationBucketPrefix = "acs:oss:::";
        const rolePrefix = `acs:ram::${OSSBucketDestination.accountId}:role/`;
        const paramXMLObj = {
          InventoryConfiguration: {
            Id: inventory.id,
            IsEnabled: inventory.isEnabled,
            Filter: {
              Prefix: inventory.prefix || ""
            },
            Destination: {
              OSSBucketDestination: {
                Format: OSSBucketDestination.format,
                AccountId: OSSBucketDestination.accountId,
                RoleArn: `${rolePrefix}${OSSBucketDestination.rolename}`,
                Bucket: `${destinationBucketPrefix}${OSSBucketDestination.bucket}`,
                Prefix: OSSBucketDestination.prefix || "",
                Encryption: OSSBucketDestination.encryption || ""
              }
            },
            Schedule: {
              Frequency: inventory.frequency
            },
            IncludedObjectVersions: includedObjectVersions,
            OptionalFields: {
              Field: (optionalFields === null || optionalFields === void 0 ? void 0 : optionalFields.field) || []
            }
          }
        };
        const paramXML = obj2xml_1.obj2xml(paramXMLObj, {
          headers: true,
          firstUpperCase: true
        });
        const params = this._bucketRequestParams("PUT", bucketName, subres, options);
        params.successStatuses = [200];
        params.mime = "xml";
        params.content = paramXML;
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      }
      exports.putBucketInventory = putBucketInventory;

      /***/
    },

    /***/ 7812: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /* eslint-disable no-use-before-define */
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { isArray } = __nccwpck_require__(1954);
      const { deepCopy } = __nccwpck_require__(7150);
      const { isObject } = __nccwpck_require__(1269);
      const { obj2xml } = __nccwpck_require__(6846);
      const { checkObjectTag } = __nccwpck_require__(849);
      const { getStrBytesCount } = __nccwpck_require__(365);

      const proto = exports;

      proto.putBucketLifecycle = async function putBucketLifecycle(name, rules, options) {
        _checkBucketName(name);

        if (!isArray(rules)) {
          throw new Error("rules must be Array");
        }

        const params = this._bucketRequestParams("PUT", name, "lifecycle", options);
        const Rule = [];
        const paramXMLObj = {
          LifecycleConfiguration: {
            Rule
          }
        };

        rules.forEach((_) => {
          defaultDaysAndDate2Expiration(_); // todo delete, 
          checkRule(_);
          if (_.id) {
            _.ID = _.id;
            delete _.id;
          }
          Rule.push(_);
        });

        const paramXML = obj2xml(paramXMLObj, {
          headers: true,
          firstUpperCase: true
        });

        params.content = paramXML;
        params.mime = "xml";
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      // todo delete, 
      function defaultDaysAndDate2Expiration(obj) {
        if (obj.days) {
          obj.expiration = {
            days: obj.days
          };
        }
        if (obj.date) {
          obj.expiration = {
            createdBeforeDate: obj.date
          };
        }
      }

      function checkDaysAndDate(obj, key) {
        const { days, createdBeforeDate } = obj;
        if (!days && !createdBeforeDate) {
          throw new Error(`${key} must includes days or createdBeforeDate`);
        } else if (days && !/^[1-9][0-9]*$/.test(days)) {
          throw new Error("days must be a positive integer");
        } else if (createdBeforeDate && !/\d{4}-\d{2}-\d{2}T00:00:00.000Z/.test(createdBeforeDate)) {
          throw new Error("createdBeforeDate must be date and conform to iso8601 format");
        }
      }

      function handleCheckTag(tag) {
        if (!isArray(tag) && !isObject(tag)) {
          throw new Error("tag must be Object or Array");
        }
        tag = isObject(tag) ? [tag] : tag;
        const tagObj = {};
        const tagClone = deepCopy(tag);
        tagClone.forEach((v) => {
          tagObj[v.key] = v.value;
        });

        checkObjectTag(tagObj);
      }

      function checkRule(rule) {
        if (rule.id && getStrBytesCount(rule.id) > 255) throw new Error("ID is composed of 255 bytes at most");

        if (rule.prefix === undefined) throw new Error("Rule must includes prefix");

        if (!["Enabled", "Disabled"].includes(rule.status)) throw new Error("Status must be  Enabled or Disabled");

        if (rule.transition) {
          if (!["IA", "Archive"].includes(rule.transition.storageClass))
            throw new Error("StorageClass must be  IA or Archive");
          checkDaysAndDate(rule.transition, "Transition");
        }

        if (rule.expiration) {
          if (!rule.expiration.expiredObjectDeleteMarker) {
            checkDaysAndDate(rule.expiration, "Expiration");
          } else if (rule.expiration.days || rule.expiration.createdBeforeDate) {
            throw new Error("expiredObjectDeleteMarker cannot be used with days or createdBeforeDate");
          }
        }

        if (rule.abortMultipartUpload) {
          checkDaysAndDate(rule.abortMultipartUpload, "AbortMultipartUpload");
        }

        if (!rule.expiration && !rule.abortMultipartUpload && !rule.transition && !rule.noncurrentVersionTransition) {
          throw new Error(
            "Rule must includes expiration or abortMultipartUpload or transition or noncurrentVersionTransition"
          );
        }

        if (rule.tag) {
          if (rule.abortMultipartUpload) {
            throw new Error("Tag cannot be used with abortMultipartUpload");
          }
          handleCheckTag(rule.tag);
        }
      }

      /***/
    },

    /***/ 9663: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { policy2Str } = __nccwpck_require__(61);
      const { isObject } = __nccwpck_require__(1269);

      const proto = exports;
      /**
       * putBucketPolicy
       * @param {String} bucketName - bucket name
       * @param {Object} policy - bucket policy
       * @param {Object} options
       */

      proto.putBucketPolicy = async function putBucketPolicy(bucketName, policy, options = {}) {
        _checkBucketName(bucketName);

        if (!isObject(policy)) {
          throw new Error("policy is not Object");
        }
        const params = this._bucketRequestParams("PUT", bucketName, "policy", options);
        params.content = policy2Str(policy);
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 4392: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);

      const proto = exports;
      /**
       * putBucketRequestPayment
       * @param {String} bucketName
       * @param {String} payer
       * @param {Object} options
       */
      const payerAll = ["BucketOwner", "Requester"];

      proto.putBucketRequestPayment = async function putBucketRequestPayment(bucketName, payer, options) {
        options = options || {};
        if (!payer || payerAll.indexOf(payer) < 0) {
          throw new Error("payer must be BucketOwner or Requester");
        }

        _checkBucketName(bucketName);
        const params = this._bucketRequestParams("PUT", bucketName, "requestPayment", options);
        params.successStatuses = [200];

        const paramXMLObj = {
          RequestPaymentConfiguration: {
            Payer: payer
          }
        };
        const paramXML = obj2xml(paramXMLObj, {
          headers: true
        });

        params.mime = "xml";
        params.content = paramXML;

        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 5149: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);
      const { checkBucketTag } = __nccwpck_require__(8694);

      const proto = exports;
      /**
       * putBucketTags
       * @param {String} name - bucket name
       * @param {Object} tag -  bucket tag, eg: `{a: "1", b: "2"}`
       * @param {Object} options
       */

      proto.putBucketTags = async function putBucketTags(name, tag, options = {}) {
        _checkBucketName(name);
        checkBucketTag(tag);
        const params = this._bucketRequestParams("PUT", name, "tagging", options);
        params.successStatuses = [200];
        tag = Object.keys(tag).map((key) => ({
          Key: key,
          Value: tag[key]
        }));

        const paramXMLObj = {
          Tagging: {
            TagSet: {
              Tag: tag
            }
          }
        };

        params.mime = "xml";
        params.content = obj2xml(paramXMLObj);

        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      };

      /***/
    },

    /***/ 1372: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);

      const proto = exports;
      /**
       * putBucketVersioning
       * @param {String} name - bucket name
       * @param {String} status
       * @param {Object} options
       */

      proto.putBucketVersioning = async function putBucketVersioning(name, status, options = {}) {
        _checkBucketName(name);
        if (!["Enabled", "Suspended"].includes(status)) {
          throw new Error("status must be Enabled or Suspended");
        }
        const params = this._bucketRequestParams("PUT", name, "versioning", options);

        const paramXMLObj = {
          VersioningConfiguration: {
            Status: status
          }
        };

        params.mime = "xml";
        params.content = obj2xml(paramXMLObj, {
          headers: true
        });

        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      };

      /***/
    },

    /***/ 4979: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { obj2xml } = __nccwpck_require__(6846);
      const { isArray } = __nccwpck_require__(1954);

      const proto = exports;
      proto.putBucketWebsite = async function putBucketWebsite(name, config = {}, options) {
        _checkBucketName(name);
        const params = this._bucketRequestParams("PUT", name, "website", options);
        const IndexDocument = {
          Suffix: config.index || "index.html"
        };
        const WebsiteConfiguration = {
          IndexDocument
        };
        let website = {
          WebsiteConfiguration
        };

        if (config.supportSubDir) {
          IndexDocument.SupportSubDir = config.supportSubDir;
        }

        if (config.type) {
          IndexDocument.Type = config.type;
        }

        if (config.error) {
          WebsiteConfiguration.ErrorDocument = {
            Key: config.error
          };
        }

        if (config.routingRules !== undefined) {
          if (!isArray(config.routingRules)) {
            throw new Error("RoutingRules must be Array");
          }
          WebsiteConfiguration.RoutingRules = {
            RoutingRule: config.routingRules
          };
        }

        website = obj2xml(website);
        params.content = website;
        params.mime = "xml";
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 6725: /***/ (__unused_webpack_module, exports) => {
      exports.encodeCallback = function encodeCallback(reqParams, options) {
        reqParams.headers = reqParams.headers || {};
        if (!Object.prototype.hasOwnProperty.call(reqParams.headers, "x-oss-callback")) {
          if (options.callback) {
            const json = {
              callbackUrl: encodeURI(options.callback.url),
              callbackBody: options.callback.body
            };
            if (options.callback.host) {
              json.callbackHost = options.callback.host;
            }
            if (options.callback.contentType) {
              json.callbackBodyType = options.callback.contentType;
            }
            const callback = Buffer.from(JSON.stringify(json)).toString("base64");
            reqParams.headers["x-oss-callback"] = callback;

            if (options.callback.customValue) {
              const callbackVar = {};
              Object.keys(options.callback.customValue).forEach((key) => {
                callbackVar[`x:${key}`] = options.callback.customValue[key].toString();
              });
              reqParams.headers["x-oss-callback-var"] = Buffer.from(JSON.stringify(callbackVar)).toString("base64");
            }
          }
        }
      };

      /***/
    },

    /***/ 6783: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getReqUrl = void 0;
      const copy_to_1 = __importDefault(__nccwpck_require__(952));
      const url_1 = __importDefault(__nccwpck_require__(7310));
      const merge_descriptors_1 = __importDefault(__nccwpck_require__(1149));
      const is_type_of_1 = __importDefault(__nccwpck_require__(5565));
      const isIP_1 = __nccwpck_require__(2439);
      const checkConfigValid_1 = __nccwpck_require__(7324);
      function getReqUrl(params) {
        const ep = {};
        const isCname = this.options.cname;
        checkConfigValid_1.checkConfigValid(this.options.endpoint, "endpoint");
        copy_to_1.default(this.options.endpoint, false).to(ep);
        if (params.bucket && !isCname && !isIP_1.isIP(ep.hostname) && !this.options.sldEnable) {
          ep.host = `${params.bucket}.${ep.host}`;
        }
        let resourcePath = "/";
        if (params.bucket && this.options.sldEnable) {
          resourcePath += `${params.bucket}/`;
        }
        if (params.object) {
          // Preserve '/' in result url
          resourcePath += this._escape(params.object).replace(/\+/g, "%2B");
        }
        ep.pathname = resourcePath;
        const query = {};
        if (params.query) {
          merge_descriptors_1.default(query, params.query);
        }
        if (params.subres) {
          let subresAsQuery = {};
          if (is_type_of_1.default.string(params.subres)) {
            subresAsQuery[params.subres] = "";
          } else if (is_type_of_1.default.array(params.subres)) {
            params.subres.forEach((k) => {
              subresAsQuery[k] = "";
            });
          } else {
            subresAsQuery = params.subres;
          }
          merge_descriptors_1.default(query, subresAsQuery);
        }
        ep.query = query;
        return url_1.default.format(ep);
      }
      exports.getReqUrl = getReqUrl;

      /***/
    },

    /***/ 9221: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      const ms = __nccwpck_require__(845);
      const urlutil = __nccwpck_require__(7310);
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const { setRegion } = __nccwpck_require__(6690);
      const { checkConfigValid } = __nccwpck_require__(7324);

      function setEndpoint(endpoint, secure) {
        checkConfigValid(endpoint, "endpoint");
        let url = urlutil.parse(endpoint);

        if (!url.protocol) {
          url = urlutil.parse(`http${secure ? "s" : ""}://${endpoint}`);
        }

        if (url.protocol !== "http:" && url.protocol !== "https:") {
          throw new Error("Endpoint protocol must be http or https.");
        }

        return url;
      }

      module.exports = function (options) {
        if (!options || !options.accessKeyId || !options.accessKeySecret) {
          throw new Error("require accessKeyId, accessKeySecret");
        }
        if (options.stsToken && !options.refreshSTSToken && !options.refreshSTSTokenInterval) {
          console.warn(
            "It's recommended to set 'refreshSTSToken' and 'refreshSTSTokenInterval' to refresh" +
              " stsTokenaccessKeyIdaccessKeySecret automatically when sts token has expired"
          );
        }
        if (options.bucket) {
          _checkBucketName(options.bucket);
        }
        const opts = Object.assign(
          {
            region: "oss-cn-hangzhou",
            internal: false,
            secure: false,
            timeout: 60000,
            bucket: null,
            endpoint: null,
            cname: false,
            isRequestPay: false,
            sldEnable: false,
            headerEncoding: "utf-8",
            refreshSTSToken: null,
            refreshSTSTokenInterval: 60000 * 5,
            retryMax: 0
          },
          options
        );

        opts.accessKeyId = opts.accessKeyId.trim();
        opts.accessKeySecret = opts.accessKeySecret.trim();

        if (opts.timeout) {
          opts.timeout = ms(opts.timeout);
        }

        if (opts.endpoint) {
          opts.endpoint = setEndpoint(opts.endpoint, opts.secure);
        } else if (opts.region) {
          opts.endpoint = setRegion(opts.region, opts.internal, opts.secure);
        } else {
          throw new Error("require options.endpoint or options.region");
        }

        opts.inited = true;
        return opts;
      };

      /***/
    },

    /***/ 2341: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const merge = __nccwpck_require__(1149);

      const proto = exports;

      merge(proto, __nccwpck_require__(3280));

      /***/
    },

    /***/ 3280: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /* eslint-disable no-use-before-define */
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);
      const querystring = __nccwpck_require__(3477);
      const {
        Base64: { encode: str2Base64 }
      } = __nccwpck_require__(4139);

      const proto = exports;

      proto.processObjectSave = async function processObjectSave(sourceObject, targetObject, process, targetBucket) {
        checkArgs(sourceObject, "sourceObject");
        checkArgs(targetObject, "targetObject");
        checkArgs(process, "process");
        targetObject = this._objectName(targetObject);
        if (targetBucket) {
          _checkBucketName(targetBucket);
        }

        const params = this._objectRequestParams("POST", sourceObject, {
          subres: "x-oss-process"
        });

        const bucketParam = targetBucket ? `,b_${str2Base64(targetBucket)}` : "";
        targetObject = str2Base64(targetObject);

        const content = {
          "x-oss-process": `${process}|sys/saveas,o_${targetObject}${bucketParam}`
        };
        params.content = querystring.stringify(content);

        const result = await this.request(params);
        return {
          res: result.res,
          status: result.res.status
        };
      };

      function checkArgs(name, key) {
        if (!name) {
          throw new Error(`${key} is required`);
        }
        if (typeof name !== "string") {
          throw new Error(`${key} must be String`);
        }
      }

      /***/
    },

    /***/ 5944: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /* eslint-disable no-async-promise-executor */

      const debug = __nccwpck_require__(8237)("ali-oss:multipart-copy");
      const copy = __nccwpck_require__(952);

      const proto = exports;

      /**
       * Upload a part copy in a multipart from the source bucket/object
       * used with initMultipartUpload and completeMultipartUpload.
       * @param {String} name copy object name
       * @param {String} uploadId the upload id
       * @param {Number} partNo the part number
       * @param {String} range  like 0-102400  part size need to copy
       * @param {Object} sourceData
       *        {String} sourceData.sourceKey  the source object name
       *        {String} sourceData.sourceBucketName  the source bucket name
       * @param {Object} options
       */
      /* eslint max-len: [0] */
      proto.uploadPartCopy = async function uploadPartCopy(name, uploadId, partNo, range, sourceData, options = {}) {
        options.headers = options.headers || {};
        const versionId = options.versionId || (options.subres && options.subres.versionId) || null;
        let copySource;
        if (versionId) {
          copySource = `/${sourceData.sourceBucketName}/${encodeURIComponent(
            sourceData.sourceKey
          )}?versionId=${versionId}`;
        } else {
          copySource = `/${sourceData.sourceBucketName}/${encodeURIComponent(sourceData.sourceKey)}`;
        }

        options.headers["x-oss-copy-source"] = copySource;
        if (range) {
          options.headers["x-oss-copy-source-range"] = `bytes=${range}`;
        }

        options.subres = {
          partNumber: partNo,
          uploadId
        };
        const params = this._objectRequestParams("PUT", name, options);
        params.mime = options.mime;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          name,
          etag: result.res.headers.etag,
          res: result.res
        };
      };

      /**
       * @param {String} name copy object name
       * @param {Object} sourceData
       *        {String} sourceData.sourceKey  the source object name
       *        {String} sourceData.sourceBucketName  the source bucket name
       *        {Number} sourceData.startOffset  data copy start byte offset, e.g: 0
       *        {Number} sourceData.endOffset  data copy end byte offset, e.g: 102400
       * @param {Object} options
       *        {Number} options.partSize
       */
      proto.multipartUploadCopy = async function multipartUploadCopy(name, sourceData, options = {}) {
        this.resetCancelFlag();
        const { versionId = null } = options;
        const metaOpt = {
          versionId
        };
        const objectMeta = await this._getObjectMeta(sourceData.sourceBucketName, sourceData.sourceKey, metaOpt);
        const fileSize = objectMeta.res.headers["content-length"];
        sourceData.startOffset = sourceData.startOffset || 0;
        sourceData.endOffset = sourceData.endOffset || fileSize;

        if (options.checkpoint && options.checkpoint.uploadId) {
          return await this._resumeMultipartCopy(options.checkpoint, sourceData, options);
        }

        const minPartSize = 100 * 1024;

        const copySize = sourceData.endOffset - sourceData.startOffset;
        if (copySize < minPartSize) {
          throw new Error(`copySize must not be smaller than ${minPartSize}`);
        }

        if (options.partSize && options.partSize < minPartSize) {
          throw new Error(`partSize must not be smaller than ${minPartSize}`);
        }

        const init = await this.initMultipartUpload(name, options);
        const { uploadId } = init;
        const partSize = this._getPartSize(copySize, options.partSize);

        const checkpoint = {
          name,
          copySize,
          partSize,
          uploadId,
          doneParts: []
        };

        if (options && options.progress) {
          await options.progress(0, checkpoint, init.res);
        }

        return await this._resumeMultipartCopy(checkpoint, sourceData, options);
      };

      /*
       * Resume multipart copy from checkpoint. The checkpoint will be
       * updated after each successful part copy.
       * @param {Object} checkpoint the checkpoint
       * @param {Object} options
       */
      proto._resumeMultipartCopy = async function _resumeMultipartCopy(checkpoint, sourceData, options) {
        if (this.isCancel()) {
          throw this._makeCancelEvent();
        }
        const { versionId = null } = options;
        const metaOpt = {
          versionId
        };
        const { copySize, partSize, uploadId, doneParts, name } = checkpoint;

        const partOffs = this._divideMultipartCopyParts(copySize, partSize, sourceData.startOffset);
        const numParts = partOffs.length;

        const uploadPartCopyOptions = {
          headers: {}
        };

        if (options.copyheaders) {
          copy(options.copyheaders).to(uploadPartCopyOptions.headers);
        }
        if (versionId) {
          copy(metaOpt).to(uploadPartCopyOptions);
        }

        const uploadPartJob = function uploadPartJob(self, partNo, source) {
          return new Promise(async (resolve, reject) => {
            try {
              if (!self.isCancel()) {
                const pi = partOffs[partNo - 1];
                const range = `${pi.start}-${pi.end - 1}`;

                let result;
                try {
                  result = await self.uploadPartCopy(name, uploadId, partNo, range, source, uploadPartCopyOptions);
                } catch (error) {
                  if (error.status === 404) {
                    throw self._makeAbortEvent();
                  }
                  throw error;
                }
                if (!self.isCancel()) {
                  debug(`content-range ${result.res.headers["content-range"]}`);
                  doneParts.push({
                    number: partNo,
                    etag: result.res.headers.etag
                  });
                  checkpoint.doneParts = doneParts;

                  if (options && options.progress) {
                    await options.progress(doneParts.length / numParts, checkpoint, result.res);
                  }
                }
              }
              resolve();
            } catch (err) {
              err.partNum = partNo;
              reject(err);
            }
          });
        };

        const all = Array.from(new Array(numParts), (x, i) => i + 1);
        const done = doneParts.map((p) => p.number);
        const todo = all.filter((p) => done.indexOf(p) < 0);
        const defaultParallel = 5;
        const parallel = options.parallel || defaultParallel;

        if (this.checkBrowserAndVersion("Internet Explorer", "10") || parallel === 1) {
          for (let i = 0; i < todo.length; i++) {
            if (this.isCancel()) {
              throw this._makeCancelEvent();
            }
            /* eslint no-await-in-loop: [0] */
            await uploadPartJob(this, todo[i], sourceData);
          }
        } else {
          // upload in parallel
          const errors = await this._parallelNode(todo, parallel, uploadPartJob, sourceData);

          const abortEvent = errors.find((err) => err.name === "abort");
          if (abortEvent) throw abortEvent;

          if (this.isCancel()) {
            throw this._makeCancelEvent();
          }

          // check errors after all jobs are completed
          if (errors && errors.length > 0) {
            const err = errors[0];
            err.message = `Failed to copy some parts with error: ${err.toString()} part_num: ${err.partNum}`;
            throw err;
          }
        }

        return await this.completeMultipartUpload(name, uploadId, doneParts, options);
      };

      proto._divideMultipartCopyParts = function _divideMultipartCopyParts(fileSize, partSize, startOffset) {
        const numParts = Math.ceil(fileSize / partSize);

        const partOffs = [];
        for (let i = 0; i < numParts; i++) {
          const start = partSize * i + startOffset;
          const end = Math.min(start + partSize, fileSize + startOffset);

          partOffs.push({
            start,
            end
          });
        }

        return partOffs;
      };

      /**
       * Get Object Meta
       * @param {String} bucket  bucket name
       * @param {String} name   object name
       * @param {Object} options
       */
      proto._getObjectMeta = async function _getObjectMeta(bucket, name, options) {
        const currentBucket = this.getBucket();
        this.setBucket(bucket);
        const data = await this.head(name, options);
        this.setBucket(currentBucket);
        return data;
      };

      /***/
    },

    /***/ 5976: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const copy = __nccwpck_require__(952);
      const callback = __nccwpck_require__(6725);
      const { deepCopyWith } = __nccwpck_require__(7150);
      const { isBuffer } = __nccwpck_require__(5850);
      const { omit } = __nccwpck_require__(2577);

      const proto = exports;

      /**
       * List the on-going multipart uploads
       * https://help.aliyun.com/document_detail/31997.html
       * @param {Object} options
       * @return {Array} the multipart uploads
       */
      proto.listUploads = async function listUploads(query, options) {
        options = options || {};
        const opt = {};
        copy(options).to(opt);
        opt.subres = "uploads";
        const params = this._objectRequestParams("GET", "", opt);
        params.query = query;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);
        let uploads = result.data.Upload || [];
        if (!Array.isArray(uploads)) {
          uploads = [uploads];
        }
        uploads = uploads.map((up) => ({
          name: up.Key,
          uploadId: up.UploadId,
          initiated: up.Initiated
        }));

        return {
          res: result.res,
          uploads,
          bucket: result.data.Bucket,
          nextKeyMarker: result.data.NextKeyMarker,
          nextUploadIdMarker: result.data.NextUploadIdMarker,
          isTruncated: result.data.IsTruncated === "true"
        };
      };

      /**
       * List the done uploadPart parts
       * @param {String} name object name
       * @param {String} uploadId multipart upload id
       * @param {Object} query
       * {Number} query.max-parts The maximum part number in the response of the OSS. Default value: 1000
       * {Number} query.part-number-marker Starting position of a specific list.
       * {String} query.encoding-type Specify the encoding of the returned content and the encoding type.
       * @param {Object} options
       * @return {Object} result
       */
      proto.listParts = async function listParts(name, uploadId, query, options) {
        options = options || {};
        const opt = {};
        copy(options).to(opt);
        opt.subres = {
          uploadId
        };
        const params = this._objectRequestParams("GET", name, opt);
        params.query = query;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          res: result.res,
          uploadId: result.data.UploadId,
          bucket: result.data.Bucket,
          name: result.data.Key,
          partNumberMarker: result.data.PartNumberMarker,
          nextPartNumberMarker: result.data.NextPartNumberMarker,
          maxParts: result.data.MaxParts,
          isTruncated: result.data.IsTruncated,
          parts: result.data.Part || []
        };
      };

      /**
       * Abort a multipart upload transaction
       * @param {String} name the object name
       * @param {String} uploadId the upload id
       * @param {Object} options
       */
      proto.abortMultipartUpload = async function abortMultipartUpload(name, uploadId, options) {
        this._stop();
        options = options || {};
        const opt = {};
        copy(options).to(opt);
        opt.subres = { uploadId };
        const params = this._objectRequestParams("DELETE", name, opt);
        params.successStatuses = [204];

        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      /**
       * Initiate a multipart upload transaction
       * @param {String} name the object name
       * @param {Object} options
       * @return {String} upload id
       */
      proto.initMultipartUpload = async function initMultipartUpload(name, options) {
        options = options || {};
        const opt = {};
        copy(options).to(opt);
        opt.headers = opt.headers || {};
        this._convertMetaToHeaders(options.meta, opt.headers);

        opt.subres = "uploads";
        const params = this._objectRequestParams("POST", name, opt);
        params.mime = options.mime;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          res: result.res,
          bucket: result.data.Bucket,
          name: result.data.Key,
          uploadId: result.data.UploadId
        };
      };

      /**
       * Upload a part in a multipart upload transaction
       * @param {String} name the object name
       * @param {String} uploadId the upload id
       * @param {Integer} partNo the part number
       * @param {File} file upload File, whole File
       * @param {Integer} start  part start bytes  e.g: 102400
       * @param {Integer} end  part end bytes  e.g: 204800
       * @param {Object} options
       */
      proto.uploadPart = async function uploadPart(name, uploadId, partNo, file, start, end, options) {
        const data = {
          size: end - start
        };
        const isBrowserEnv = process && process.browser;
        isBrowserEnv
          ? (data.content = await this._createBuffer(file, start, end))
          : (data.stream = await this._createStream(file, start, end));
        return await this._uploadPart(name, uploadId, partNo, data, options);
      };

      /**
       * Complete a multipart upload transaction
       * @param {String} name the object name
       * @param {String} uploadId the upload id
       * @param {Array} parts the uploaded parts, each in the structure:
       *        {Integer} number partNo
       *        {String} etag  part etag  uploadPartCopy result.res.header.etag
       * @param {Object} options
       *         {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
       *         {String} options.callback.url  the OSS sends a callback request to this URL
       *         {String} options.callback.host  The host header value for initiating callback requests
       *         {String} options.callback.body  The value of the request body when a callback is initiated
       *         {String} options.callback.contentType  The Content-Type of the callback requests initiatiated
       *         {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:
       *                   customValue = {
       *                     key1: 'value1',
       *                     key2: 'value2'
       *                   }
       */
      proto.completeMultipartUpload = async function completeMultipartUpload(name, uploadId, parts, options) {
        const completeParts = parts
          .concat()
          .sort((a, b) => a.number - b.number)
          .filter((item, index, arr) => !index || item.number !== arr[index - 1].number);
        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n<CompleteMultipartUpload>\n';
        for (let i = 0; i < completeParts.length; i++) {
          const p = completeParts[i];
          xml += "<Part>\n";
          xml += `<PartNumber>${p.number}</PartNumber>\n`;
          xml += `<ETag>${p.etag}</ETag>\n`;
          xml += "</Part>\n";
        }
        xml += "</CompleteMultipartUpload>";

        options = options || {};
        let opt = {};
        opt = deepCopyWith(options, (_) => {
          if (isBuffer(_)) return null;
        });
        opt.subres = { uploadId };
        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption", "x-oss-storage-class"]);

        const params = this._objectRequestParams("POST", name, opt);
        callback.encodeCallback(params, opt);
        params.mime = "xml";
        params.content = xml;

        if (!(params.headers && params.headers["x-oss-callback"])) {
          params.xmlResponse = true;
        }
        params.successStatuses = [200];
        const result = await this.request(params);

        if (options.progress) {
          await options.progress(1, null, result.res);
        }

        const ret = {
          res: result.res,
          bucket: params.bucket,
          name,
          etag: result.res.headers.etag
        };

        if (params.headers && params.headers["x-oss-callback"]) {
          ret.data = JSON.parse(result.data.toString());
        }

        return ret;
      };

      /**
       * Upload a part in a multipart upload transaction
       * @param {String} name the object name
       * @param {String} uploadId the upload id
       * @param {Integer} partNo the part number
       * @param {Object} data the body data
       * @param {Object} options
       */
      proto._uploadPart = async function _uploadPart(name, uploadId, partNo, data, options) {
        options = options || {};
        const opt = {};
        copy(options).to(opt);
        opt.headers = opt.headers || {};
        opt.headers["Content-Length"] = data.size;

        // Uploading shards does not require x-oss server side encryption
        opt.headers = omit(opt.headers, ["x-oss-server-side-encryption"]);
        opt.subres = {
          partNumber: partNo,
          uploadId
        };

        const params = this._objectRequestParams("PUT", name, opt);
        params.mime = opt.mime;
        const isBrowserEnv = process && process.browser;
        isBrowserEnv ? (params.content = data.content) : (params.stream = data.stream);
        params.successStatuses = [200];
        params.disabledMD5 = options.disabledMD5;

        const result = await this.request(params);

        if (!result.res.headers.etag) {
          throw new Error(
            "Please set the etag of expose-headers in OSS \n https://help.aliyun.com/document_detail/32069.html"
          );
        }
        if (data.stream) {
          data.stream = null;
          params.stream = null;
        }
        return {
          name,
          etag: result.res.headers.etag,
          res: result.res
        };
      };

      /***/
    },

    /***/ 7330: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const urlutil = __nccwpck_require__(7310);
      const utility = __nccwpck_require__(3877);
      const copy = __nccwpck_require__(952);
      const signHelper = __nccwpck_require__(5150);
      const { isIP } = __nccwpck_require__(2439);
      const { setSTSToken } = __nccwpck_require__(4622);
      const { isFunction } = __nccwpck_require__(8818);

      const proto = exports;

      proto.asyncSignatureUrl = async function asyncSignatureUrl(name, options) {
        if (isIP(this.options.endpoint.hostname)) {
          throw new Error("can not get the object URL when endpoint is IP");
        }
        options = options || {};
        name = this._objectName(name);
        options.method = options.method || "GET";
        const expires = utility.timestamp() + (options.expires || 1800);
        const params = {
          bucket: this.options.bucket,
          object: name
        };

        const resource = this._getResource(params);

        if (this.options.stsToken && isFunction(this.options.refreshSTSToken)) {
          await setSTSToken.call(this);
        }

        if (this.options.stsToken) {
          options["security-token"] = this.options.stsToken;
        }

        const signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);

        const url = urlutil.parse(this._getReqUrl(params));
        url.query = {
          OSSAccessKeyId: this.options.accessKeyId,
          Expires: expires,
          Signature: signRes.Signature
        };

        copy(signRes.subResource).to(url.query);

        return url.format();
      };

      /***/
    },

    /***/ 2273: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { policy2Str } = __nccwpck_require__(61);
      const signHelper = __nccwpck_require__(5150);
      const { isObject } = __nccwpck_require__(1269);

      const proto = exports;

      /**
       * @param {Object or JSON} policy specifies the validity of the fields in the request.
       * @return {Object} params
       *         {String} params.OSSAccessKeyId
       *         {String} params.Signature
       *         {String} params.policy JSON text encoded with UTF-8 and Base64.
       */
      proto.calculatePostSignature = function calculatePostSignature(policy) {
        if (!isObject(policy) && typeof policy !== "string") {
          throw new Error("policy must be JSON string or Object");
        }
        if (!isObject(policy)) {
          try {
            JSON.stringify(JSON.parse(policy));
          } catch (error) {
            throw new Error("policy must be JSON string or Object");
          }
        }
        policy = Buffer.from(policy2Str(policy), "utf8").toString("base64");

        const Signature = signHelper.computeSignature(this.options.accessKeySecret, policy);

        const query = {
          OSSAccessKeyId: this.options.accessKeyId,
          Signature,
          policy
        };
        return query;
      };

      /***/
    },

    /***/ 5815: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkBucketName: _checkBucketName } = __nccwpck_require__(922);

      const proto = exports;

      const REPLACE_HEDERS = [
        "content-type",
        "content-encoding",
        "content-language",
        "content-disposition",
        "cache-control",
        "expires"
      ];

      proto.copy = async function copy(name, sourceName, bucketName, options) {
        if (typeof bucketName === "object") {
          options = bucketName; // options
        }
        options = options || {};
        options.headers = options.headers || {};

        Object.keys(options.headers).forEach((key) => {
          options.headers[`x-oss-copy-source-${key.toLowerCase()}`] = options.headers[key];
        });
        if (options.meta || Object.keys(options.headers).find((_) => REPLACE_HEDERS.includes(_.toLowerCase()))) {
          options.headers["x-oss-metadata-directive"] = "REPLACE";
        }
        this._convertMetaToHeaders(options.meta, options.headers);

        sourceName = this._getSourceName(sourceName, bucketName);

        if (options.versionId) {
          sourceName = `${sourceName}?versionId=${options.versionId}`;
        }

        options.headers["x-oss-copy-source"] = sourceName;

        const params = this._objectRequestParams("PUT", name, options);
        params.xmlResponse = true;
        params.successStatuses = [200, 304];

        const result = await this.request(params);

        let { data } = result;
        if (data) {
          data = {
            etag: data.ETag,
            lastModified: data.LastModified
          };
        }

        return {
          data,
          res: result.res
        };
      };

      // todo delete
      proto._getSourceName = function _getSourceName(sourceName, bucketName) {
        if (typeof bucketName === "string") {
          sourceName = this._objectName(sourceName);
        } else if (sourceName[0] !== "/") {
          bucketName = this.options.bucket;
        } else {
          bucketName = sourceName.replace(/\/(.+?)(\/.*)/, "$1");
          sourceName = sourceName.replace(/(\/.+?\/)(.*)/, "$2");
        }

        _checkBucketName(bucketName);

        sourceName = encodeURIComponent(sourceName);

        sourceName = `/${bucketName}/${sourceName}`;
        return sourceName;
      };

      /***/
    },

    /***/ 5515: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;
      /**
       * delete
       * @param {String} name - object name
       * @param {Object} options
       * @param {{res}}
       */

      proto.delete = async function _delete(name, options = {}) {
        options.subres = Object.assign({}, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("DELETE", name, options);
        params.successStatuses = [204];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 3103: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /* eslint-disable object-curly-newline */
      const utility = __nccwpck_require__(3877);
      const { obj2xml } = __nccwpck_require__(6846);

      const proto = exports;

      proto.deleteMulti = async function deleteMulti(names, options = {}) {
        const objects = [];
        if (!names || !names.length) {
          throw new Error("names is required");
        }
        for (let i = 0; i < names.length; i++) {
          const object = {};
          if (typeof names[i] === "string") {
            object.Key = utility.escape(this._objectName(names[i]));
          } else {
            const { key, versionId } = names[i];
            object.Key = utility.escape(this._objectName(key));
            object.VersionId = versionId;
          }
          objects.push(object);
        }

        const paramXMLObj = {
          Delete: {
            Quiet: !!options.quiet,
            Object: objects
          }
        };

        const paramXML = obj2xml(paramXMLObj, {
          headers: true
        });

        options.subres = Object.assign({ delete: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("POST", "", options);
        params.mime = "xml";
        params.content = paramXML;
        params.xmlResponse = true;
        params.successStatuses = [200];
        const result = await this.request(params);

        const r = result.data;
        let deleted = (r && r.Deleted) || null;
        if (deleted) {
          if (!Array.isArray(deleted)) {
            deleted = [deleted];
          }
        }
        return {
          res: result.res,
          deleted: deleted || []
        };
      };

      /***/
    },

    /***/ 7031: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;
      /**
       * deleteObjectTagging
       * @param {String} name - object name
       * @param {Object} options
       */

      proto.deleteObjectTagging = async function deleteObjectTagging(name, options = {}) {
        options.subres = Object.assign({ tagging: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        name = this._objectName(name);
        const params = this._objectRequestParams("DELETE", name, options);
        params.successStatuses = [204];
        const result = await this.request(params);

        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 2659: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const urlutil = __nccwpck_require__(7310);
      const { isIP } = __nccwpck_require__(2439);

      const proto = exports;

      /**
       * Get Object url by name
       * @param {String} name - object name
       * @param {String} [baseUrl] - If provide `baseUrl`, will use `baseUrl` instead the default `endpoint and bucket`.
       * @return {String} object url include bucket
       */
      proto.generateObjectUrl = function generateObjectUrl(name, baseUrl) {
        if (isIP(this.options.endpoint.hostname)) {
          throw new Error("can not get the object URL when endpoint is IP");
        }
        if (!baseUrl) {
          baseUrl = this.options.endpoint.format();
          const copyUrl = urlutil.parse(baseUrl);
          const { bucket } = this.options;

          copyUrl.hostname = `${bucket}.${copyUrl.hostname}`;
          copyUrl.host = `${bucket}.${copyUrl.host}`;
          baseUrl = copyUrl.format();
        } else if (baseUrl[baseUrl.length - 1] !== "/") {
          baseUrl += "/";
        }
        return baseUrl + this._escape(this._objectName(name));
      };

      /***/
    },

    /***/ 1973: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const fs = __nccwpck_require__(7147);
      const is = __nccwpck_require__(5565);

      const proto = exports;
      /**
       * get
       * @param {String} name - object name
       * @param {String | Stream} file
       * @param {Object} options
       * @param {{res}}
       */
      proto.get = async function get(name, file, options = {}) {
        let writeStream = null;
        let needDestroy = false;

        if (is.writableStream(file)) {
          writeStream = file;
        } else if (is.string(file)) {
          writeStream = fs.createWriteStream(file);
          needDestroy = true;
        } else {
          // get(name, options)
          options = file;
        }

        options = options || {};
        const isBrowserEnv = process && process.browser;
        const responseCacheControl = options.responseCacheControl === null ? "" : "no-cache";
        const defaultSubresOptions =
          isBrowserEnv && responseCacheControl ? { "response-cache-control": responseCacheControl } : {};
        options.subres = Object.assign(defaultSubresOptions, options.subres);

        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        if (options.process) {
          options.subres["x-oss-process"] = options.process;
        }

        let result;
        try {
          const params = this._objectRequestParams("GET", name, options);
          params.writeStream = writeStream;
          params.successStatuses = [200, 206, 304];

          result = await this.request(params);

          if (needDestroy) {
            writeStream.destroy();
          }
        } catch (err) {
          if (needDestroy) {
            writeStream.destroy();
            // should delete the exists file before throw error
            await this._deleteFileSafe(file);
          }
          throw err;
        }

        return {
          res: result.res,
          content: result.data
        };
      };

      /***/
    },

    /***/ 6599: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;

      /*
       * Get object's ACL
       * @param {String} name the object key
       * @param {Object} options
       * @return {Object}
       */
      proto.getACL = async function getACL(name, options = {}) {
        options.subres = Object.assign({ acl: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        name = this._objectName(name);

        const params = this._objectRequestParams("GET", name, options);
        params.successStatuses = [200];
        params.xmlResponse = true;

        const result = await this.request(params);

        return {
          acl: result.data.AccessControlList.Grant,
          owner: {
            id: result.data.Owner.ID,
            displayName: result.data.Owner.DisplayName
          },
          res: result.res
        };
      };

      /***/
    },

    /***/ 6595: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getAsyncFetch = void 0;
      const formatObjKey_1 = __nccwpck_require__(2095);
      /*
       * getAsyncFetch
       * @param {String} asyncFetch taskId
       * @param {Object} options
       */
      async function getAsyncFetch(taskId, options = {}) {
        options.subres = Object.assign({ asyncFetch: "" }, options.subres);
        options.headers = options.headers || {};
        const params = this._objectRequestParams("GET", "", options);
        params.headers["x-oss-task-id"] = taskId;
        params.successStatuses = [200];
        params.xmlResponse = true;
        const result = await this.request(params);
        const taskInfo = formatObjKey_1.formatObjKey(result.data.TaskInfo, "firstLowerCase");
        return {
          res: result.res,
          status: result.status,
          state: result.data.State,
          taskInfo
        };
      }
      exports.getAsyncFetch = getAsyncFetch;

      /***/
    },

    /***/ 7406: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /* eslint-disable no-use-before-define */
      const proto = exports;
      const { isObject } = __nccwpck_require__(1269);
      const { isArray } = __nccwpck_require__(1954);

      proto.getBucketVersions = getBucketVersions;
      proto.listObjectVersions = getBucketVersions;

      async function getBucketVersions(query = {}, options = {}) {
        // prefix, key-marker, max-keys, delimiter, encoding-type, version-id-marker
        if (query.versionIdMarker && query.keyMarker === undefined) {
          throw new Error("A version-id marker cannot be specified without a key marker");
        }

        options.subres = Object.assign({ versions: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("GET", "", options);
        params.xmlResponse = true;
        params.successStatuses = [200];

        params.query = formatQuery(query);

        const result = await this.request(params);
        let objects = result.data.Version || [];
        let deleteMarker = result.data.DeleteMarker || [];
        const that = this;
        if (objects) {
          if (!Array.isArray(objects)) {
            objects = [objects];
          }
          objects = objects.map((obj) => ({
            name: obj.Key,
            url: that._objectUrl(obj.Key),
            lastModified: obj.LastModified,
            isLatest: obj.IsLatest === "true",
            versionId: obj.VersionId,
            etag: obj.ETag,
            type: obj.Type,
            size: Number(obj.Size),
            storageClass: obj.StorageClass,
            owner: {
              id: obj.Owner.ID,
              displayName: obj.Owner.DisplayName
            }
          }));
        }
        if (deleteMarker) {
          if (!isArray(deleteMarker)) {
            deleteMarker = [deleteMarker];
          }
          deleteMarker = deleteMarker.map((obj) => ({
            name: obj.Key,
            lastModified: obj.LastModified,
            versionId: obj.VersionId,
            owner: {
              id: obj.Owner.ID,
              displayName: obj.Owner.DisplayName
            }
          }));
        }
        let prefixes = result.data.CommonPrefixes || null;
        if (prefixes) {
          if (!isArray(prefixes)) {
            prefixes = [prefixes];
          }
          prefixes = prefixes.map((item) => item.Prefix);
        }
        return {
          res: result.res,
          objects,
          deleteMarker,
          prefixes,
          // attirbute of legacy error
          nextMarker: result.data.NextKeyMarker || null,
          // attirbute of legacy error
          NextVersionIdMarker: result.data.NextVersionIdMarker || null,
          nextKeyMarker: result.data.NextKeyMarker || null,
          nextVersionIdMarker: result.data.NextVersionIdMarker || null,
          isTruncated: result.data.IsTruncated === "true"
        };
      }

      function camel2Line(name) {
        return name.replace(/([A-Z])/g, "-$1").toLowerCase();
      }

      function formatQuery(query = {}) {
        const obj = {};
        if (isObject(query)) {
          Object.keys(query).forEach((key) => {
            obj[camel2Line(key)] = query[key];
          });
        }

        return obj;
      }

      /***/
    },

    /***/ 4552: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;
      /**
       * getObjectMeta
       * @param {String} name - object name
       * @param {Object} options
       * @param {{res}}
       */

      proto.getObjectMeta = async function getObjectMeta(name, options) {
        options = options || {};
        name = this._objectName(name);
        options.subres = Object.assign({ objectMeta: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("HEAD", name, options);
        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          status: result.status,
          res: result.res
        };
      };

      /***/
    },

    /***/ 9795: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const proto = exports;
      const { isObject } = __nccwpck_require__(1269);
      /**
       * getObjectTagging
       * @param {String} name - object name
       * @param {Object} options
       * @return {Object}
       */

      proto.getObjectTagging = async function getObjectTagging(name, options = {}) {
        options.subres = Object.assign({ tagging: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        name = this._objectName(name);
        const params = this._objectRequestParams("GET", name, options);
        params.successStatuses = [200];
        const result = await this.request(params);
        const Tagging = await this.parseXML(result.data);
        let { Tag } = Tagging.TagSet;
        Tag = Tag && isObject(Tag) ? [Tag] : Tag || [];

        const tag = {};

        Tag.forEach((item) => {
          tag[item.Key] = item.Value;
        });

        return {
          status: result.status,
          res: result.res,
          tag
        };
      };

      /***/
    },

    /***/ 5633: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { isIP } = __nccwpck_require__(2439);

      const proto = exports;
      /**
       * Get Object url by name
       * @param {String} name - object name
       * @param {String} [baseUrl] - If provide `baseUrl`,
       *        will use `baseUrl` instead the default `endpoint`.
       * @return {String} object url
       */
      proto.getObjectUrl = function getObjectUrl(name, baseUrl) {
        if (isIP(this.options.endpoint.hostname)) {
          throw new Error("can not get the object URL when endpoint is IP");
        }
        if (!baseUrl) {
          baseUrl = this.options.endpoint.format();
        } else if (baseUrl[baseUrl.length - 1] !== "/") {
          baseUrl += "/";
        }
        return baseUrl + this._escape(this._objectName(name));
      };

      /***/
    },

    /***/ 9797: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;
      /**
       * getSymlink
       * @param {String} name - object name
       * @param {Object} options
       * @param {{res}}
       */

      proto.getSymlink = async function getSymlink(name, options = {}) {
        options.subres = Object.assign({ symlink: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        name = this._objectName(name);
        const params = this._objectRequestParams("GET", name, options);
        params.successStatuses = [200];
        const result = await this.request(params);
        const target = result.res.headers["x-oss-symlink-target"];
        return {
          targetName: decodeURIComponent(target),
          res: result.res
        };
      };

      /***/
    },

    /***/ 411: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { checkEnv } = __nccwpck_require__(7211);
      const proto = exports;
      /**
       * head
       * @param {String} name - object name
       * @param {Object} options
       * @param {{res}}
       */

      proto.head = async function head(name, options = {}) {
        checkEnv(
          "Because HeadObject has gzip enabled, head cannot get the file size correctly. If you need to get the file size, please use getObjectMeta"
        );
        options.subres = Object.assign({}, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("HEAD", name, options);
        params.successStatuses = [200, 304];

        const result = await this.request(params);

        const data = {
          meta: null,
          res: result.res,
          status: result.status
        };

        if (result.status === 200) {
          Object.keys(result.headers).forEach((k) => {
            if (k.indexOf("x-oss-meta-") === 0) {
              if (!data.meta) {
                data.meta = {};
              }
              data.meta[k.substring(11)] = result.headers[k];
            }
          });
        }
        return data;
      };

      /***/
    },

    /***/ 8417: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const merge = __nccwpck_require__(1149);

      const proto = exports;

      merge(proto, __nccwpck_require__(9797));
      merge(proto, __nccwpck_require__(9547));
      merge(proto, __nccwpck_require__(4552));
      merge(proto, __nccwpck_require__(5815));
      merge(proto, __nccwpck_require__(2273));
      merge(proto, __nccwpck_require__(9795));
      merge(proto, __nccwpck_require__(4972));
      merge(proto, __nccwpck_require__(7031));
      merge(proto, __nccwpck_require__(7406));
      merge(proto, __nccwpck_require__(3103));
      merge(proto, __nccwpck_require__(6599));
      merge(proto, __nccwpck_require__(5366));
      merge(proto, __nccwpck_require__(411));
      merge(proto, __nccwpck_require__(5515));
      merge(proto, __nccwpck_require__(1973));
      merge(proto, __nccwpck_require__(501));
      merge(proto, __nccwpck_require__(6595));
      merge(proto, __nccwpck_require__(2659));
      merge(proto, __nccwpck_require__(5633));
      merge(proto, __nccwpck_require__(3252));
      merge(proto, __nccwpck_require__(7330));

      /***/
    },

    /***/ 501: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.postAsyncFetch = void 0;
      const obj2xml_1 = __nccwpck_require__(6846);
      /*
       * postAsyncFetch
       * @param {String} name the object key
       * @param {String} url
       * @param {Object} options
       *        {String} options.host
       *        {String} options.contentMD5
       *        {String} options.callback
       *        {String} options.storageClass Standard/IA/Archive
       *        {Boolean} options.ignoreSameKey  default value true
       */
      async function postAsyncFetch(object, url, options = {}) {
        options.subres = Object.assign({ asyncFetch: "" }, options.subres);
        options.headers = options.headers || {};
        object = this._objectName(object);
        const { host = "", contentMD5 = "", callback = "", storageClass = "", ignoreSameKey = true } = options;
        const paramXMLObj = {
          AsyncFetchTaskConfiguration: {
            Url: url,
            Object: object,
            Host: host,
            ContentMD5: contentMD5,
            Callback: callback,
            StorageClass: storageClass,
            IgnoreSameKey: ignoreSameKey
          }
        };
        const params = this._objectRequestParams("POST", "", options);
        params.mime = "xml";
        params.xmlResponse = true;
        params.successStatuses = [200];
        params.content = obj2xml_1.obj2xml(paramXMLObj);
        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status,
          taskId: result.data.TaskId
        };
      }
      exports.postAsyncFetch = postAsyncFetch;

      /***/
    },

    /***/ 5366: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;

      /*
       * Set object's ACL
       * @param {String} name the object key
       * @param {String} acl the object ACL
       * @param {Object} options
       */
      proto.putACL = async function putACL(name, acl, options) {
        options = options || {};
        options.subres = Object.assign({ acl: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        options.headers = options.headers || {};
        options.headers["x-oss-object-acl"] = acl;
        name = this._objectName(name);

        const params = this._objectRequestParams("PUT", name, options);
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 4972: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { obj2xml } = __nccwpck_require__(6846);
      const { checkObjectTag } = __nccwpck_require__(849);

      const proto = exports;
      /**
       * putObjectTagging
       * @param {String} name - object name
       * @param {Object} tag -  object tag, eg: `{a: "1", b: "2"}`
       * @param {Object} options
       */

      proto.putObjectTagging = async function putObjectTagging(name, tag, options = {}) {
        checkObjectTag(tag);

        options.subres = Object.assign({ tagging: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        name = this._objectName(name);
        const params = this._objectRequestParams("PUT", name, options);
        params.successStatuses = [200];
        tag = Object.keys(tag).map((key) => ({
          Key: key,
          Value: tag[key]
        }));

        const paramXMLObj = {
          Tagging: {
            TagSet: {
              Tag: tag
            }
          }
        };

        params.mime = "xml";
        params.content = obj2xml(paramXMLObj);

        const result = await this.request(params);
        return {
          res: result.res,
          status: result.status
        };
      };

      /***/
    },

    /***/ 9547: /***/ (__unused_webpack_module, exports) => {
      const proto = exports;
      /**
       * putSymlink
       * @param {String} name - object name
       * @param {String} targetName - target name
       * @param {Object} options
       * @param {{res}}
       */

      proto.putSymlink = async function putSymlink(name, targetName, options) {
        options = options || {};
        options.headers = options.headers || {};
        targetName = this._escape(this._objectName(targetName));
        this._convertMetaToHeaders(options.meta, options.headers);
        options.headers["x-oss-symlink-target"] = targetName;
        options.subres = Object.assign({ symlink: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }

        if (options.storageClass) {
          options.headers["x-oss-storage-class"] = options.storageClass;
        }

        name = this._objectName(name);
        const params = this._objectRequestParams("PUT", name, options);

        params.successStatuses = [200];
        const result = await this.request(params);
        return {
          res: result.res
        };
      };

      /***/
    },

    /***/ 3252: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const urlutil = __nccwpck_require__(7310);
      const utility = __nccwpck_require__(3877);
      const copy = __nccwpck_require__(952);
      const signHelper = __nccwpck_require__(5150);
      const { isIP } = __nccwpck_require__(2439);

      const proto = exports;

      /**
       *  signatureUrl
       * @deprecated will be deprecated in 7.x
       * @param {String} name object name
       * @param {Object} options  options
       */
      proto.signatureUrl = function signatureUrl(name, options) {
        if (isIP(this.options.endpoint.hostname)) {
          throw new Error("can not get the object URL when endpoint is IP");
        }
        options = options || {};
        name = this._objectName(name);
        options.method = options.method || "GET";
        const expires = utility.timestamp() + (options.expires || 1800);
        const params = {
          bucket: this.options.bucket,
          object: name
        };

        const resource = this._getResource(params);

        if (this.options.stsToken) {
          options["security-token"] = this.options.stsToken;
        }

        const signRes = signHelper._signatureForURL(this.options.accessKeySecret, options, resource, expires);

        const url = urlutil.parse(this._getReqUrl(params));
        url.query = {
          OSSAccessKeyId: this.options.accessKeyId,
          Expires: expires,
          Signature: signRes.Signature
        };

        copy(signRes.subResource).to(url.query);

        return url.format();
      };

      /***/
    },

    /***/ 986: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const { isArray } = __nccwpck_require__(1954);

      const proto = exports;

      proto._parallelNode = async function _parallelNode(todo, parallel, fn, sourceData) {
        const that = this;
        // upload in parallel
        const jobErr = [];
        let jobs = [];
        const tempBatch = todo.length / parallel;
        const remainder = todo.length % parallel;
        const batch = remainder === 0 ? tempBatch : (todo.length - remainder) / parallel + 1;
        let taskIndex = 1;
        for (let i = 0; i < todo.length; i++) {
          if (that.isCancel()) {
            break;
          }

          if (sourceData) {
            jobs.push(fn(that, todo[i], sourceData));
          } else {
            jobs.push(fn(that, todo[i]));
          }

          if (jobs.length === parallel || (taskIndex === batch && i === todo.length - 1)) {
            try {
              taskIndex += 1;
              /* eslint no-await-in-loop: [0] */
              await Promise.all(jobs);
            } catch (err) {
              jobErr.push(err);
            }
            jobs = [];
          }
        }

        return jobErr;
      };

      proto._parallel = function _parallel(todo, parallel, jobPromise) {
        const that = this;
        return new Promise((resolve) => {
          const _jobErr = [];
          if (parallel <= 0 || !todo) {
            resolve(_jobErr);
            return;
          }

          function onlyOnce(fn) {
            return function (...args) {
              if (fn === null) throw new Error("Callback was already called.");
              const callFn = fn;
              fn = null;
              callFn.apply(this, args);
            };
          }

          function createArrayIterator(coll) {
            let i = -1;
            const len = coll.length;
            return function next() {
              return ++i < len && !that.isCancel() ? { value: coll[i], key: i } : null;
            };
          }

          const nextElem = createArrayIterator(todo);
          let done = false;
          let running = 0;
          let looping = false;

          function iterateeCallback(err) {
            running -= 1;
            if (err) {
              done = true;
              _jobErr.push(err);
              resolve(_jobErr);
            } else if (done && running <= 0) {
              done = true;
              resolve(_jobErr);
            } else if (!looping) {
              /* eslint no-use-before-define: [0] */
              if (that.isCancel()) {
                resolve(_jobErr);
              } else {
                replenish();
              }
            }
          }

          function iteratee(value, callback) {
            jobPromise(value)
              .then((result) => {
                callback(null, result);
              })
              .catch((err) => {
                callback(err);
              });
          }

          function replenish() {
            looping = true;
            while (running < parallel && !done && !that.isCancel()) {
              const elem = nextElem();
              if (elem === null || _jobErr.length > 0) {
                done = true;
                if (running <= 0) {
                  resolve(_jobErr);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, onlyOnce(iterateeCallback));
            }
            looping = false;
          }

          replenish();
        });
      };

      /**
       * cancel operation, now can use with multipartUpload
       * @param {Object} abort
       *        {String} anort.name object key
       *        {String} anort.uploadId upload id
       *        {String} anort.options timeout
       */
      proto.cancel = function cancel(abort) {
        this.options.cancelFlag = true;

        if (isArray(this.multipartUploadStreams)) {
          this.multipartUploadStreams.forEach((_) => {
            if (_.destroyed === false) {
              const err = {
                name: "cancel",
                message: "cancel"
              };
              _.destroy(err);
            }
          });
        }
        this.multipartUploadStreams = [];
        if (abort) {
          this.abortMultipartUpload(abort.name, abort.uploadId, abort.options);
        }
      };

      proto.isCancel = function isCancel() {
        return this.options.cancelFlag;
      };

      proto.resetCancelFlag = function resetCancelFlag() {
        this.options.cancelFlag = false;
      };

      proto._stop = function _stop() {
        this.options.cancelFlag = true;
      };

      // cancel is not error , so create an object
      proto._makeCancelEvent = function _makeCancelEvent() {
        const cancelEvent = {
          status: 0,
          name: "cancel"
        };
        return cancelEvent;
      };

      // abort is not error , so create an object
      proto._makeAbortEvent = function _makeAbortEvent() {
        const abortEvent = {
          status: 0,
          name: "abort",
          message: "upload task has been abort"
        };
        return abortEvent;
      };

      /***/
    },

    /***/ 5150: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const crypto = __nccwpck_require__(6113);
      const is = __nccwpck_require__(5565);
      const { lowercaseKeyHeader } = __nccwpck_require__(5285);

      /**
       *
       * @param {String} resourcePath
       * @param {Object} parameters
       * @return
       */
      exports.buildCanonicalizedResource = function buildCanonicalizedResource(resourcePath, parameters) {
        let canonicalizedResource = `${resourcePath}`;
        let separatorString = "?";

        if (is.string(parameters) && parameters.trim() !== "") {
          canonicalizedResource += separatorString + parameters;
        } else if (is.array(parameters)) {
          parameters.sort();
          canonicalizedResource += separatorString + parameters.join("&");
        } else if (parameters) {
          const compareFunc = (entry1, entry2) => {
            if (entry1[0] > entry2[0]) {
              return 1;
            } else if (entry1[0] < entry2[0]) {
              return -1;
            }
            return 0;
          };
          const processFunc = (key) => {
            canonicalizedResource += separatorString + key;
            if (parameters[key] || parameters[key] === 0) {
              canonicalizedResource += `=${parameters[key]}`;
            }
            separatorString = "&";
          };
          Object.keys(parameters).sort(compareFunc).forEach(processFunc);
        }

        return canonicalizedResource;
      };

      /**
       * @param {String} method
       * @param {String} resourcePath
       * @param {Object} request
       * @param {String} expires
       * @return {String} canonicalString
       */
      exports.buildCanonicalString = function canonicalString(method, resourcePath, request, expires) {
        request = request || {};
        const headers = lowercaseKeyHeader(request.headers);
        const OSS_PREFIX = "x-oss-";
        const ossHeaders = [];
        const headersToSign = {};

        let signContent = [
          method.toUpperCase(),
          headers["content-md5"] || "",
          headers["content-type"],
          expires || headers["x-oss-date"]
        ];

        Object.keys(headers).forEach((key) => {
          const lowerKey = key.toLowerCase();
          if (lowerKey.indexOf(OSS_PREFIX) === 0) {
            headersToSign[lowerKey] = String(headers[key]).trim();
          }
        });

        Object.keys(headersToSign)
          .sort()
          .forEach((key) => {
            ossHeaders.push(`${key}:${headersToSign[key]}`);
          });

        signContent = signContent.concat(ossHeaders);

        signContent.push(this.buildCanonicalizedResource(resourcePath, request.parameters));

        return signContent.join("\n");
      };

      /**
       * @param {String} accessKeySecret
       * @param {String} canonicalString
       */
      exports.computeSignature = function computeSignature(accessKeySecret, canonicalString, headerEncoding = "utf-8") {
        const signature = crypto.createHmac("sha1", accessKeySecret);
        return signature.update(Buffer.from(canonicalString, headerEncoding)).digest("base64");
      };

      /**
       * @param {String} accessKeyId
       * @param {String} accessKeySecret
       * @param {String} canonicalString
       */
      exports.authorization = function authorization(accessKeyId, accessKeySecret, canonicalString, headerEncoding) {
        return `OSS ${accessKeyId}:${this.computeSignature(accessKeySecret, canonicalString, headerEncoding)}`;
      };

      /**
       *
       * @param {String} accessKeySecret
       * @param {Object} options
       * @param {String} resource
       * @param {Number} expires
       */
      exports._signatureForURL = function _signatureForURL(
        accessKeySecret,
        options = {},
        resource,
        expires,
        headerEncoding
      ) {
        const headers = {};
        const { subResource = {} } = options;

        if (options.process) {
          const processKeyword = "x-oss-process";
          subResource[processKeyword] = options.process;
        }

        if (options.trafficLimit) {
          const trafficLimitKey = "x-oss-traffic-limit";
          subResource[trafficLimitKey] = options.trafficLimit;
        }

        if (options.response) {
          Object.keys(options.response).forEach((k) => {
            const key = `response-${k.toLowerCase()}`;
            subResource[key] = options.response[k];
          });
        }

        Object.keys(options).forEach((key) => {
          const lowerKey = key.toLowerCase();
          const value = options[key];
          if (lowerKey.indexOf("x-oss-") === 0) {
            headers[lowerKey] = value;
          } else if (lowerKey.indexOf("content-md5") === 0) {
            headers[key] = value;
          } else if (lowerKey.indexOf("content-type") === 0) {
            headers[key] = value;
          }
        });

        if (Object.prototype.hasOwnProperty.call(options, "security-token")) {
          subResource["security-token"] = options["security-token"];
        }

        if (Object.prototype.hasOwnProperty.call(options, "callback")) {
          const json = {
            callbackUrl: encodeURI(options.callback.url),
            callbackBody: options.callback.body
          };
          if (options.callback.host) {
            json.callbackHost = options.callback.host;
          }
          if (options.callback.contentType) {
            json.callbackBodyType = options.callback.contentType;
          }
          subResource.callback = Buffer.from(JSON.stringify(json)).toString("base64");

          if (options.callback.customValue) {
            const callbackVar = {};
            Object.keys(options.callback.customValue).forEach((key) => {
              callbackVar[`x:${key}`] = options.callback.customValue[key];
            });
            subResource["callback-var"] = Buffer.from(JSON.stringify(callbackVar)).toString("base64");
          }
        }

        const canonicalString = this.buildCanonicalString(
          options.method,
          resource,
          {
            headers,
            parameters: subResource
          },
          expires.toString()
        );

        return {
          Signature: this.computeSignature(accessKeySecret, canonicalString, headerEncoding),
          subResource
        };
      };

      /***/
    },

    /***/ 922: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkBucketName = void 0;
      exports.checkBucketName = (name, createBucket = false) => {
        const bucketRegex = createBucket ? /^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$/ : /^[a-z0-9_][a-z0-9-_]{1,61}[a-z0-9_]$/;
        if (!bucketRegex.test(name)) {
          throw new Error("The bucket must be conform to the specifications");
        }
      };

      /***/
    },

    /***/ 8694: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkBucketTag = void 0;
      const { checkValid } = __nccwpck_require__(7355);
      const { isObject } = __nccwpck_require__(1269);
      const commonRules = [
        {
          validator: (value) => {
            if (typeof value !== "string") {
              throw new Error("the key and value of the tag must be String");
            }
          }
        }
      ];
      const rules = {
        key: [
          ...commonRules,
          {
            pattern: /^.{1,64}$/,
            msg: "tag key can be a maximum of 64 bytes in length"
          },
          {
            pattern: /^(?!https*:\/\/|Aliyun)/,
            msg: "tag key can not startsWith: http://, https://, Aliyun"
          }
        ],
        value: [
          ...commonRules,
          {
            pattern: /^.{0,128}$/,
            msg: "tag value can be a maximum of 128 bytes in length"
          }
        ]
      };
      exports.checkBucketTag = (tag) => {
        if (!isObject(tag)) {
          throw new Error("bucket tag must be Object");
        }
        const entries = Object.entries(tag);
        if (entries.length > 20) {
          throw new Error("maximum of 20 tags for a bucket");
        }
        const rulesIndexKey = ["key", "value"];
        entries.forEach((keyValue) => {
          keyValue.forEach((item, index) => {
            checkValid(item, rules[rulesIndexKey[index]]);
          });
        });
      };

      /***/
    },

    /***/ 7324: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkConfigValid = void 0;
      const checkConfigMap = {
        endpoint: checkEndpoint,
        region: /^[a-zA-Z0-9\-_]+$/
      };
      function checkEndpoint(endpoint) {
        if (typeof endpoint === "string") {
          return /^[a-zA-Z0-9._:/-]+$/.test(endpoint);
        } else if (endpoint.host) {
          return /^[a-zA-Z0-9._:/-]+$/.test(endpoint.host);
        }
        return false;
      }
      exports.checkConfigValid = (conf, key) => {
        if (checkConfigMap[key]) {
          let isConfigValid = true;
          if (checkConfigMap[key] instanceof Function) {
            isConfigValid = checkConfigMap[key](conf);
          } else {
            isConfigValid = checkConfigMap[key].test(conf);
          }
          if (!isConfigValid) {
            throw new Error(`The ${key} must be conform to the specifications`);
          }
        }
      };

      /***/
    },

    /***/ 7211: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkEnv = void 0;
      function checkEnv(msg) {
        if (process.browser) {
          console.warn(msg);
        }
      }
      exports.checkEnv = checkEnv;

      /***/
    },

    /***/ 849: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkObjectTag = void 0;
      const { checkValid } = __nccwpck_require__(7355);
      const { isObject } = __nccwpck_require__(1269);
      const commonRules = [
        {
          validator: (value) => {
            if (typeof value !== "string") {
              throw new Error("the key and value of the tag must be String");
            }
          }
        },
        {
          pattern: /^[a-zA-Z0-9 +-=._:/]+$/,
          msg: "tag can contain letters, numbers, spaces, and the following symbols: plus sign (+), hyphen (-), equal sign (=), period (.), underscore (_), colon (:), and forward slash (/)"
        }
      ];
      const rules = {
        key: [
          ...commonRules,
          {
            pattern: /^.{1,128}$/,
            msg: "tag key can be a maximum of 128 bytes in length"
          }
        ],
        value: [
          ...commonRules,
          {
            pattern: /^.{0,256}$/,
            msg: "tag value can be a maximum of 256 bytes in length"
          }
        ]
      };
      function checkObjectTag(tag) {
        if (!isObject(tag)) {
          throw new Error("tag must be Object");
        }
        const entries = Object.entries(tag);
        if (entries.length > 10) {
          throw new Error("maximum of 10 tags for a object");
        }
        const rulesIndexKey = ["key", "value"];
        entries.forEach((keyValue) => {
          keyValue.forEach((item, index) => {
            checkValid(item, rules[rulesIndexKey[index]]);
          });
        });
      }
      exports.checkObjectTag = checkObjectTag;

      /***/
    },

    /***/ 7355: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkValid = void 0;
      function checkValid(_value, _rules) {
        _rules.forEach((rule) => {
          if (rule.validator) {
            rule.validator(_value);
          } else if (rule.pattern && !rule.pattern.test(_value)) {
            throw new Error(rule.msg);
          }
        });
      }
      exports.checkValid = checkValid;

      /***/
    },

    /***/ 1828: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createRequest = void 0;
      const crypto = __nccwpck_require__(6113);
      const debug = __nccwpck_require__(8237)("ali-oss");
      const mime = __nccwpck_require__(9994);
      const dateFormat = __nccwpck_require__(1512);
      const copy = __nccwpck_require__(952);
      const path = __nccwpck_require__(1017);
      const { encoder } = __nccwpck_require__(3240);
      const { isIP } = __nccwpck_require__(2439);
      const { setRegion } = __nccwpck_require__(6690);
      const { getReqUrl } = __nccwpck_require__(6783);
      const { isDingTalk } = __nccwpck_require__(5605);
      function getHeader(headers, name) {
        return headers[name] || headers[name.toLowerCase()];
      }
      function delHeader(headers, name) {
        delete headers[name];
        delete headers[name.toLowerCase()];
      }
      function createRequest(params) {
        let date = new Date();
        if (this.options.amendTimeSkewed) {
          date = +new Date() + this.options.amendTimeSkewed;
        }
        const headers = {
          "x-oss-date": dateFormat(date, "UTC:ddd, dd mmm yyyy HH:MM:ss 'GMT'")
        };
        if (typeof window !== "undefined") {
          headers["x-oss-user-agent"] = this.userAgent;
        }
        if (this.userAgent.includes("nodejs")) {
          headers["User-Agent"] = this.userAgent;
        }
        if (this.options.isRequestPay) {
          Object.assign(headers, { "x-oss-request-payer": "requester" });
        }
        if (this.options.stsToken) {
          headers["x-oss-security-token"] = this.options.stsToken;
        }
        copy(params.headers).to(headers);
        if (!getHeader(headers, "Content-Type")) {
          if (params.mime && params.mime.indexOf("/") > 0) {
            headers["Content-Type"] = params.mime;
          } else if (isDingTalk()) {
            headers["Content-Type"] = "application/octet-stream";
          } else {
            headers["Content-Type"] = mime.getType(params.mime || path.extname(params.object || ""));
          }
        }
        if (!getHeader(headers, "Content-Type")) {
          delHeader(headers, "Content-Type");
        }
        if (params.content) {
          if (!params.disabledMD5) {
            if (!params.headers || !params.headers["Content-MD5"]) {
              headers["Content-MD5"] = crypto
                .createHash("md5")
                .update(Buffer.from(params.content, "utf8"))
                .digest("base64");
            } else {
              headers["Content-MD5"] = params.headers["Content-MD5"];
            }
          }
          if (!headers["Content-Length"]) {
            headers["Content-Length"] = params.content.length;
          }
        }
        const { hasOwnProperty } = Object.prototype;
        for (const k in headers) {
          if (headers[k] && hasOwnProperty.call(headers, k)) {
            headers[k] = encoder(String(headers[k]), this.options.headerEncoding);
          }
        }
        const authResource = this._getResource(params);
        headers.authorization = this.authorization(
          params.method,
          authResource,
          params.subres,
          headers,
          this.options.headerEncoding
        );
        // const url = this._getReqUrl(params);
        if (isIP(this.options.endpoint.hostname)) {
          const { region, internal, secure } = this.options;
          const hostInfo = setRegion(region, internal, secure);
          headers.host = `${params.bucket}.${hostInfo.host}`;
        }
        const url = getReqUrl.bind(this)(params);
        debug("request %s %s, with headers %j, !!stream: %s", params.method, url, headers, !!params.stream);
        const timeout = params.timeout || this.options.timeout;
        const reqParams = {
          method: params.method,
          content: params.content,
          stream: params.stream,
          headers,
          timeout,
          writeStream: params.writeStream,
          customResponse: params.customResponse,
          ctx: params.ctx || this.ctx
        };
        if (this.agent) {
          reqParams.agent = this.agent;
        }
        if (this.httpsAgent) {
          reqParams.httpsAgent = this.httpsAgent;
        }
        reqParams.enableProxy = !!this.options.enableProxy;
        reqParams.proxy = this.options.proxy ? this.options.proxy : null;
        return {
          url,
          params: reqParams
        };
      }
      exports.createRequest = createRequest;

      /***/
    },

    /***/ 1615: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dataFix = void 0;
      const isObject_1 = __nccwpck_require__(1269);
      const TRUE = ["true", "TRUE", "1", 1];
      const FALSE = ["false", "FALSE", "0", 0];
      function dataFix(o, conf, finalKill) {
        if (!isObject_1.isObject(o)) return;
        const { remove = [], rename = {}, camel = [], bool = [], lowerFirst = false } = conf;
        // 
        remove.forEach((v) => delete o[v]);
        // 
        Object.entries(rename).forEach((v) => {
          if (!o[v[0]]) return;
          if (o[v[1]]) return;
          o[v[1]] = o[v[0]];
          delete o[v[0]];
        });
        // 
        camel.forEach((v) => {
          if (!o[v]) return;
          const afterKey = v.replace(/^(.)/, ($0) => $0.toLowerCase()).replace(/-(\w)/g, (_, $1) => $1.toUpperCase());
          if (o[afterKey]) return;
          o[afterKey] = o[v];
          // todo 
          // delete o[v];
        });
        // 
        bool.forEach((v) => {
          o[v] = fixBool(o[v]);
        });
        // finalKill
        if (typeof finalKill === "function") {
          finalKill(o);
        }
        // 
        fixLowerFirst(o, lowerFirst);
        return dataFix;
      }
      exports.dataFix = dataFix;
      function fixBool(value) {
        if (!value) return false;
        if (TRUE.includes(value)) return true;
        return FALSE.includes(value) ? false : value;
      }
      function fixLowerFirst(o, lowerFirst) {
        if (lowerFirst) {
          Object.keys(o).forEach((key) => {
            const lowerK = key.replace(/^\w/, (match) => match.toLowerCase());
            if (typeof o[lowerK] === "undefined") {
              o[lowerK] = o[key];
              delete o[key];
            }
          });
        }
      }

      /***/
    },

    /***/ 7150: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deepCopyWith = exports.deepCopy = void 0;
      const isBuffer_1 = __nccwpck_require__(5850);
      exports.deepCopy = (obj) => {
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        if (isBuffer_1.isBuffer(obj)) {
          return obj.slice();
        }
        const copy = Array.isArray(obj) ? [] : {};
        Object.keys(obj).forEach((key) => {
          copy[key] = exports.deepCopy(obj[key]);
        });
        return copy;
      };
      exports.deepCopyWith = (obj, customizer) => {
        function deepCopyWithHelper(value, innerKey, innerObject) {
          const result = customizer(value, innerKey, innerObject);
          if (result !== undefined) return result;
          if (value === null || typeof value !== "object") {
            return value;
          }
          if (isBuffer_1.isBuffer(value)) {
            return value.slice();
          }
          const copy = Array.isArray(value) ? [] : {};
          Object.keys(value).forEach((k) => {
            copy[k] = deepCopyWithHelper(value[k], k, value);
          });
          return copy;
        }
        if (customizer) {
          return deepCopyWithHelper(obj, "", null);
        } else {
          return exports.deepCopy(obj);
        }
      };

      /***/
    },

    /***/ 3240: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encoder = void 0;
      function encoder(str, encoding = "utf-8") {
        if (encoding === "utf-8") return str;
        return Buffer.from(str).toString("latin1");
      }
      exports.encoder = encoder;

      /***/
    },

    /***/ 5708: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatInventoryConfig = void 0;
      const dataFix_1 = __nccwpck_require__(1615);
      const isObject_1 = __nccwpck_require__(1269);
      const isArray_1 = __nccwpck_require__(1954);
      const formatObjKey_1 = __nccwpck_require__(2095);
      function formatInventoryConfig(inventoryConfig, toArray = false) {
        if (toArray && isObject_1.isObject(inventoryConfig)) inventoryConfig = [inventoryConfig];
        if (isArray_1.isArray(inventoryConfig)) {
          inventoryConfig = inventoryConfig.map(formatFn);
        } else {
          inventoryConfig = formatFn(inventoryConfig);
        }
        return inventoryConfig;
      }
      exports.formatInventoryConfig = formatInventoryConfig;
      function formatFn(_) {
        dataFix_1.dataFix(_, { bool: ["IsEnabled"] }, (conf) => {
          var _a, _b;
          // prefix
          conf.prefix = conf.Filter.Prefix;
          delete conf.Filter;
          // OSSBucketDestination
          conf.OSSBucketDestination = conf.Destination.OSSBucketDestination;
          // OSSBucketDestination.rolename
          conf.OSSBucketDestination.rolename = conf.OSSBucketDestination.RoleArn.replace(/.*\//, "");
          delete conf.OSSBucketDestination.RoleArn;
          // OSSBucketDestination.bucket
          conf.OSSBucketDestination.bucket = conf.OSSBucketDestination.Bucket.replace(/.*:::/, "");
          delete conf.OSSBucketDestination.Bucket;
          delete conf.Destination;
          // frequency
          conf.frequency = conf.Schedule.Frequency;
          delete conf.Schedule.Frequency;
          // optionalFields
          if (
            ((_a = conf === null || conf === void 0 ? void 0 : conf.OptionalFields) === null || _a === void 0
              ? void 0
              : _a.Field) &&
            !isArray_1.isArray((_b = conf.OptionalFields) === null || _b === void 0 ? void 0 : _b.Field)
          )
            conf.OptionalFields.Field = [conf.OptionalFields.Field];
        });
        // firstLowerCase
        _ = formatObjKey_1.formatObjKey(_, "firstLowerCase", {
          exclude: ["OSSBucketDestination", "SSE-OSS", "SSE-KMS"]
        });
        return _;
      }

      /***/
    },

    /***/ 2095: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatObjKey = void 0;
      function formatObjKey(obj, type, options) {
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        let o;
        if (Array.isArray(obj)) {
          o = [];
          for (let i = 0; i < obj.length; i++) {
            o.push(formatObjKey(obj[i], type, options));
          }
        } else {
          o = {};
          Object.keys(obj).forEach((key) => {
            o[handelFormat(key, type, options)] = formatObjKey(obj[key], type, options);
          });
        }
        return o;
      }
      exports.formatObjKey = formatObjKey;
      function handelFormat(key, type, options) {
        if (options && options.exclude && options.exclude.includes(key)) return key;
        if (type === "firstUpperCase") {
          key = key.replace(/^./, (_) => _.toUpperCase());
        } else if (type === "firstLowerCase") {
          key = key.replace(/^./, (_) => _.toLowerCase());
        }
        return key;
      }

      /***/
    },

    /***/ 7115: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.formatTag = void 0;
      const isObject_1 = __nccwpck_require__(1269);
      function formatTag(obj) {
        if (obj.Tagging !== undefined) {
          obj = obj.Tagging.TagSet.Tag;
        } else if (obj.TagSet !== undefined) {
          obj = obj.TagSet.Tag;
        } else if (obj.Tag !== undefined) {
          obj = obj.Tag;
        }
        obj = obj && isObject_1.isObject(obj) ? [obj] : obj || [];
        const tag = {};
        obj.forEach((item) => {
          tag[item.Key] = item.Value;
        });
        return tag;
      }
      exports.formatTag = formatTag;

      /***/
    },

    /***/ 365: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getStrBytesCount = void 0;
      function getStrBytesCount(str) {
        let bytesCount = 0;
        for (let i = 0; i < str.length; i++) {
          const c = str.charAt(i);
          if (/^[\u00-\uff]$/.test(c)) {
            bytesCount += 1;
          } else {
            bytesCount += 2;
          }
        }
        return bytesCount;
      }
      exports.getStrBytesCount = getStrBytesCount;

      /***/
    },

    /***/ 1954: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isArray = void 0;
      exports.isArray = (obj) => {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };

      /***/
    },

    /***/ 5850: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBuffer = void 0;
      function isBuffer(obj) {
        return Buffer.isBuffer(obj);
      }
      exports.isBuffer = isBuffer;

      /***/
    },

    /***/ 5605: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isDingTalk = void 0;
      function isDingTalk() {
        if (process.browser && window.navigator.userAgent.toLowerCase().includes("aliapp(dingtalk")) {
          return true;
        }
        return false;
      }
      exports.isDingTalk = isDingTalk;

      /***/
    },

    /***/ 7169: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFile = void 0;
      exports.isFile = (obj) => {
        return typeof File !== "undefined" && obj instanceof File;
      };

      /***/
    },

    /***/ 8818: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFunction = void 0;
      exports.isFunction = (v) => {
        return typeof v === "function";
      };

      /***/
    },

    /***/ 2439: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isIP = void 0;
      // it provide commont methods for node and browser , we will add more solutions later in this file
      /**
       * Judge isIP include ipv4 or ipv6
       * @param {String} options
       * @return {Array} the multipart uploads
       */
      exports.isIP = (host) => {
        const ipv4Regex = /^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$/;
        const ipv6Regex =
          /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        return ipv4Regex.test(host) || ipv6Regex.test(host);
      };

      /***/
    },

    /***/ 1269: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isObject = void 0;
      exports.isObject = (obj) => {
        return Object.prototype.toString.call(obj) === "[object Object]";
      };

      /***/
    },

    /***/ 5285: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lowercaseKeyHeader = void 0;
      const isObject_1 = __nccwpck_require__(1269);
      function lowercaseKeyHeader(headers) {
        const lowercaseHeader = {};
        if (isObject_1.isObject(headers)) {
          Object.keys(headers).forEach((key) => {
            lowercaseHeader[key.toLowerCase()] = headers[key];
          });
        }
        return lowercaseHeader;
      }
      exports.lowercaseKeyHeader = lowercaseKeyHeader;

      /***/
    },

    /***/ 6846: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.obj2xml = void 0;
      const formatObjKey_1 = __nccwpck_require__(2095);
      function type(params) {
        return Object.prototype.toString
          .call(params)
          .replace(/(.*? |])/g, "")
          .toLowerCase();
      }
      function obj2xml(obj, options) {
        let s = "";
        if (options && options.headers) {
          s = '<?xml version="1.0" encoding="UTF-8"?>\n';
        }
        if (options && options.firstUpperCase) {
          obj = formatObjKey_1.formatObjKey(obj, "firstUpperCase");
        }
        if (type(obj) === "object") {
          Object.keys(obj).forEach((key) => {
            // filter undefined or null
            if (type(obj[key]) !== "undefined" && type(obj[key]) !== "null") {
              if (type(obj[key]) === "string" || type(obj[key]) === "number") {
                s += `<${key}>${obj[key]}</${key}>`;
              } else if (type(obj[key]) === "object") {
                s += `<${key}>${obj2xml(obj[key])}</${key}>`;
              } else if (type(obj[key]) === "array") {
                s += obj[key].map((keyChild) => `<${key}>${obj2xml(keyChild)}</${key}>`).join("");
              } else {
                s += `<${key}>${obj[key].toString()}</${key}>`;
              }
            }
          });
        } else {
          s += obj.toString();
        }
        return s;
      }
      exports.obj2xml = obj2xml;

      /***/
    },

    /***/ 2577: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.omit = void 0;
      function omit(originalObject, keysToOmit) {
        const cloneObject = Object.assign({}, originalObject);
        for (const path of keysToOmit) {
          delete cloneObject[path];
        }
        return cloneObject;
      }
      exports.omit = omit;

      /***/
    },

    /***/ 61: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.policy2Str = void 0;
      function policy2Str(policy) {
        let policyStr;
        if (policy) {
          if (typeof policy === "string") {
            try {
              policyStr = JSON.stringify(JSON.parse(policy));
            } catch (err) {
              throw new Error(`Policy string is not a valid JSON: ${err.message}`);
            }
          } else {
            policyStr = JSON.stringify(policy);
          }
        }
        return policyStr;
      }
      exports.policy2Str = policy2Str;

      /***/
    },

    /***/ 8263: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.retry = void 0;
      function retry(func, retryMax, config = {}) {
        let retryNum = 0;
        const { retryDelay = 500, errorHandler = () => true } = config;
        const funcR = (...arg) => {
          return new Promise((resolve, reject) => {
            func(...arg)
              .then((result) => {
                retryNum = 0;
                resolve(result);
              })
              .catch((err) => {
                if (retryNum < retryMax && errorHandler(err)) {
                  retryNum++;
                  setTimeout(() => {
                    resolve(funcR(...arg));
                  }, retryDelay);
                } else {
                  retryNum = 0;
                  reject(err);
                }
              });
          });
        };
        return funcR;
      }
      exports.retry = retry;

      /***/
    },

    /***/ 6690: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";

      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.setRegion = void 0;
      const url_1 = __importDefault(__nccwpck_require__(7310));
      const checkConfigValid_1 = __nccwpck_require__(7324);
      function setRegion(region, internal = false, secure = false) {
        checkConfigValid_1.checkConfigValid(region, "region");
        const protocol = secure ? "https://" : "http://";
        let suffix = internal ? "-internal.aliyuncs.com" : ".aliyuncs.com";
        const prefix = "vpc100-oss-cn-";
        // aliyun VPC region: https://help.aliyun.com/knowledge_detail/38740.html
        if (region.substr(0, prefix.length) === prefix) {
          suffix = ".aliyuncs.com";
        }
        return url_1.default.parse(protocol + region + suffix);
      }
      exports.setRegion = setRegion;

      /***/
    },

    /***/ 4622: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkCredentials = exports.setSTSToken = void 0;
      const formatObjKey_1 = __nccwpck_require__(2095);
      async function setSTSToken() {
        if (!this.options) this.options = {};
        const now = new Date();
        if (this.stsTokenFreshTime) {
          if (+now - this.stsTokenFreshTime >= this.options.refreshSTSTokenInterval) {
            this.stsTokenFreshTime = now;
            let credentials = await this.options.refreshSTSToken();
            credentials = formatObjKey_1.formatObjKey(credentials, "firstLowerCase");
            if (credentials.securityToken) {
              credentials.stsToken = credentials.securityToken;
            }
            checkCredentials(credentials);
            Object.assign(this.options, credentials);
          }
        } else {
          this.stsTokenFreshTime = now;
        }
        return null;
      }
      exports.setSTSToken = setSTSToken;
      function checkCredentials(obj) {
        const stsTokenKey = ["accessKeySecret", "accessKeyId", "stsToken"];
        const objKeys = Object.keys(obj);
        stsTokenKey.forEach((_) => {
          if (!objKeys.find((key) => key === _)) {
            throw Error(`refreshSTSToken must return contains ${_}`);
          }
        });
      }
      exports.checkCredentials = checkCredentials;

      /***/
    },

    /***/ 628: /***/ (module) => {
      /* istanbul ignore next */
      module.exports = function (OssClient) {
        /* istanbul ignore next */
        //   function objectRequestParams(method, name, options) {
        //     options = options || {};
        //     name = this._objectName(name);
        //     const authResource = `/${this.options.bucket}/${name}`;
        //     const params = {
        //       name,
        //       method,
        //       host: this.options.imageHost,
        //       resource: `/${name}`,
        //       timeout: options.timeout,
        //       authResource,
        //       ctx: options.ctx
        //     };
        //     if (options.headers) {
        //       params.headers = options.headers;
        //     }
        //     return params;
        //   }

        function ImageClient(options) {
          if (!(this instanceof ImageClient)) {
            return new ImageClient(options);
          }
          if (!options.bucket) {
            throw new Error("require bucket for image service instance");
          }
          if (!options.imageHost) {
            throw new Error("require imageHost for image service instance");
          }

          options.endpoint = options.imageHost;
          this.ossClient = new OssClient(options);
          this.ossClient.options.imageHost = options.imageHost;
          // this.ossClient._objectRequestParams = objectRequestParams;
        }

        /**
         * Image operations
         */

        ImageClient.prototype.get = async function get(name, file, options) {
          return await this.ossClient.get(name, file, options);
        };

        ImageClient.prototype.getStream = async function getStream(name, options) {
          return await this.ossClient.getStream(name, options);
        };

        ImageClient.prototype.getExif = async function getExif(name, options) {
          const params = this.ossClient._objectRequestParams("GET", `${name}@exif`, options);
          params.successStatuses = [200];

          let result = await this.ossClient.request(params);
          result = await this._parseResponse(result);
          return {
            res: result.res,
            data: result.data
          };
        };

        ImageClient.prototype.getInfo = async function getInfo(name, options) {
          const params = this.ossClient._objectRequestParams("GET", `${name}@infoexif`, options);
          params.successStatuses = [200];

          let result = await this.ossClient.request(params);
          result = await this._parseResponse(result);
          return {
            res: result.res,
            data: result.data
          };
        };

        ImageClient.prototype.putStyle = async function putStyle(styleName, style, options) {
          const params = this.ossClient._objectRequestParams("PUT", `/?style&styleName=${styleName}`, options);
          params.successStatuses = [200];
          params.content = `${'<?xml version="1.0" encoding="UTF-8"?>\n<Style><Content>'}${style}</Content></Style>`;

          let result = await this.ossClient.request(params);
          result = await this._parseResponse(result);
          return {
            res: result.res,
            data: result.data
          };
        };

        ImageClient.prototype.getStyle = async function getStyle(styleName, options) {
          const params = this.ossClient._objectRequestParams("GET", `/?style&styleName=${styleName}`, options);
          params.successStatuses = [200];

          let result = await this.ossClient.request(params);
          result = await this._parseResponse(result);
          return {
            res: result.res,
            data: result.data
          };
        };

        ImageClient.prototype.listStyle = async function listStyle(options) {
          const params = this.ossClient._objectRequestParams("GET", "/?style", options);
          params.successStatuses = [200];

          let result = await this.ossClient.request(params);
          result = await this._parseResponse(result);
          return {
            res: result.res,
            data: result.data.Style
          };
        };

        ImageClient.prototype.deleteStyle = async function deleteStyle(styleName, options) {
          const params = this.ossClient._objectRequestParams("DELETE", `/?style&styleName=${styleName}`, options);
          params.successStatuses = [204];

          const result = await this.ossClient.request(params);
          return {
            res: result.res
          };
        };

        ImageClient.prototype.signatureUrl = function signatureUrl(name) {
          return this.ossClient.signatureUrl(name);
        };

        ImageClient.prototype._parseResponse = async function _parseResponse(result) {
          const str = result.data.toString();
          const type = result.res.headers["content-type"];

          if (type === "application/json") {
            const data = JSON.parse(str);
            result.data = {};
            if (data) {
              Object.keys(data).forEach((key) => {
                result.data[key] = parseFloat(data[key].value, 10) || data[key].value;
              });
            }
          } else if (type === "application/xml") {
            result.data = await this.ossClient.parseXML(str);
          }
          return result;
        };

        return ImageClient;
      };

      /***/
    },

    /***/ 107: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const fs = __nccwpck_require__(7147);
      const is = __nccwpck_require__(5565);
      const util = __nccwpck_require__(3837);
      const path = __nccwpck_require__(1017);
      const mime = __nccwpck_require__(9994);
      const { isFile } = __nccwpck_require__(7169);
      const { isArray } = __nccwpck_require__(1954);
      const { isBuffer } = __nccwpck_require__(5850);
      const { retry } = __nccwpck_require__(8263);

      const proto = exports;

      /**
       * Multipart operations
       */

      /**
       * Upload a file to OSS using multipart uploads
       * @param {String} name
       * @param {String|File|Buffer} file
       * @param {Object} options
       *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
       *        {String} options.callback.url the OSS sends a callback request to this URL
       *        {String} options.callback.host The host header value for initiating callback requests
       *        {String} options.callback.body The value of the request body when a callback is initiated
       *        {String} options.callback.contentType The Content-Type of the callback requests initiatiated
       *        {Object} options.callback.customValue Custom parameters are a map of key-values, e.g:
       *                  customValue = {
       *                    key1: 'value1',
       *                    key2: 'value2'
       *                  }
       */
      proto.multipartUpload = async function multipartUpload(name, file, options) {
        this.resetCancelFlag();
        options = options || {};
        if (options.checkpoint && options.checkpoint.uploadId) {
          return await this._resumeMultipart(options.checkpoint, options);
        }

        const minPartSize = 100 * 1024;
        if (!options.mime) {
          if (isFile(file)) {
            options.mime = mime.getType(path.extname(file.name));
          } else if (isBuffer(file)) {
            options.mime = "";
          } else {
            options.mime = mime.getType(path.extname(file));
          }
        }
        options.headers = options.headers || {};
        this._convertMetaToHeaders(options.meta, options.headers);

        const fileSize = await this._getFileSize(file);
        if (fileSize < minPartSize) {
          options.contentLength = fileSize;
          const result = await this.put(name, file, options);
          if (options && options.progress) {
            await options.progress(1);
          }

          const ret = {
            res: result.res,
            bucket: this.options.bucket,
            name,
            etag: result.res.headers.etag
          };

          if ((options.headers && options.headers["x-oss-callback"]) || options.callback) {
            ret.data = result.data;
          }

          return ret;
        }

        if (options.partSize && !(parseInt(options.partSize, 10) === options.partSize)) {
          throw new Error("partSize must be int number");
        }

        if (options.partSize && options.partSize < minPartSize) {
          throw new Error(`partSize must not be smaller than ${minPartSize}`);
        }

        const initResult = await this.initMultipartUpload(name, options);
        const { uploadId } = initResult;
        const partSize = this._getPartSize(fileSize, options.partSize);

        const checkpoint = {
          file,
          name,
          fileSize,
          partSize,
          uploadId,
          doneParts: []
        };

        if (options && options.progress) {
          await options.progress(0, checkpoint, initResult.res);
        }

        return await this._resumeMultipart(checkpoint, options);
      };

      /*
       * Resume multipart upload from checkpoint. The checkpoint will be
       * updated after each successful part upload.
       * @param {Object} checkpoint the checkpoint
       * @param {Object} options
       */
      proto._resumeMultipart = async function _resumeMultipart(checkpoint, options) {
        const that = this;
        if (this.isCancel()) {
          throw this._makeCancelEvent();
        }
        const { file, fileSize, partSize, uploadId, doneParts, name } = checkpoint;

        const partOffs = this._divideParts(fileSize, partSize);
        const numParts = partOffs.length;
        let uploadPartJob = retry(
          (self, partNo) => {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise(async (resolve, reject) => {
              try {
                if (!self.isCancel()) {
                  const pi = partOffs[partNo - 1];
                  const stream = await self._createStream(file, pi.start, pi.end);
                  const data = {
                    stream,
                    size: pi.end - pi.start
                  };

                  if (isArray(self.multipartUploadStreams)) {
                    self.multipartUploadStreams.push(data.stream);
                  } else {
                    self.multipartUploadStreams = [data.stream];
                  }

                  const removeStreamFromMultipartUploadStreams = function () {
                    if (!stream.destroyed) {
                      stream.destroy();
                    }
                    const index = self.multipartUploadStreams.indexOf(stream);
                    if (index !== -1) {
                      self.multipartUploadStreams.splice(index, 1);
                    }
                  };

                  stream.on("close", removeStreamFromMultipartUploadStreams);
                  stream.on("error", removeStreamFromMultipartUploadStreams);

                  let result;
                  try {
                    result = await self._uploadPart(name, uploadId, partNo, data, options);
                  } catch (error) {
                    removeStreamFromMultipartUploadStreams();
                    if (error.status === 404) {
                      throw self._makeAbortEvent();
                    }
                    throw error;
                  }
                  if (!self.isCancel()) {
                    doneParts.push({
                      number: partNo,
                      etag: result.res.headers.etag
                    });
                    checkpoint.doneParts = doneParts;

                    if (options.progress) {
                      await options.progress(doneParts.length / (numParts + 1), checkpoint, result.res);
                    }
                  }
                }
                resolve();
              } catch (err) {
                err.partNum = partNo;
                reject(err);
              }
            });
          },
          this.options.retryMax,
          {
            errorHandler: (err) => {
              const _errHandle = (_err) => {
                const statusErr = [-1, -2].includes(_err.status);
                const requestErrorRetryHandle = this.options.requestErrorRetryHandle || (() => true);
                return statusErr && requestErrorRetryHandle(_err);
              };
              return !!_errHandle(err);
            }
          }
        );

        const all = Array.from(new Array(numParts), (x, i) => i + 1);
        const done = doneParts.map((p) => p.number);
        const todo = all.filter((p) => done.indexOf(p) < 0);

        const defaultParallel = 5;
        const parallel = options.parallel || defaultParallel;

        if (this.checkBrowserAndVersion("Internet Explorer", "10") || parallel === 1) {
          for (let i = 0; i < todo.length; i++) {
            if (this.isCancel()) {
              throw this._makeCancelEvent();
            }
            /* eslint no-await-in-loop: [0] */
            await uploadPartJob(this, todo[i]);
          }
        } else {
          // upload in parallel
          const jobErr = await this._parallel(todo, parallel, (value) => {
            return new Promise((resolve, reject) => {
              uploadPartJob(that, value)
                .then(() => {
                  resolve();
                })
                .catch(reject);
            });
          });

          const abortEvent = jobErr.find((err) => err.name === "abort");
          if (abortEvent) throw abortEvent;

          if (this.isCancel()) {
            uploadPartJob = null;
            throw this._makeCancelEvent();
          }

          if (jobErr && jobErr.length > 0) {
            jobErr[0].message = `Failed to upload some parts with error: ${jobErr[0].toString()} part_num: ${
              jobErr[0].partNum
            }`;
            throw jobErr[0];
          }
        }

        return await this.completeMultipartUpload(name, uploadId, doneParts, options);
      };

      /**
       * Get file size
       */
      proto._getFileSize = async function _getFileSize(file) {
        if (isBuffer(file)) {
          return file.length;
        } else if (isFile(file)) {
          return file.size;
        } else if (is.string(file)) {
          const stat = await this._statFile(file);
          return stat.size;
        }

        throw new Error("_getFileSize requires Buffer/File/String.");
      };

      /*
       * Readable stream for Web File
       */
      const { Readable } = __nccwpck_require__(2781);

      function WebFileReadStream(file, options) {
        if (!(this instanceof WebFileReadStream)) {
          return new WebFileReadStream(file, options);
        }

        Readable.call(this, options);

        this.file = file;
        this.reader = new FileReader();
        this.start = 0;
        this.finish = false;
        this.fileBuffer = null;
      }
      util.inherits(WebFileReadStream, Readable);

      WebFileReadStream.prototype.readFileAndPush = function readFileAndPush(size) {
        if (this.fileBuffer) {
          let pushRet = true;
          while (pushRet && this.fileBuffer && this.start < this.fileBuffer.length) {
            const { start } = this;
            let end = start + size;
            end = end > this.fileBuffer.length ? this.fileBuffer.length : end;
            this.start = end;
            pushRet = this.push(this.fileBuffer.slice(start, end));
          }
        }
      };

      WebFileReadStream.prototype._read = function _read(size) {
        if (
          (this.file && this.start >= this.file.size) ||
          (this.fileBuffer && this.start >= this.fileBuffer.length) ||
          this.finish ||
          (this.start === 0 && !this.file)
        ) {
          if (!this.finish) {
            this.fileBuffer = null;
            this.finish = true;
          }
          this.push(null);
          return;
        }

        const defaultReadSize = 16 * 1024;
        size = size || defaultReadSize;

        const that = this;
        this.reader.onload = function (e) {
          that.fileBuffer = Buffer.from(new Uint8Array(e.target.result));
          that.file = null;
          that.readFileAndPush(size);
        };
        this.reader.onerror = function onload(e) {
          const error = e.srcElement && e.srcElement.error;
          if (error) {
            throw error;
          }
          throw e;
        };

        if (this.start === 0) {
          this.reader.readAsArrayBuffer(this.file);
        } else {
          this.readFileAndPush(size);
        }
      };

      proto._createStream = function _createStream(file, start, end) {
        if (is.readableStream(file)) {
          return file;
        } else if (isFile(file)) {
          return new WebFileReadStream(file.slice(start, end));
        } else if (isBuffer(file)) {
          const iterable = file.subarray(start, end);
          // we can't use Readable.from() since it is only support in Node v10
          return new Readable({
            read() {
              this.push(iterable);
              this.push(null);
            }
          });
        } else if (is.string(file)) {
          return fs.createReadStream(file, {
            start,
            end: end - 1
          });
        }
        throw new Error("_createStream requires Buffer/File/String.");
      };

      proto._getPartSize = function _getPartSize(fileSize, partSize) {
        const maxNumParts = 10 * 1000;
        const defaultPartSize = 1 * 1024 * 1024;

        if (!partSize) partSize = defaultPartSize;
        const safeSize = Math.ceil(fileSize / maxNumParts);

        if (partSize < safeSize) {
          partSize = safeSize;
          console.warn(
            `partSize has been set to ${partSize}, because the partSize you provided causes partNumber to be greater than 10,000`
          );
        }
        return partSize;
      };

      proto._divideParts = function _divideParts(fileSize, partSize) {
        const numParts = Math.ceil(fileSize / partSize);

        const partOffs = [];
        for (let i = 0; i < numParts; i++) {
          const start = partSize * i;
          const end = Math.min(start + partSize, fileSize);

          partOffs.push({
            start,
            end
          });
        }

        return partOffs;
      };

      /***/
    },

    /***/ 2557: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      const debug = __nccwpck_require__(8237)("ali-oss:object");
      const fs = __nccwpck_require__(7147);
      const is = __nccwpck_require__(5565);
      const copy = __nccwpck_require__(952);
      const path = __nccwpck_require__(1017);
      const mime = __nccwpck_require__(9994);
      const callback = __nccwpck_require__(6725);
      const { Transform } = __nccwpck_require__(2781);
      const pump = __nccwpck_require__(8341);
      const { isBuffer } = __nccwpck_require__(5850);
      const { retry } = __nccwpck_require__(8263);
      const { obj2xml } = __nccwpck_require__(6846);

      const proto = exports;

      /**
       * Object operations
       */

      /**
       * append an object from String(file path)/Buffer/ReadableStream
       * @param {String} name the object key
       * @param {Mixed} file String(file path)/Buffer/ReadableStream
       * @param {Object} options
       * @return {Object}
       */
      proto.append = async function append(name, file, options) {
        options = options || {};
        if (options.position === undefined) options.position = "0";
        options.subres = {
          append: "",
          position: options.position
        };
        options.method = "POST";

        const result = await this.put(name, file, options);
        result.nextAppendPosition = result.res.headers["x-oss-next-append-position"];
        return result;
      };

      /**
       * put an object from String(file path)/Buffer/ReadableStream
       * @param {String} name the object key
       * @param {Mixed} file String(file path)/Buffer/ReadableStream
       * @param {Object} options
       *        {Object} options.callback The callback parameter is composed of a JSON string encoded in Base64
       *        {String} options.callback.url  the OSS sends a callback request to this URL
       *        {String} options.callback.host  The host header value for initiating callback requests
       *        {String} options.callback.body  The value of the request body when a callback is initiated
       *        {String} options.callback.contentType  The Content-Type of the callback requests initiatiated
       *        {Object} options.callback.customValue  Custom parameters are a map of key-values, e.g:
       *                  customValue = {
       *                    key1: 'value1',
       *                    key2: 'value2'
       *                  }
       * @return {Object}
       */
      proto.put = async function put(name, file, options) {
        let content;
        options = options || {};
        name = this._objectName(name);

        if (isBuffer(file)) {
          content = file;
        } else if (is.string(file)) {
          const stats = fs.statSync(file);
          if (!stats.isFile()) {
            throw new Error(`${file} is not file`);
          }
          options.mime = options.mime || mime.getType(path.extname(file));
          options.contentLength = await this._getFileSize(file);
          const getStream = () => fs.createReadStream(file);
          const putStreamStb = (objectName, makeStream, configOption) => {
            return this.putStream(objectName, makeStream(), configOption);
          };
          return await retry(putStreamStb, this.options.retryMax, {
            errorHandler: (err) => {
              const _errHandle = (_err) => {
                const statusErr = [-1, -2].includes(_err.status);
                const requestErrorRetryHandle = this.options.requestErrorRetryHandle || (() => true);
                return statusErr && requestErrorRetryHandle(_err);
              };
              if (_errHandle(err)) return true;
              return false;
            }
          })(name, getStream, options);
        } else if (is.readableStream(file)) {
          return await this.putStream(name, file, options);
        } else {
          throw new TypeError("Must provide String/Buffer/ReadableStream for put.");
        }

        options.headers = options.headers || {};
        this._convertMetaToHeaders(options.meta, options.headers);

        const method = options.method || "PUT";
        const params = this._objectRequestParams(method, name, options);

        callback.encodeCallback(params, options);

        params.mime = options.mime;
        params.content = content;
        params.successStatuses = [200];

        const result = await this.request(params);

        const ret = {
          name,
          url: this._objectUrl(name),
          res: result.res
        };

        if (params.headers && params.headers["x-oss-callback"]) {
          ret.data = JSON.parse(result.data.toString());
        }

        return ret;
      };

      /**
       * put an object from ReadableStream. If `options.contentLength` is
       * not provided, chunked encoding is used.
       * @param {String} name the object key
       * @param {Readable} stream the ReadableStream
       * @param {Object} options
       * @return {Object}
       */
      proto.putStream = async function putStream(name, stream, options) {
        options = options || {};
        options.headers = options.headers || {};
        name = this._objectName(name);
        if (options.contentLength) {
          options.headers["Content-Length"] = options.contentLength;
        } else {
          options.headers["Transfer-Encoding"] = "chunked";
        }
        this._convertMetaToHeaders(options.meta, options.headers);

        const method = options.method || "PUT";
        const params = this._objectRequestParams(method, name, options);
        callback.encodeCallback(params, options);
        params.mime = options.mime;
        const transform = new Transform();
        // must remove http stream header for signature
        transform._transform = function _transform(chunk, encoding, done) {
          this.push(chunk);
          done();
        };
        params.stream = pump(stream, transform);
        params.successStatuses = [200];

        const result = await this.request(params);

        const ret = {
          name,
          url: this._objectUrl(name),
          res: result.res
        };

        if (params.headers && params.headers["x-oss-callback"]) {
          ret.data = JSON.parse(result.data.toString());
        }

        return ret;
      };

      proto.getStream = async function getStream(name, options) {
        options = options || {};

        if (options.process) {
          options.subres = options.subres || {};
          options.subres["x-oss-process"] = options.process;
        }

        const params = this._objectRequestParams("GET", name, options);
        params.customResponse = true;
        params.successStatuses = [200, 206, 304];

        const result = await this.request(params);

        return {
          stream: result.res,
          res: {
            status: result.status,
            headers: result.headers
          }
        };
      };

      proto.putMeta = async function putMeta(name, meta, options) {
        return await this.copy(name, name, {
          meta: meta || {},
          timeout: options && options.timeout,
          ctx: options && options.ctx
        });
      };

      proto.list = async function list(query, options) {
        // prefix, marker, max-keys, delimiter

        const params = this._objectRequestParams("GET", "", options);
        params.query = query;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);
        let objects = result.data.Contents || [];
        const that = this;
        if (objects) {
          if (!Array.isArray(objects)) {
            objects = [objects];
          }
          objects = objects.map((obj) => ({
            name: obj.Key,
            url: that._objectUrl(obj.Key),
            lastModified: obj.LastModified,
            etag: obj.ETag,
            type: obj.Type,
            size: Number(obj.Size),
            storageClass: obj.StorageClass,
            owner: {
              id: obj.Owner.ID,
              displayName: obj.Owner.DisplayName
            }
          }));
        }
        let prefixes = result.data.CommonPrefixes || null;
        if (prefixes) {
          if (!Array.isArray(prefixes)) {
            prefixes = [prefixes];
          }
          prefixes = prefixes.map((item) => item.Prefix);
        }
        return {
          res: result.res,
          objects,
          prefixes,
          nextMarker: result.data.NextMarker || null,
          isTruncated: result.data.IsTruncated === "true"
        };
      };

      proto.listV2 = async function listV2(query = {}, options = {}) {
        const continuation_token = query["continuation-token"] || query.continuationToken;
        delete query["continuation-token"];
        delete query.continuationToken;
        if (continuation_token) {
          options.subres = Object.assign(
            {
              "continuation-token": continuation_token
            },
            options.subres
          );
        }
        const params = this._objectRequestParams("GET", "", options);
        params.query = Object.assign({ "list-type": 2 }, query);
        delete params.query["continuation-token"];
        delete query.continuationToken;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);
        let objects = result.data.Contents || [];
        const that = this;
        if (objects) {
          if (!Array.isArray(objects)) {
            objects = [objects];
          }

          objects = objects.map((obj) => {
            let owner = null;
            if (obj.Owner) {
              owner = {
                id: obj.Owner.ID,
                displayName: obj.Owner.DisplayName
              };
            }
            return {
              name: obj.Key,
              url: that._objectUrl(obj.Key),
              lastModified: obj.LastModified,
              etag: obj.ETag,
              type: obj.Type,
              size: Number(obj.Size),
              storageClass: obj.StorageClass,
              owner
            };
          });
        }
        let prefixes = result.data.CommonPrefixes || null;
        if (prefixes) {
          if (!Array.isArray(prefixes)) {
            prefixes = [prefixes];
          }
          prefixes = prefixes.map((item) => item.Prefix);
        }
        return {
          res: result.res,
          objects,
          prefixes,
          isTruncated: result.data.IsTruncated === "true",
          keyCount: +result.data.KeyCount,
          continuationToken: result.data.ContinuationToken || null,
          nextContinuationToken: result.data.NextContinuationToken || null
        };
      };

      /**
       * Restore Object
       * @param {String} name the object key
       * @param {Object} options {type : Archive or ColdArchive}
       * @returns {{res}}
       */
      proto.restore = async function restore(name, options = { type: "Archive" }) {
        options = options || {};
        options.subres = Object.assign({ restore: "" }, options.subres);
        if (options.versionId) {
          options.subres.versionId = options.versionId;
        }
        const params = this._objectRequestParams("POST", name, options);
        if (options.type === "ColdArchive") {
          const paramsXMLObj = {
            RestoreRequest: {
              Days: options.Days ? options.Days : 2,
              JobParameters: {
                Tier: options.JobParameters ? options.JobParameters : "Standard"
              }
            }
          };
          params.content = obj2xml(paramsXMLObj, {
            headers: true
          });
          params.mime = "xml";
        }
        params.successStatuses = [202];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      proto._objectUrl = function _objectUrl(name) {
        return this._getReqUrl({ bucket: this.options.bucket, object: name });
      };

      /**
       * generator request params
       * @return {Object} params
       *
       * @api private
       */

      proto._objectRequestParams = function (method, name, options) {
        if (!this.options.bucket && !this.options.cname) {
          throw new Error("Please create a bucket first");
        }

        options = options || {};
        name = this._objectName(name);
        const params = {
          object: name,
          bucket: this.options.bucket,
          method,
          subres: options && options.subres,
          timeout: options && options.timeout,
          ctx: options && options.ctx
        };

        if (options.headers) {
          params.headers = {};
          copy(options.headers).to(params.headers);
        }
        return params;
      };

      proto._objectName = function (name) {
        return name.replace(/^\/+/, "");
      };

      proto._statFile = function (filepath) {
        return new Promise((resolve, reject) => {
          fs.stat(filepath, (err, stats) => {
            if (err) {
              reject(err);
            } else {
              resolve(stats);
            }
          });
        });
      };

      proto._convertMetaToHeaders = function (meta, headers) {
        if (!meta) {
          return;
        }

        Object.keys(meta).forEach((k) => {
          headers[`x-oss-meta-${k}`] = meta[k];
        });
      };

      proto._deleteFileSafe = function (filepath) {
        return new Promise((resolve) => {
          fs.exists(filepath, (exists) => {
            if (!exists) {
              resolve();
            } else {
              fs.unlink(filepath, (err) => {
                if (err) {
                  debug("unlink %j error: %s", filepath, err);
                }
                resolve();
              });
            }
          });
        });
      };

      /***/
    },

    /***/ 9164: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      /**
       * Copyright(c) ali-sdk and other contributors.
       * MIT Licensed
       *
       * Authors:
       *   rockuw <rockuw@gmail.com> (http://rockuw.com)
       */

      /**
       * Module dependencies.
       */

      const jstoxml = __nccwpck_require__(3094);
      const utility = __nccwpck_require__(3877);
      const copy = __nccwpck_require__(952);
      const urlutil = __nccwpck_require__(7310);

      const proto = exports;

      /**
       * RTMP operations
       */

      /**
       * Create a live channel
       * @param {String} id the channel id
       * @param {Object} conf the channel configuration
       * @param {Object} options
       * @return {Object}
       */
      proto.putChannel = async function putChannel(id, conf, options) {
        options = options || {};
        options.subres = "live";

        const params = this._objectRequestParams("PUT", id, options);
        params.xmlResponse = true;
        params.content = jstoxml.toXML({
          LiveChannelConfiguration: conf
        });
        params.successStatuses = [200];

        const result = await this.request(params);

        let publishUrls = result.data.PublishUrls.Url;
        if (!Array.isArray(publishUrls)) {
          publishUrls = [publishUrls];
        }
        let playUrls = result.data.PlayUrls.Url;
        if (!Array.isArray(playUrls)) {
          playUrls = [playUrls];
        }

        return {
          publishUrls,
          playUrls,
          res: result.res
        };
      };

      /**
       * Get the channel info
       * @param {String} id the channel id
       * @param {Object} options
       * @return {Object}
       */
      proto.getChannel = async function getChannel(id, options) {
        options = options || {};
        options.subres = "live";

        const params = this._objectRequestParams("GET", id, options);
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          data: result.data,
          res: result.res
        };
      };

      /**
       * Delete the channel
       * @param {String} id the channel id
       * @param {Object} options
       * @return {Object}
       */
      proto.deleteChannel = async function deleteChannel(id, options) {
        options = options || {};
        options.subres = "live";

        const params = this._objectRequestParams("DELETE", id, options);
        params.successStatuses = [204];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      /**
       * Set the channel status
       * @param {String} id the channel id
       * @param {String} status the channel status
       * @param {Object} options
       * @return {Object}
       */
      proto.putChannelStatus = async function putChannelStatus(id, status, options) {
        options = options || {};
        options.subres = {
          live: null,
          status
        };

        const params = this._objectRequestParams("PUT", id, options);
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      /**
       * Get the channel status
       * @param {String} id the channel id
       * @param {Object} options
       * @return {Object}
       */
      proto.getChannelStatus = async function getChannelStatus(id, options) {
        options = options || {};
        options.subres = {
          live: null,
          comp: "stat"
        };

        const params = this._objectRequestParams("GET", id, options);
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          data: result.data,
          res: result.res
        };
      };

      /**
       * List the channels
       * @param {Object} query the query parameters
       *  filter options:
       *   - prefix {String}: the channel id prefix (returns channels with this prefix)
       *   - marker {String}: the channle id marker (returns channels after this id)
       *   - max-keys {Number}: max number of channels to return
       * @param {Object} options
       * @return {Object}
       */
      proto.listChannels = async function listChannels(query, options) {
        // prefix, marker, max-keys

        options = options || {};
        options.subres = "live";

        const params = this._objectRequestParams("GET", "", options);
        params.query = query;
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        let channels = result.data.LiveChannel || [];
        if (!Array.isArray(channels)) {
          channels = [channels];
        }

        channels = channels.map((x) => {
          x.PublishUrls = x.PublishUrls.Url;
          if (!Array.isArray(x.PublishUrls)) {
            x.PublishUrls = [x.PublishUrls];
          }
          x.PlayUrls = x.PlayUrls.Url;
          if (!Array.isArray(x.PlayUrls)) {
            x.PlayUrls = [x.PlayUrls];
          }

          return x;
        });

        return {
          channels,
          nextMarker: result.data.NextMarker || null,
          isTruncated: result.data.IsTruncated === "true",
          res: result.res
        };
      };

      /**
       * Get the channel history
       * @param {String} id the channel id
       * @param {Object} options
       * @return {Object}
       */
      proto.getChannelHistory = async function getChannelHistory(id, options) {
        options = options || {};
        options.subres = {
          live: null,
          comp: "history"
        };

        const params = this._objectRequestParams("GET", id, options);
        params.xmlResponse = true;
        params.successStatuses = [200];

        const result = await this.request(params);

        let records = result.data.LiveRecord || [];
        if (!Array.isArray(records)) {
          records = [records];
        }
        return {
          records,
          res: result.res
        };
      };

      /**
       * Create vod playlist
       * @param {String} id the channel id
       * @param {String} name the playlist name
       * @param {Object} time the begin and end time
       *  time:
       *   - startTime {Number}: the begin time in epoch seconds
       *   - endTime {Number}: the end time in epoch seconds
       * @param {Object} options
       * @return {Object}
       */
      proto.createVod = async function createVod(id, name, time, options) {
        options = options || {};
        options.subres = {
          vod: null
        };
        copy(time).to(options.subres);

        const params = this._objectRequestParams("POST", `${id}/${name}`, options);
        params.query = time;
        params.successStatuses = [200];

        const result = await this.request(params);

        return {
          res: result.res
        };
      };

      /**
       * Get RTMP Url
       * @param {String} channelId the channel id
       * @param {Object} options
       *  options:
       *   - expires {Number}: expire time in seconds
       *   - params {Object}: the parameters such as 'playlistName'
       * @return {String} the RTMP url
       */
      proto.getRtmpUrl = function (channelId, options) {
        options = options || {};
        const expires = utility.timestamp() + (options.expires || 1800);
        const res = {
          bucket: this.options.bucket,
          object: this._objectName(`live/${channelId}`)
        };
        const resource = `/${res.bucket}/${channelId}`;

        options.params = options.params || {};
        const query = Object.keys(options.params)
          .sort()
          .map((x) => `${x}:${options.params[x]}\n`)
          .join("");

        const stringToSign = `${expires}\n${query}${resource}`;
        const signature = this.signature(stringToSign);

        const url = urlutil.parse(this._getReqUrl(res));
        url.protocol = "rtmp:";
        url.query = {
          OSSAccessKeyId: this.options.accessKeyId,
          Expires: expires,
          Signature: signature
        };
        copy(options.params).to(url.query);

        return url.format();
      };

      /***/
    },

    /***/ 4418: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      const debug = __nccwpck_require__(8237)("ali-oss:sts");
      const crypto = __nccwpck_require__(6113);
      const querystring = __nccwpck_require__(3477);
      const copy = __nccwpck_require__(952);
      const AgentKeepalive = __nccwpck_require__(4623);
      const is = __nccwpck_require__(5565);
      const ms = __nccwpck_require__(845);
      const urllib = __nccwpck_require__(4783);

      const globalHttpAgent = new AgentKeepalive();

      function STS(options) {
        if (!(this instanceof STS)) {
          return new STS(options);
        }

        if (!options || !options.accessKeyId || !options.accessKeySecret) {
          throw new Error("require accessKeyId, accessKeySecret");
        }

        this.options = {
          endpoint: options.endpoint || "https://sts.aliyuncs.com",
          format: "JSON",
          apiVersion: "2015-04-01",
          sigMethod: "HMAC-SHA1",
          sigVersion: "1.0",
          timeout: "60s"
        };
        copy(options).to(this.options);

        // support custom agent and urllib client
        if (this.options.urllib) {
          this.urllib = this.options.urllib;
        } else {
          this.urllib = urllib;
          this.agent = this.options.agent || globalHttpAgent;
        }
      }

      module.exports = STS;

      const proto = STS.prototype;

      /**
       * STS opertaions
       */

      proto.assumeRole = async function assumeRole(role, policy, expiration, session, options) {
        const opts = this.options;
        const params = {
          Action: "AssumeRole",
          RoleArn: role,
          RoleSessionName: session || "app",
          DurationSeconds: expiration || 3600,

          Format: opts.format,
          Version: opts.apiVersion,
          AccessKeyId: opts.accessKeyId,
          SignatureMethod: opts.sigMethod,
          SignatureVersion: opts.sigVersion,
          SignatureNonce: Math.random(),
          Timestamp: new Date().toISOString()
        };

        if (policy) {
          let policyStr;
          if (is.string(policy)) {
            try {
              policyStr = JSON.stringify(JSON.parse(policy));
            } catch (err) {
              throw new Error(`Policy string is not a valid JSON: ${err.message}`);
            }
          } else {
            policyStr = JSON.stringify(policy);
          }
          params.Policy = policyStr;
        }

        const signature = this._getSignature("POST", params, opts.accessKeySecret);
        params.Signature = signature;

        const reqUrl = opts.endpoint;
        const reqParams = {
          agent: this.agent,
          timeout: ms((options && options.timeout) || opts.timeout),
          method: "POST",
          content: querystring.stringify(params),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          ctx: options && options.ctx
        };

        const result = await this.urllib.request(reqUrl, reqParams);
        debug("response %s %s, got %s, headers: %j", reqParams.method, reqUrl, result.status, result.headers);

        if (Math.floor(result.status / 100) !== 2) {
          const err = await this._requestError(result);
          err.params = reqParams;
          throw err;
        }
        result.data = JSON.parse(result.data);

        return {
          res: result.res,
          credentials: result.data.Credentials
        };
      };

      proto._requestError = async function _requestError(result) {
        const err = new Error();
        err.status = result.status;

        try {
          const resp = (await JSON.parse(result.data)) || {};
          err.code = resp.Code;
          err.message = `${resp.Code}: ${resp.Message}`;
          err.requestId = resp.RequestId;
        } catch (e) {
          err.message = `UnknownError: ${String(result.data)}`;
        }

        return err;
      };

      proto._getSignature = function _getSignature(method, params, key) {
        const that = this;
        const canoQuery = Object.keys(params)
          .sort()
          .map((k) => `${that._escape(k)}=${that._escape(params[k])}`)
          .join("&");

        const stringToSign = `${method.toUpperCase()}&${this._escape("/")}&${this._escape(canoQuery)}`;

        debug("string to sign: %s", stringToSign);

        let signature = crypto.createHmac("sha1", `${key}&`);
        signature = signature.update(stringToSign).digest("base64");

        debug("signature: %s", signature);

        return signature;
      };

      /**
       * Since `encodeURIComponent` doesn't encode '*', which causes
       * 'SignatureDoesNotMatch'. We need do it ourselves.
       */
      proto._escape = function _escape(str) {
        return encodeURIComponent(str)
          .replace(/!/g, "%21")
          .replace(/'/g, "%27")
          .replace(/\(/g, "%28")
          .replace(/\)/g, "%29")
          .replace(/\*/g, "%2A");
      };

      /***/
    },

    /***/ 5768: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(6196)().Promise;

      /***/
    },

    /***/ 4549: /***/ (module) => {
      "use strict";

      // global key for user preferred registration
      var REGISTRATION_KEY = "@@any-promise/REGISTRATION",
        // Prior registration (preferred or detected)
        registered = null;

      /**
       * Registers the given implementation.  An implementation must
       * be registered prior to any call to `require("any-promise")`,
       * typically on application load.
       *
       * If called with no arguments, will return registration in
       * following priority:
       *
       * For Node.js:
       *
       * 1. Previous registration
       * 2. global.Promise if node.js version >= 0.12
       * 3. Auto detected promise based on first sucessful require of
       *    known promise libraries. Note this is a last resort, as the
       *    loaded library is non-deterministic. node.js >= 0.12 will
       *    always use global.Promise over this priority list.
       * 4. Throws error.
       *
       * For Browser:
       *
       * 1. Previous registration
       * 2. window.Promise
       * 3. Throws error.
       *
       * Options:
       *
       * Promise: Desired Promise constructor
       * global: Boolean - Should the registration be cached in a global variable to
       * allow cross dependency/bundle registration?  (default true)
       */
      module.exports = function (root, loadImplementation) {
        return function register(implementation, opts) {
          implementation = implementation || null;
          opts = opts || {};
          // global registration unless explicitly  {global: false} in options (default true)
          var registerGlobal = opts.global !== false;

          // load any previous global registration
          if (registered === null && registerGlobal) {
            registered = root[REGISTRATION_KEY] || null;
          }

          if (registered !== null && implementation !== null && registered.implementation !== implementation) {
            // Throw error if attempting to redefine implementation
            throw new Error(
              'any-promise already defined as "' +
                registered.implementation +
                '".  You can only register an implementation before the first ' +
                ' call to require("any-promise") and an implementation cannot be changed'
            );
          }

          if (registered === null) {
            // use provided implementation
            if (implementation !== null && typeof opts.Promise !== "undefined") {
              registered = {
                Promise: opts.Promise,
                implementation: implementation
              };
            } else {
              // require implementation if implementation is specified but not provided
              registered = loadImplementation(implementation);
            }

            if (registerGlobal) {
              // register preference globally in case multiple installations
              root[REGISTRATION_KEY] = registered;
            }
          }

          return registered;
        };
      };

      /***/
    },

    /***/ 6196: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      module.exports = __nccwpck_require__(4549)(global, loadImplementation);

      /**
       * Node.js version of loadImplementation.
       *
       * Requires the given implementation and returns the registration
       * containing {Promise, implementation}
       *
       * If implementation is undefined or global.Promise, loads it
       * Otherwise uses require
       */
      function loadImplementation(implementation) {
        var impl = null;

        if (shouldPreferGlobalPromise(implementation)) {
          // if no implementation or env specified use global.Promise
          impl = {
            Promise: global.Promise,
            implementation: "global.Promise"
          };
        } else if (implementation) {
          // if implementation specified, require it
          var lib = require(implementation);
          impl = {
            Promise: lib.Promise || lib,
            implementation: implementation
          };
        } else {
          // try to auto detect implementation. This is non-deterministic
          // and should prefer other branches, but this is our last chance
          // to load something without throwing error
          impl = tryAutoDetect();
        }

        if (impl === null) {
          throw new Error(
            "Cannot find any-promise implementation nor" +
              " global.Promise. You must install polyfill or call" +
              ' require("any-promise/register") with your preferred' +
              ' implementation, e.g. require("any-promise/register/bluebird")' +
              ' on application load prior to any require("any-promise").'
          );
        }

        return impl;
      }

      /**
       * Determines if the global.Promise should be preferred if an implementation
       * has not been registered.
       */
      function shouldPreferGlobalPromise(implementation) {
        if (implementation) {
          return implementation === "global.Promise";
        } else if (typeof global.Promise !== "undefined") {
          // Load global promise if implementation not specified
          // Versions < 0.11 did not have global Promise
          // Do not use for version < 0.12 as version 0.11 contained buggy versions
          var version = /v(\d+)\.(\d+)\.(\d+)/.exec(process.version);
          return !(version && +version[1] == 0 && +version[2] < 12);
        }

        // do not have global.Promise or another implementation was specified
        return false;
      }

      /**
       * Look for common libs as last resort there is no guarantee that
       * this will return a desired implementation or even be deterministic.
       * The priority is also nearly arbitrary. We are only doing this
       * for older versions of Node.js <0.12 that do not have a reasonable
       * global.Promise implementation and we the user has not registered
       * the preference. This preserves the behavior of any-promise <= 0.1
       * and may be deprecated or removed in the future
       */
      function tryAutoDetect() {
        var libs = [
          "es6-promise",
          "promise",
          "native-promise-only",
          "bluebird",
          "rsvp",
          "when",
          "q",
          "pinkie",
          "lie",
          "vow"
        ];
        var i = 0,
          len = libs.length;
        for (; i < len; i++) {
          try {
            return loadImplementation(libs[i]);
          } catch (e) {}
        }
        return null;
      }

      /***/
    },

    /***/ 9417: /***/ (module) => {
      "use strict";

      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);

        var r = range(a, b, str);

        return (
          r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length)
          }
        );
      }

      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }

      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;

        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;

          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }

              bi = str.indexOf(b, i + 1);
            }

            i = ai < bi && ai >= 0 ? ai : bi;
          }

          if (begs.length) {
            result = [left, right];
          }
        }

        return result;
      }

      /***/
    },

    /***/ 1686: /***/ function (module) {
      /*!
       * Bowser - a browser detector
       * https://github.com/ded/bowser
       * MIT License | (c) Dustin Diaz 2015
       */

      !(function (root, name, definition) {
        if (true && module.exports) module.exports = definition();
        else if (typeof define == "function" && define.amd) define(name, definition);
        else root[name] = definition();
      })(this, "bowser", function () {
        /**
         * See useragents.js for examples of navigator.userAgent
         */

        var t = true;

        function detect(ua) {
          function getFirstMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[1]) || "";
          }

          function getSecondMatch(regex) {
            var match = ua.match(regex);
            return (match && match.length > 1 && match[2]) || "";
          }

          var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),
            likeAndroid = /like android/i.test(ua),
            android = !likeAndroid && /android/i.test(ua),
            nexusMobile = /nexus\s*[0-6]\s*/i.test(ua),
            nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua),
            chromeos = /CrOS/.test(ua),
            silk = /silk/i.test(ua),
            sailfish = /sailfish/i.test(ua),
            tizen = /tizen/i.test(ua),
            webos = /(web|hpw)(o|0)s/i.test(ua),
            windowsphone = /windows phone/i.test(ua),
            samsungBrowser = /SamsungBrowser/i.test(ua),
            windows = !windowsphone && /windows/i.test(ua),
            mac = !iosdevice && !silk && /macintosh/i.test(ua),
            linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua),
            edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i),
            versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i),
            tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua),
            mobile = !tablet && /[^-]mobi/i.test(ua),
            xbox = /xbox/i.test(ua),
            result;

          if (/opera/i.test(ua)) {
            //  an old Opera
            result = {
              name: "Opera",
              opera: t,
              version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
            };
          } else if (/opr\/|opios/i.test(ua)) {
            // a new Opera
            result = {
              name: "Opera",
              opera: t,
              version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
            };
          } else if (/SamsungBrowser/i.test(ua)) {
            result = {
              name: "Samsung Internet for Android",
              samsungBrowser: t,
              version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
            };
          } else if (/Whale/i.test(ua)) {
            result = {
              name: "NAVER Whale browser",
              whale: t,
              version: getFirstMatch(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/MZBrowser/i.test(ua)) {
            result = {
              name: "MZ Browser",
              mzbrowser: t,
              version: getFirstMatch(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/coast/i.test(ua)) {
            result = {
              name: "Opera Coast",
              coast: t,
              version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
            };
          } else if (/focus/i.test(ua)) {
            result = {
              name: "Focus",
              focus: t,
              version: getFirstMatch(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/yabrowser/i.test(ua)) {
            result = {
              name: "Yandex Browser",
              yandexbrowser: t,
              version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
            };
          } else if (/ucbrowser/i.test(ua)) {
            result = {
              name: "UC Browser",
              ucbrowser: t,
              version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/mxios/i.test(ua)) {
            result = {
              name: "Maxthon",
              maxthon: t,
              version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/epiphany/i.test(ua)) {
            result = {
              name: "Epiphany",
              epiphany: t,
              version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/puffin/i.test(ua)) {
            result = {
              name: "Puffin",
              puffin: t,
              version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
            };
          } else if (/sleipnir/i.test(ua)) {
            result = {
              name: "Sleipnir",
              sleipnir: t,
              version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (/k-meleon/i.test(ua)) {
            result = {
              name: "K-Meleon",
              kMeleon: t,
              version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
            };
          } else if (windowsphone) {
            result = {
              name: "Windows Phone",
              osname: "Windows Phone",
              windowsphone: t
            };
            if (edgeVersion) {
              result.msedge = t;
              result.version = edgeVersion;
            } else {
              result.msie = t;
              result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
            }
          } else if (/msie|trident/i.test(ua)) {
            result = {
              name: "Internet Explorer",
              msie: t,
              version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
            };
          } else if (chromeos) {
            result = {
              name: "Chrome",
              osname: "Chrome OS",
              chromeos: t,
              chromeBook: t,
              chrome: t,
              version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            };
          } else if (/edg([ea]|ios)/i.test(ua)) {
            result = {
              name: "Microsoft Edge",
              msedge: t,
              version: edgeVersion
            };
          } else if (/vivaldi/i.test(ua)) {
            result = {
              name: "Vivaldi",
              vivaldi: t,
              version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
            };
          } else if (sailfish) {
            result = {
              name: "Sailfish",
              osname: "Sailfish OS",
              sailfish: t,
              version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
            };
          } else if (/seamonkey\//i.test(ua)) {
            result = {
              name: "SeaMonkey",
              seamonkey: t,
              version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
            };
          } else if (/firefox|iceweasel|fxios/i.test(ua)) {
            result = {
              name: "Firefox",
              firefox: t,
              version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
            };
            if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
              result.firefoxos = t;
              result.osname = "Firefox OS";
            }
          } else if (silk) {
            result = {
              name: "Amazon Silk",
              silk: t,
              version: getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
            };
          } else if (/phantom/i.test(ua)) {
            result = {
              name: "PhantomJS",
              phantom: t,
              version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
            };
          } else if (/slimerjs/i.test(ua)) {
            result = {
              name: "SlimerJS",
              slimer: t,
              version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
            };
          } else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
            result = {
              name: "BlackBerry",
              osname: "BlackBerry OS",
              blackberry: t,
              version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
            };
          } else if (webos) {
            result = {
              name: "WebOS",
              osname: "WebOS",
              webos: t,
              version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
            };
            /touchpad\//i.test(ua) && (result.touchpad = t);
          } else if (/bada/i.test(ua)) {
            result = {
              name: "Bada",
              osname: "Bada",
              bada: t,
              version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
            };
          } else if (tizen) {
            result = {
              name: "Tizen",
              osname: "Tizen",
              tizen: t,
              version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
            };
          } else if (/qupzilla/i.test(ua)) {
            result = {
              name: "QupZilla",
              qupzilla: t,
              version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
            };
          } else if (/chromium/i.test(ua)) {
            result = {
              name: "Chromium",
              chromium: t,
              version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
            };
          } else if (/chrome|crios|crmo/i.test(ua)) {
            result = {
              name: "Chrome",
              chrome: t,
              version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
            };
          } else if (android) {
            result = {
              name: "Android",
              version: versionIdentifier
            };
          } else if (/safari|applewebkit/i.test(ua)) {
            result = {
              name: "Safari",
              safari: t
            };
            if (versionIdentifier) {
              result.version = versionIdentifier;
            }
          } else if (iosdevice) {
            result = {
              name: iosdevice == "iphone" ? "iPhone" : iosdevice == "ipad" ? "iPad" : "iPod"
            };
            // WTF: version is not part of user agent in web apps
            if (versionIdentifier) {
              result.version = versionIdentifier;
            }
          } else if (/googlebot/i.test(ua)) {
            result = {
              name: "Googlebot",
              googlebot: t,
              version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
            };
          } else {
            result = {
              name: getFirstMatch(/^(.*)\/(.*) /),
              version: getSecondMatch(/^(.*)\/(.*) /)
            };
          }

          // set webkit or gecko flag for browsers based on these engines
          if (!result.msedge && /(apple)?webkit/i.test(ua)) {
            if (/(apple)?webkit\/537\.36/i.test(ua)) {
              result.name = result.name || "Blink";
              result.blink = t;
            } else {
              result.name = result.name || "Webkit";
              result.webkit = t;
            }
            if (!result.version && versionIdentifier) {
              result.version = versionIdentifier;
            }
          } else if (!result.opera && /gecko\//i.test(ua)) {
            result.name = result.name || "Gecko";
            result.gecko = t;
            result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
          }

          // set OS flags for platforms that have multiple browsers
          if (!result.windowsphone && (android || result.silk)) {
            result.android = t;
            result.osname = "Android";
          } else if (!result.windowsphone && iosdevice) {
            result[iosdevice] = t;
            result.ios = t;
            result.osname = "iOS";
          } else if (mac) {
            result.mac = t;
            result.osname = "macOS";
          } else if (xbox) {
            result.xbox = t;
            result.osname = "Xbox";
          } else if (windows) {
            result.windows = t;
            result.osname = "Windows";
          } else if (linux) {
            result.linux = t;
            result.osname = "Linux";
          }

          function getWindowsVersion(s) {
            switch (s) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return undefined;
            }
          }

          // OS version extraction
          var osVersion = "";
          if (result.windows) {
            osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
          } else if (result.windowsphone) {
            osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
          } else if (result.mac) {
            osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
            osVersion = osVersion.replace(/[_\s]/g, ".");
          } else if (iosdevice) {
            osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
            osVersion = osVersion.replace(/[_\s]/g, ".");
          } else if (android) {
            osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
          } else if (result.webos) {
            osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
          } else if (result.blackberry) {
            osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
          } else if (result.bada) {
            osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
          } else if (result.tizen) {
            osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
          }
          if (osVersion) {
            result.osversion = osVersion;
          }

          // device type extraction
          var osMajorVersion = !result.windows && osVersion.split(".")[0];
          if (
            tablet ||
            nexusTablet ||
            iosdevice == "ipad" ||
            (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile))) ||
            result.silk
          ) {
            result.tablet = t;
          } else if (
            mobile ||
            iosdevice == "iphone" ||
            iosdevice == "ipod" ||
            android ||
            nexusMobile ||
            result.blackberry ||
            result.webos ||
            result.bada
          ) {
            result.mobile = t;
          }

          // Graded Browser Support
          // http://developer.yahoo.com/yui/articles/gbs
          if (
            result.msedge ||
            (result.msie && result.version >= 10) ||
            (result.yandexbrowser && result.version >= 15) ||
            (result.vivaldi && result.version >= 1.0) ||
            (result.chrome && result.version >= 20) ||
            (result.samsungBrowser && result.version >= 4) ||
            (result.whale && compareVersions([result.version, "1.0"]) === 1) ||
            (result.mzbrowser && compareVersions([result.version, "6.0"]) === 1) ||
            (result.focus && compareVersions([result.version, "1.0"]) === 1) ||
            (result.firefox && result.version >= 20.0) ||
            (result.safari && result.version >= 6) ||
            (result.opera && result.version >= 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
            (result.blackberry && result.version >= 10.1) ||
            (result.chromium && result.version >= 20)
          ) {
            result.a = t;
          } else if (
            (result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20.0) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] < 6) ||
            (result.chromium && result.version < 20)
          ) {
            result.c = t;
          } else result.x = t;

          return result;
        }

        var bowser = detect(typeof navigator !== "undefined" ? navigator.userAgent || "" : "");

        bowser.test = function (browserList) {
          for (var i = 0; i < browserList.length; ++i) {
            var browserItem = browserList[i];
            if (typeof browserItem === "string") {
              if (browserItem in bowser) {
                return true;
              }
            }
          }
          return false;
        };

        /**
         * Get version precisions count
         *
         * @example
         *   getVersionPrecision("1.10.3") // 3
         *
         * @param  {string} version
         * @return {number}
         */
        function getVersionPrecision(version) {
          return version.split(".").length;
        }

        /**
         * Array::map polyfill
         *
         * @param  {Array} arr
         * @param  {Function} iterator
         * @return {Array}
         */
        function map(arr, iterator) {
          var result = [],
            i;
          if (Array.prototype.map) {
            return Array.prototype.map.call(arr, iterator);
          }
          for (i = 0; i < arr.length; i++) {
            result.push(iterator(arr[i]));
          }
          return result;
        }

        /**
         * Calculate browser version weight
         *
         * @example
         *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
         *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
         *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
         *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
         *
         * @param  {Array<String>} versions versions to compare
         * @return {Number} comparison result
         */
        function compareVersions(versions) {
          // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
          var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
          var chunks = map(versions, function (version) {
            var delta = precision - getVersionPrecision(version);

            // 2) "9" -> "9.0" (for precision = 2)
            version = version + new Array(delta + 1).join(".0");

            // 3) "9.0" -> ["000000000"", "000000009"]
            return map(version.split("."), function (chunk) {
              return new Array(20 - chunk.length).join("0") + chunk;
            }).reverse();
          });

          // iterate in reverse order by reversed chunks array
          while (--precision >= 0) {
            // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
            if (chunks[0][precision] > chunks[1][precision]) {
              return 1;
            } else if (chunks[0][precision] === chunks[1][precision]) {
              if (precision === 0) {
                // all version chunks are same
                return 0;
              }
            } else {
              return -1;
            }
          }
        }

        /**
         * Check if browser is unsupported
         *
         * @example
         *   bowser.isUnsupportedBrowser({
         *     msie: "10",
         *     firefox: "23",
         *     chrome: "29",
         *     safari: "5.1",
         *     opera: "16",
         *     phantom: "534"
         *   });
         *
         * @param  {Object}  minVersions map of minimal version to browser
         * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
         * @param  {String}  [ua] user agent string
         * @return {Boolean}
         */
        function isUnsupportedBrowser(minVersions, strictMode, ua) {
          var _bowser = bowser;

          // make strictMode param optional with ua param usage
          if (typeof strictMode === "string") {
            ua = strictMode;
            strictMode = void 0;
          }

          if (strictMode === void 0) {
            strictMode = false;
          }
          if (ua) {
            _bowser = detect(ua);
          }

          var version = "" + _bowser.version;
          for (var browser in minVersions) {
            if (minVersions.hasOwnProperty(browser)) {
              if (_bowser[browser]) {
                if (typeof minVersions[browser] !== "string") {
                  throw new Error(
                    "Browser version in the minVersion map should be a string: " + browser + ": " + String(minVersions)
                  );
                }

                // browser version and min supported version.
                return compareVersions([version, minVersions[browser]]) < 0;
              }
            }
          }

          return strictMode; // not found
        }

        /**
         * Check if browser is supported
         *
         * @param  {Object} minVersions map of minimal version to browser
         * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
         * @param  {String}  [ua] user agent string
         * @return {Boolean}
         */
        function check(minVersions, strictMode, ua) {
          return !isUnsupportedBrowser(minVersions, strictMode, ua);
        }

        bowser.isUnsupportedBrowser = isUnsupportedBrowser;
        bowser.compareVersions = compareVersions;
        bowser.check = check;

        /*
         * Set our detect method to the main bowser object so we can
         * reuse it to test other user agents.
         * This is needed to implement future tests.
         */
        bowser._detect = detect;

        /*
         * Set our detect public method to the main bowser object
         * This is needed to implement bowser in server side
         */
        bowser.detect = detect;
        return bowser;
      });

      /***/
    },

    /***/ 3717: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var concatMap = __nccwpck_require__(6891);
      var balanced = __nccwpck_require__(9417);

      module.exports = expandTop;

      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";

      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }

      function escapeBraces(str) {
        return str
          .split("\\\\")
          .join(escSlash)
          .split("\\{")
          .join(escOpen)
          .split("\\}")
          .join(escClose)
          .split("\\,")
          .join(escComma)
          .split("\\.")
          .join(escPeriod);
      }

      function unescapeBraces(str) {
        return str
          .split(escSlash)
          .join("\\")
          .split(escOpen)
          .join("{")
          .split(escClose)
          .join("}")
          .split(escComma)
          .join(",")
          .split(escPeriod)
          .join(".");
      }

      // Basically just str.split(","), but handling cases
      // where we have nested braced sections, which should be
      // treated as individual members, like {a,{b,c},d}
      function parseCommaParts(str) {
        if (!str) return [""];

        var parts = [];
        var m = balanced("{", "}", str);

        if (!m) return str.split(",");

        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");

        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }

        parts.push.apply(parts, p);

        return parts;
      }

      function expandTop(str) {
        if (!str) return [];

        // I don't know why Bash 4.3 does this, but it does.
        // Anything starting with {} will have the first two bytes preserved
        // but *only* at the top level, so {},a}b will not expand to anything,
        // but a{},b}c will be expanded to [a}c,abc].
        // One could argue that this is a bug in Bash, but since the goal of
        // this module is to match Bash's rules, we escape a leading {}
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }

        return expand(escapeBraces(str), true).map(unescapeBraces);
      }

      function identity(e) {
        return e;
      }

      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }

      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }

      function expand(str, isTop) {
        var expansions = [];

        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre)) return [str];

        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          // {a},b}
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }

        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            // x{{a,b}}y ==> x{a}y x{b}y
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand(m.post, false) : [""];
              return post.map(function (p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }

        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.

        // no need to expand pre, since it is guaranteed to be free of brace-sets
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];

        var N;

        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);

          N = [];

          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\") c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0) c = "-" + z + c.slice(1);
                  else c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function (el) {
            return expand(el, false);
          });
        }

        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion) expansions.push(expansion);
          }
        }

        return expansions;
      }

      /***/
    },

    /***/ 8803: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var GetIntrinsic = __nccwpck_require__(4538);

      var callBind = __nccwpck_require__(2977);

      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));

      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };

      /***/
    },

    /***/ 2977: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var bind = __nccwpck_require__(8334);
      var GetIntrinsic = __nccwpck_require__(4538);

      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);

      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");

      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          // IE 8 has a broken defineProperty
          $defineProperty = null;
        }
      }

      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            // original length, plus the receiver, minus any additional arguments (after the receiver)
            $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
          }
        }
        return func;
      };

      var applyBind = function applyBind() {
        return $reflectApply(bind, $apply, arguments);
      };

      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }

      /***/
    },

    /***/ 6891: /***/ (module) => {
      module.exports = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x)) res.push.apply(res, x);
          else res.push(x);
        }
        return res;
      };

      var isArray =
        Array.isArray ||
        function (xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };

      /***/
    },

    /***/ 9915: /***/ (__unused_webpack_module, exports) => {
      "use strict";
      /*!
       * content-type
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */

      /**
       * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
       *
       * parameter     = token "=" ( token / quoted-string )
       * token         = 1*tchar
       * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
       *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
       *               / DIGIT / ALPHA
       *               ; any VCHAR, except delimiters
       * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
       * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
       * obs-text      = %x80-FF
       * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
       */
      var PARAM_REGEXP =
        /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex
      var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/; // eslint-disable-line no-control-regex
      var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

      /**
       * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
       *
       * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
       * obs-text    = %x80-FF
       */
      var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g; // eslint-disable-line no-control-regex

      /**
       * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
       */
      var QUOTE_REGEXP = /([\\"])/g;

      /**
       * RegExp to match type in RFC 7231 sec 3.1.1.1
       *
       * media-type = type "/" subtype
       * type       = token
       * subtype    = token
       */
      var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

      /**
       * Module exports.
       * @public
       */

      exports.format = format;
      exports.parse = parse;

      /**
       * Format object to media type.
       *
       * @param {object} obj
       * @return {string}
       * @public
       */

      function format(obj) {
        if (!obj || typeof obj !== "object") {
          throw new TypeError("argument obj is required");
        }

        var parameters = obj.parameters;
        var type = obj.type;

        if (!type || !TYPE_REGEXP.test(type)) {
          throw new TypeError("invalid type");
        }

        var string = type;

        // append parameters
        if (parameters && typeof parameters === "object") {
          var param;
          var params = Object.keys(parameters).sort();

          for (var i = 0; i < params.length; i++) {
            param = params[i];

            if (!TOKEN_REGEXP.test(param)) {
              throw new TypeError("invalid parameter name");
            }

            string += "; " + param + "=" + qstring(parameters[param]);
          }
        }

        return string;
      }

      /**
       * Parse media type to object.
       *
       * @param {string|object} string
       * @return {Object}
       * @public
       */

      function parse(string) {
        if (!string) {
          throw new TypeError("argument string is required");
        }

        // support req/res-like objects as argument
        var header = typeof string === "object" ? getcontenttype(string) : string;

        if (typeof header !== "string") {
          throw new TypeError("argument string is required to be a string");
        }

        var index = header.indexOf(";");
        var type = index !== -1 ? header.slice(0, index).trim() : header.trim();

        if (!TYPE_REGEXP.test(type)) {
          throw new TypeError("invalid media type");
        }

        var obj = new ContentType(type.toLowerCase());

        // parse parameters
        if (index !== -1) {
          var key;
          var match;
          var value;

          PARAM_REGEXP.lastIndex = index;

          while ((match = PARAM_REGEXP.exec(header))) {
            if (match.index !== index) {
              throw new TypeError("invalid parameter format");
            }

            index += match[0].length;
            key = match[1].toLowerCase();
            value = match[2];

            if (value.charCodeAt(0) === 0x22 /* " */) {
              // remove quotes
              value = value.slice(1, -1);

              // remove escapes
              if (value.indexOf("\\") !== -1) {
                value = value.replace(QESC_REGEXP, "$1");
              }
            }

            obj.parameters[key] = value;
          }

          if (index !== header.length) {
            throw new TypeError("invalid parameter format");
          }
        }

        return obj;
      }

      /**
       * Get content-type from req/res objects.
       *
       * @param {object}
       * @return {Object}
       * @private
       */

      function getcontenttype(obj) {
        var header;

        if (typeof obj.getHeader === "function") {
          // res-like
          header = obj.getHeader("content-type");
        } else if (typeof obj.headers === "object") {
          // req-like
          header = obj.headers && obj.headers["content-type"];
        }

        if (typeof header !== "string") {
          throw new TypeError("content-type header is missing from object");
        }

        return header;
      }

      /**
       * Quote a string if necessary.
       *
       * @param {string} val
       * @return {string}
       * @private
       */

      function qstring(val) {
        var str = String(val);

        // no need to quote tokens
        if (TOKEN_REGEXP.test(str)) {
          return str;
        }

        if (str.length > 0 && !TEXT_REGEXP.test(str)) {
          throw new TypeError("invalid parameter value");
        }

        return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
      }

      /**
       * Class to represent a content type.
       * @private
       */
      function ContentType(type) {
        this.parameters = Object.create(null);
        this.type = type;
      }

      /***/
    },

    /***/ 952: /***/ (module) => {
      "use strict";
      /*!
       * copy-to - index.js
       * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
       * MIT Licensed
       */

      /**
       * slice() reference.
       */

      var slice = Array.prototype.slice;

      /**
       * Expose copy
       *
       * ```
       * copy({foo: 'nar', hello: 'copy'}).to({hello: 'world'});
       * copy({foo: 'nar', hello: 'copy'}).toCover({hello: 'world'});
       * ```
       *
       * @param {Object} src
       * @return {Copy}
       */

      module.exports = Copy;

      /**
       * Copy
       * @param {Object} src
       * @param {Boolean} withAccess
       */

      function Copy(src, withAccess) {
        if (!(this instanceof Copy)) return new Copy(src, withAccess);
        this.src = src;
        this._withAccess = withAccess;
      }

      /**
       * copy properties include getter and setter
       * @param {[type]} val [description]
       * @return {[type]} [description]
       */

      Copy.prototype.withAccess = function (w) {
        this._withAccess = w !== false;
        return this;
      };

      /**
       * pick keys in src
       *
       * @api: public
       */

      Copy.prototype.pick = function (keys) {
        if (!Array.isArray(keys)) {
          keys = slice.call(arguments);
        }
        if (keys.length) {
          this.keys = keys;
        }
        return this;
      };

      /**
       * copy src to target,
       * do not cover any property target has
       * @param {Object} to
       *
       * @api: public
       */

      Copy.prototype.to = function (to) {
        to = to || {};

        if (!this.src) return to;
        var keys = this.keys || Object.keys(this.src);

        if (!this._withAccess) {
          for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            if (to[key] !== undefined) continue;
            to[key] = this.src[key];
          }
          return to;
        }

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!notDefined(to, key)) continue;
          var getter = this.src.__lookupGetter__(key);
          var setter = this.src.__lookupSetter__(key);
          if (getter) to.__defineGetter__(key, getter);
          if (setter) to.__defineSetter__(key, setter);

          if (!getter && !setter) {
            to[key] = this.src[key];
          }
        }
        return to;
      };

      /**
       * copy src to target,
       * override any property target has
       * @param {Object} to
       *
       * @api: public
       */

      Copy.prototype.toCover = function (to) {
        var keys = this.keys || Object.keys(this.src);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          delete to[key];
          var getter = this.src.__lookupGetter__(key);
          var setter = this.src.__lookupSetter__(key);
          if (getter) to.__defineGetter__(key, getter);
          if (setter) to.__defineSetter__(key, setter);

          if (!getter && !setter) {
            to[key] = this.src[key];
          }
        }
      };

      Copy.prototype.override = Copy.prototype.toCover;

      /**
       * append another object to src
       * @param {Obj} obj
       * @return {Copy}
       */

      Copy.prototype.and = function (obj) {
        var src = {};
        this.to(src);
        this.src = obj;
        this.to(src);
        this.src = src;

        return this;
      };

      /**
       * check obj[key] if not defiend
       * @param {Object} obj
       * @param {String} key
       * @return {Boolean}
       */

      function notDefined(obj, key) {
        return (
          obj[key] === undefined && obj.__lookupGetter__(key) === undefined && obj.__lookupSetter__(key) === undefined
        );
      }

      /***/
    },

    /***/ 5898: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      // NOTE: These type checking functions intentionally don't use `instanceof`
      // because it is fragile and can be easily faked with `Object.create()`.

      function isArray(arg) {
        if (Array.isArray) {
          return Array.isArray(arg);
        }
        return objectToString(arg) === "[object Array]";
      }
      exports.isArray = isArray;

      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;

      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;

      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;

      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;

      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;

      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;

      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;

      function isRegExp(re) {
        return objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;

      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;

      function isDate(d) {
        return objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;

      function isError(e) {
        return objectToString(e) === "[object Error]" || e instanceof Error;
      }
      exports.isError = isError;

      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;

      function isPrimitive(arg) {
        return (
          arg === null ||
          typeof arg === "boolean" ||
          typeof arg === "number" ||
          typeof arg === "string" ||
          typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined"
        );
      }
      exports.isPrimitive = isPrimitive;

      exports.isBuffer = __nccwpck_require__(4300).Buffer.isBuffer;

      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }

      /***/
    },

    /***/ 1512: /***/ function (module) {
      /*
       * Date Format 1.2.3
       * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
       * MIT license
       *
       * Includes enhancements by Scott Trenda <scott.trenda.net>
       * and Kris Kowal <cixar.com/~kris.kowal/>
       *
       * Accepts a date, a mask, or a date and a mask.
       * Returns a formatted version of the given date.
       * The date defaults to the current date/time.
       * The mask defaults to dateFormat.masks.default.
       */

      (function (global) {
        "use strict";

        var dateFormat = (function () {
          var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
          var timezone =
            /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
          var timezoneClip = /[^-+\dA-Z]/g;

          // Regexes and supporting functions are cached through closure
          return function (date, mask, utc, gmt) {
            // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
            if (arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
              mask = date;
              date = undefined;
            }

            date = date || new Date();

            if (!(date instanceof Date)) {
              date = new Date(date);
            }

            if (isNaN(date)) {
              throw TypeError("Invalid date");
            }

            mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);

            // Allow setting the utc/gmt argument via the mask
            var maskSlice = mask.slice(0, 4);
            if (maskSlice === "UTC:" || maskSlice === "GMT:") {
              mask = mask.slice(4);
              utc = true;
              if (maskSlice === "GMT:") {
                gmt = true;
              }
            }

            var _ = utc ? "getUTC" : "get";
            var d = date[_ + "Date"]();
            var D = date[_ + "Day"]();
            var m = date[_ + "Month"]();
            var y = date[_ + "FullYear"]();
            var H = date[_ + "Hours"]();
            var M = date[_ + "Minutes"]();
            var s = date[_ + "Seconds"]();
            var L = date[_ + "Milliseconds"]();
            var o = utc ? 0 : date.getTimezoneOffset();
            var W = getWeek(date);
            var N = getDayOfWeek(date);
            var flags = {
              d: d,
              dd: pad(d),
              ddd: dateFormat.i18n.dayNames[D],
              dddd: dateFormat.i18n.dayNames[D + 7],
              m: m + 1,
              mm: pad(m + 1),
              mmm: dateFormat.i18n.monthNames[m],
              mmmm: dateFormat.i18n.monthNames[m + 12],
              yy: String(y).slice(2),
              yyyy: y,
              h: H % 12 || 12,
              hh: pad(H % 12 || 12),
              H: H,
              HH: pad(H),
              M: M,
              MM: pad(M),
              s: s,
              ss: pad(s),
              l: pad(L, 3),
              L: pad(Math.round(L / 10)),
              t: H < 12 ? "a" : "p",
              tt: H < 12 ? "am" : "pm",
              T: H < 12 ? "A" : "P",
              TT: H < 12 ? "AM" : "PM",
              Z: gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
              o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + (Math.abs(o) % 60), 4),
              S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (((d % 100) - (d % 10) != 10) * d) % 10],
              W: W,
              N: N
            };

            return mask.replace(token, function (match) {
              if (match in flags) {
                return flags[match];
              }
              return match.slice(1, match.length - 1);
            });
          };
        })();

        dateFormat.masks = {
          default: "ddd mmm dd yyyy HH:MM:ss",
          shortDate: "m/d/yy",
          mediumDate: "mmm d, yyyy",
          longDate: "mmmm d, yyyy",
          fullDate: "dddd, mmmm d, yyyy",
          shortTime: "h:MM TT",
          mediumTime: "h:MM:ss TT",
          longTime: "h:MM:ss TT Z",
          isoDate: "yyyy-mm-dd",
          isoTime: "HH:MM:ss",
          isoDateTime: "yyyy-mm-dd'T'HH:MM:sso",
          isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'",
          expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z"
        };

        // Internationalization strings
        dateFormat.i18n = {
          dayNames: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ],
          monthNames: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        };

        function pad(val, len) {
          val = String(val);
          len = len || 2;
          while (val.length < len) {
            val = "0" + val;
          }
          return val;
        }

        /**
         * Get the ISO 8601 week number
         * Based on comments from
         * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
         *
         * @param  {Object} `date`
         * @return {Number}
         */
        function getWeek(date) {
          // Remove time components of date
          var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

          // Change date to Thursday same week
          targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

          // Take January 4th as it is always in week 1 (see ISO 8601)
          var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

          // Change date to Thursday same week
          firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

          // Check if daylight-saving-time-switch occurred and correct for it
          var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
          targetThursday.setHours(targetThursday.getHours() - ds);

          // Number of weeks between target Thursday and first Thursday
          var weekDiff = (targetThursday - firstThursday) / (86400000 * 7);
          return 1 + Math.floor(weekDiff);
        }

        /**
         * Get ISO-8601 numeric representation of the day of the week
         * 1 (for Monday) through 7 (for Sunday)
         *
         * @param  {Object} `date`
         * @return {Number}
         */
        function getDayOfWeek(date) {
          var dow = date.getDay();
          if (dow === 0) {
            dow = 7;
          }
          return dow;
        }

        /**
         * kind-of shortcut
         * @param  {*} val
         * @return {String}
         */
        function kindOf(val) {
          if (val === null) {
            return "null";
          }

          if (val === undefined) {
            return "undefined";
          }

          if (typeof val !== "object") {
            return typeof val;
          }

          if (Array.isArray(val)) {
            return "array";
          }

          return {}.toString.call(val).slice(8, -1).toLowerCase();
        }

        if (typeof define === "function" && define.amd) {
          define(function () {
            return dateFormat;
          });
        } else if (true) {
          module.exports = dateFormat;
        } else {
        }
      })(this);

      /***/
    },

    /***/ 8222: /***/ (module, exports, __nccwpck_require__) => {
      /* eslint-env browser */

      /**
       * This is the web browser implementation of `debug()`.
       */

      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;

        return () => {
          if (!warned) {
            warned = true;
            console.warn(
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
            );
          }
        };
      })();

      /**
       * Colors.
       */

      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];

      /**
       * Currently only WebKit-based Web Inspectors, Firefox >= v31,
       * and the Firebug extension (any Firefox version) are known
       * to support "%c" CSS customizations.
       *
       * TODO: add a `localStorage` variable to explicitly enable/disable colors
       */

      // eslint-disable-next-line complexity
      function useColors() {
        // NB: In an Electron preload script, document will be defined but not fully
        // initialized. Since we know we're in Chrome, we'll just detect this case
        // explicitly
        if (
          typeof window !== "undefined" &&
          window.process &&
          (window.process.type === "renderer" || window.process.__nwjs)
        ) {
          return true;
        }

        // Internet Explorer and Edge do not support colors.
        if (
          typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ) {
          return false;
        }

        // Is webkit? http://stackoverflow.com/a/16459606/376773
        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
        return (
          (typeof document !== "undefined" &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          // Is firebug? http://stackoverflow.com/a/398120/376773
          (typeof window !== "undefined" &&
            window.console &&
            (window.console.firebug || (window.console.exception && window.console.table))) ||
          // Is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          // Double check webkit in userAgent just in case we are in a worker
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        );
      }

      /**
       * Colorize log arguments if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        args[0] =
          (this.useColors ? "%c" : "") +
          this.namespace +
          (this.useColors ? " %c" : " ") +
          args[0] +
          (this.useColors ? "%c " : " ") +
          "+" +
          module.exports.humanize(this.diff);

        if (!this.useColors) {
          return;
        }

        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");

        // The final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
          }
        });

        args.splice(lastC, 0, c);
      }

      /**
       * Invokes `console.debug()` when available.
       * No-op when `console.debug` is not a "function".
       * If `console.debug` is not available, falls back
       * to `console.log`.
       *
       * @api public
       */
      exports.log = console.debug || console.log || (() => {});

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
          // Swallow
          // XXX (@Qix-) should we be logging these?
        }
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
          // Swallow
          // XXX (@Qix-) should we be logging these?
        }

        // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }

        return r;
      }

      /**
       * Localstorage attempts to return the localstorage.
       *
       * This is necessary because safari throws
       * when a user disables cookies/localstorage
       * and you attempt to access it.
       *
       * @return {LocalStorage}
       * @api private
       */

      function localstorage() {
        try {
          // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
          // The Browser also has localStorage in the global context.
          return localStorage;
        } catch (error) {
          // Swallow
          // XXX (@Qix-) should we be logging these?
        }
      }

      module.exports = __nccwpck_require__(6243)(exports);

      const { formatters } = module.exports;

      /**
       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
       */

      formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };

      /***/
    },

    /***/ 6243: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      /**
       * This is the common logic for both the Node.js and web browser
       * implementations of `debug()`.
       */

      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = __nccwpck_require__(900);
        createDebug.destroy = destroy;

        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });

        /**
         * The currently active debug mode names, and names to skip.
         */

        createDebug.names = [];
        createDebug.skips = [];

        /**
         * Map of special "%n" handling functions, for the debug "format" argument.
         *
         * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
         */
        createDebug.formatters = {};

        /**
         * Selects a color for a debug namespace
         * @param {String} namespace The namespace string for the debug instance to be colored
         * @return {Number|String} An ANSI color code for the given namespace
         * @api private
         */
        function selectColor(namespace) {
          let hash = 0;

          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
          }

          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;

        /**
         * Create a debugger with the given `namespace`.
         *
         * @param {String} namespace
         * @return {Function}
         * @api public
         */
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;

          function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
              return;
            }

            const self = debug;

            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;

            args[0] = createDebug.coerce(args[0]);

            if (typeof args[0] !== "string") {
              // Anything else let's inspect with %O
              args.unshift("%O");
            }

            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              // If we encounter an escaped % then don't increase the array index
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);

                // Now we need to remove `args[index]` since it's inlined in the `format`
                args.splice(index, 1);
                index--;
              }
              return match;
            });

            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);

            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }

          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }

              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });

          // Env-specific initialization logic for debug instances
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }

          return debug;
        }

        function extend(namespace, delimiter) {
          const newDebug = createDebug(
            this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace
          );
          newDebug.log = this.log;
          return newDebug;
        }

        /**
         * Enables a debug mode by namespaces. This can include modes
         * separated by a colon and wildcards.
         *
         * @param {String} namespaces
         * @api public
         */
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;

          createDebug.names = [];
          createDebug.skips = [];

          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;

          for (i = 0; i < len; i++) {
            if (!split[i]) {
              // ignore empty strings
              continue;
            }

            namespaces = split[i].replace(/\*/g, ".*?");

            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }

        /**
         * Disable debug output.
         *
         * @return {String} namespaces
         * @api public
         */
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }

        /**
         * Returns true if the given mode name is enabled, false otherwise.
         *
         * @param {String} name
         * @return {Boolean}
         * @api public
         */
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }

          let i;
          let len;

          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }

          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }

          return false;
        }

        /**
         * Convert regexp to namespace
         *
         * @param {RegExp} regxep
         * @return {String} namespace
         * @api private
         */
        function toNamespace(regexp) {
          return regexp
            .toString()
            .substring(2, regexp.toString().length - 2)
            .replace(/\.\*\?$/, "*");
        }

        /**
         * Coerce `val`.
         *
         * @param {Mixed} val
         * @return {Mixed}
         * @api private
         */
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }

        /**
         * XXX DO NOT USE. This is a temporary stub function.
         * XXX It WILL be removed in the next major release.
         */
        function destroy() {
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          );
        }

        createDebug.enable(createDebug.load());

        return createDebug;
      }

      module.exports = setup;

      /***/
    },

    /***/ 8237: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      /**
       * Detect Electron renderer / nwjs process, which is node, but we should
       * treat as a browser.
       */

      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module.exports = __nccwpck_require__(8222);
      } else {
        module.exports = __nccwpck_require__(4874);
      }

      /***/
    },

    /***/ 4874: /***/ (module, exports, __nccwpck_require__) => {
      /**
       * Module dependencies.
       */

      const tty = __nccwpck_require__(6224);
      const util = __nccwpck_require__(3837);

      /**
       * This is the Node.js implementation of `debug()`.
       */

      exports.init = init;
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.destroy = util.deprecate(
        () => {},
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
      );

      /**
       * Colors.
       */

      exports.colors = [6, 2, 3, 4, 5, 1];

      try {
        // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
        // eslint-disable-next-line import/no-extraneous-dependencies
        const supportsColor = __nccwpck_require__(9318);

        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [
            20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80,
            81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
            169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
            208, 209, 214, 215, 220, 221
          ];
        }
      } catch (error) {
        // Swallow - we only care if `supports-color` is available; it doesn't have to be.
      }

      /**
       * Build up the default `inspectOpts` object from the environment variables.
       *
       *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
       */

      exports.inspectOpts = Object.keys(process.env)
        .filter((key) => {
          return /^debug_/i.test(key);
        })
        .reduce((obj, key) => {
          // Camel-case
          const prop = key
            .substring(6)
            .toLowerCase()
            .replace(/_([a-z])/g, (_, k) => {
              return k.toUpperCase();
            });

          // Coerce string value into JS value
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }

          obj[prop] = val;
          return obj;
        }, {});

      /**
       * Is stdout a TTY? Colored output is enabled when `true`.
       */

      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }

      /**
       * Adds ANSI color escape codes if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        const { namespace: name, useColors } = this;

        if (useColors) {
          const c = this.color;
          const colorCode = "\u001B[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} \u001B[0m`;

          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\u001B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }

      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }

      /**
       * Invokes `util.format()` with the specified arguments and writes to stderr.
       */

      function log(...args) {
        return process.stderr.write(util.format(...args) + "\n");
      }

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          // If you set a process.env field to null or undefined, it gets cast to the
          // string 'null' or 'undefined'. Just delete instead.
          delete process.env.DEBUG;
        }
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */

      function load() {
        return process.env.DEBUG;
      }

      /**
       * Init logic for `debug` instances.
       *
       * Create a new `inspectOpts` object in case `useColors` is set
       * differently for a particular `debug` instance.
       */

      function init(debug) {
        debug.inspectOpts = {};

        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }

      module.exports = __nccwpck_require__(6243)(exports);

      const { formatters } = module.exports;

      /**
       * Map %o to `util.inspect()`, all on a single line.
       */

      formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util
          .inspect(v, this.inspectOpts)
          .split("\n")
          .map((str) => str.trim())
          .join(" ");
      };

      /**
       * Map %O to `util.inspect()`, allowing multiple lines if needed.
       */

      formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };

      /***/
    },

    /***/ 6834: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /**!
       * default-user-agent - index.js
       *
       * Copyright(c) fengmk2 and other contributors.
       * MIT Licensed
       *
       * Authors:
       *   fengmk2 <fengmk2@gmail.com> (http://fengmk2.com)
       */

      /**
       * Module dependencies.
       */

      var osName = __nccwpck_require__(4824);

      var USER_AGENT = "Node.js/" + process.version.slice(1) + " (" + osName() + "; " + process.arch + ")";

      module.exports = function ua(name, version) {
        if (arguments.length !== 2) {
          return USER_AGENT;
        }
        return name + "/" + version + " " + USER_AGENT;
      };

      /***/
    },

    /***/ 3225: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /*!
       * destroy
       * Copyright(c) 2014 Jonathan Ong
       * Copyright(c) 2015-2022 Douglas Christopher Wilson
       * MIT Licensed
       */

      /**
       * Module dependencies.
       * @private
       */

      var EventEmitter = __nccwpck_require__(2361).EventEmitter;
      var ReadStream = __nccwpck_require__(7147).ReadStream;
      var Stream = __nccwpck_require__(2781);
      var Zlib = __nccwpck_require__(9796);

      /**
       * Module exports.
       * @public
       */

      module.exports = destroy;

      /**
       * Destroy the given stream, and optionally suppress any future `error` events.
       *
       * @param {object} stream
       * @param {boolean} suppress
       * @public
       */

      function destroy(stream, suppress) {
        if (isFsReadStream(stream)) {
          destroyReadStream(stream);
        } else if (isZlibStream(stream)) {
          destroyZlibStream(stream);
        } else if (hasDestroy(stream)) {
          stream.destroy();
        }

        if (isEventEmitter(stream) && suppress) {
          stream.removeAllListeners("error");
          stream.addListener("error", noop);
        }

        return stream;
      }

      /**
       * Destroy a ReadStream.
       *
       * @param {object} stream
       * @private
       */

      function destroyReadStream(stream) {
        stream.destroy();

        if (typeof stream.close === "function") {
          // node.js core bug work-around
          stream.on("open", onOpenClose);
        }
      }

      /**
       * Close a Zlib stream.
       *
       * Zlib streams below Node.js 4.5.5 have a buggy implementation
       * of .close() when zlib encountered an error.
       *
       * @param {object} stream
       * @private
       */

      function closeZlibStream(stream) {
        if (stream._hadError === true) {
          var prop = stream._binding === null ? "_binding" : "_handle";

          stream[prop] = {
            close: function () {
              this[prop] = null;
            }
          };
        }

        stream.close();
      }

      /**
       * Destroy a Zlib stream.
       *
       * Zlib streams don't have a destroy function in Node.js 6. On top of that
       * simply calling destroy on a zlib stream in Node.js 8+ will result in a
       * memory leak. So until that is fixed, we need to call both close AND destroy.
       *
       * PR to fix memory leak: https://github.com/nodejs/node/pull/23734
       *
       * In Node.js 6+8, it's important that destroy is called before close as the
       * stream would otherwise emit the error 'zlib binding closed'.
       *
       * @param {object} stream
       * @private
       */

      function destroyZlibStream(stream) {
        if (typeof stream.destroy === "function") {
          // node.js core bug work-around
          // istanbul ignore if: node.js 0.8
          if (stream._binding) {
            // node.js < 0.10.0
            stream.destroy();
            if (stream._processing) {
              stream._needDrain = true;
              stream.once("drain", onDrainClearBinding);
            } else {
              stream._binding.clear();
            }
          } else if (stream._destroy && stream._destroy !== Stream.Transform.prototype._destroy) {
            // node.js >= 12, ^11.1.0, ^10.15.1
            stream.destroy();
          } else if (stream._destroy && typeof stream.close === "function") {
            // node.js 7, 8
            stream.destroyed = true;
            stream.close();
          } else {
            // fallback
            // istanbul ignore next
            stream.destroy();
          }
        } else if (typeof stream.close === "function") {
          // node.js < 8 fallback
          closeZlibStream(stream);
        }
      }

      /**
       * Determine if stream has destroy.
       * @private
       */

      function hasDestroy(stream) {
        return stream instanceof Stream && typeof stream.destroy === "function";
      }

      /**
       * Determine if val is EventEmitter.
       * @private
       */

      function isEventEmitter(val) {
        return val instanceof EventEmitter;
      }

      /**
       * Determine if stream is fs.ReadStream stream.
       * @private
       */

      function isFsReadStream(stream) {
        return stream instanceof ReadStream;
      }

      /**
       * Determine if stream is Zlib stream.
       * @private
       */

      function isZlibStream(stream) {
        return (
          stream instanceof Zlib.Gzip ||
          stream instanceof Zlib.Gunzip ||
          stream instanceof Zlib.Deflate ||
          stream instanceof Zlib.DeflateRaw ||
          stream instanceof Zlib.Inflate ||
          stream instanceof Zlib.InflateRaw ||
          stream instanceof Zlib.Unzip
        );
      }

      /**
       * No-op function.
       * @private
       */

      function noop() {}

      /**
       * On drain handler to clear binding.
       * @private
       */

      // istanbul ignore next: node.js 0.8
      function onDrainClearBinding() {
        this._binding.clear();
      }

      /**
       * On open handler to close stream.
       * @private
       */

      function onOpenClose() {
        if (typeof this.fd === "number") {
          // actually close down the fd
          this.close();
        }
      }

      /***/
    },

    /***/ 7774: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      const crypto = __nccwpck_require__(6113);

      const AUTH_KEY_VALUE_RE = /(\w+)=["']?([^'"]{1,10000})["']?/;
      let NC = 0;
      const NC_PAD = "00000000";

      function md5(text) {
        return crypto.createHash("md5").update(text).digest("hex");
      }

      function digestAuthHeader(method, uri, wwwAuthenticate, userpass) {
        const parts = wwwAuthenticate.split(",");
        const opts = {};
        for (let i = 0; i < parts.length; i++) {
          const m = AUTH_KEY_VALUE_RE.exec(parts[i]);
          if (m) {
            opts[m[1]] = m[2].replace(/["']/g, "");
          }
        }

        if (!opts.realm || !opts.nonce) {
          return "";
        }

        let qop = opts.qop || "";

        // WWW-Authenticate: Digest realm="testrealm@host.com",
        //                       qop="auth,auth-int",
        //                       nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
        //                       opaque="5ccc069c403ebaf9f0171e9517f40e41"
        // Authorization: Digest username="Mufasa",
        //                    realm="testrealm@host.com",
        //                    nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
        //                    uri="/dir/index.html",
        //                    qop=auth,
        //                    nc=00000001,
        //                    cnonce="0a4f113b",
        //                    response="6629fae49393a05397450978507c4ef1",
        //                    opaque="5ccc069c403ebaf9f0171e9517f40e41"
        // HA1 = MD5( "Mufasa:testrealm@host.com:Circle Of Life" )
        //      = 939e7578ed9e3c518a452acee763bce9
        //
        //  HA2 = MD5( "GET:/dir/index.html" )
        //      = 39aff3a2bab6126f332b942af96d3366
        //
        //  Response = MD5( "939e7578ed9e3c518a452acee763bce9:\
        //                   dcd98b7102dd2f0e8b11d0f600bfb0c093:\
        //                   00000001:0a4f113b:auth:\
        //                   39aff3a2bab6126f332b942af96d3366" )
        //           = 6629fae49393a05397450978507c4ef1
        userpass = userpass.split(":");

        let nc = String(++NC);
        nc = NC_PAD.substring(nc.length) + nc;
        const cnonce = crypto.randomBytes(8).toString("hex");

        const ha1 = md5(userpass[0] + ":" + opts.realm + ":" + userpass[1]);
        const ha2 = md5(method.toUpperCase() + ":" + uri);
        let s = ha1 + ":" + opts.nonce;
        if (qop) {
          qop = qop.split(",")[0];
          s += ":" + nc + ":" + cnonce + ":" + qop;
        }
        s += ":" + ha2;
        const response = md5(s);
        let authstring =
          'Digest username="' +
          userpass[0] +
          '", realm="' +
          opts.realm +
          '", nonce="' +
          opts.nonce +
          '", uri="' +
          uri +
          '", response="' +
          response +
          '"';
        if (opts.opaque) {
          authstring += ', opaque="' + opts.opaque + '"';
        }
        if (qop) {
          authstring += ", qop=" + qop + ", nc=" + nc + ', cnonce="' + cnonce + '"';
        }
        return authstring;
      }

      module.exports = digestAuthHeader;

      /***/
    },

    /***/ 4401: /***/ (module) => {
      "use strict";
      /*!
       * ee-first
       * Copyright(c) 2014 Jonathan Ong
       * MIT Licensed
       */

      /**
       * Module exports.
       * @public
       */

      module.exports = first;

      /**
       * Get the first event in a set of event emitters and event pairs.
       *
       * @param {array} stuff
       * @param {function} done
       * @public
       */

      function first(stuff, done) {
        if (!Array.isArray(stuff)) throw new TypeError("arg must be an array of [ee, events...] arrays");

        var cleanups = [];

        for (var i = 0; i < stuff.length; i++) {
          var arr = stuff[i];

          if (!Array.isArray(arr) || arr.length < 2) throw new TypeError("each array member must be [ee, events...]");

          var ee = arr[0];

          for (var j = 1; j < arr.length; j++) {
            var event = arr[j];
            var fn = listener(event, callback);

            // listen to the event
            ee.on(event, fn);
            // push this listener to the list of cleanups
            cleanups.push({
              ee: ee,
              event: event,
              fn: fn
            });
          }
        }

        function callback() {
          cleanup();
          done.apply(null, arguments);
        }

        function cleanup() {
          var x;
          for (var i = 0; i < cleanups.length; i++) {
            x = cleanups[i];
            x.ee.removeListener(x.event, x.fn);
          }
        }

        function thunk(fn) {
          done = fn;
        }

        thunk.cancel = cleanup;

        return thunk;
      }

      /**
       * Create the event listener.
       * @private
       */

      function listener(event, done) {
        return function onevent(arg1) {
          var args = new Array(arguments.length);
          var ee = this;
          var err = event === "error" ? arg1 : null;

          // copy args to prevent arguments escaping scope
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }

          done(err, ee, event, args);
        };
      }

      /***/
    },

    /***/ 1205: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var once = __nccwpck_require__(1223);

      var noop = function () {};

      var isRequest = function (stream) {
        return stream.setHeader && typeof stream.abort === "function";
      };

      var isChildProcess = function (stream) {
        return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
      };

      var eos = function (stream, opts, callback) {
        if (typeof opts === "function") return eos(stream, null, opts);
        if (!opts) opts = {};

        callback = once(callback || noop);

        var ws = stream._writableState;
        var rs = stream._readableState;
        var readable = opts.readable || (opts.readable !== false && stream.readable);
        var writable = opts.writable || (opts.writable !== false && stream.writable);
        var cancelled = false;

        var onlegacyfinish = function () {
          if (!stream.writable) onfinish();
        };

        var onfinish = function () {
          writable = false;
          if (!readable) callback.call(stream);
        };

        var onend = function () {
          readable = false;
          if (!writable) callback.call(stream);
        };

        var onexit = function (exitCode) {
          callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
        };

        var onerror = function (err) {
          callback.call(stream, err);
        };

        var onclose = function () {
          process.nextTick(onclosenexttick);
        };

        var onclosenexttick = function () {
          if (cancelled) return;
          if (readable && !(rs && rs.ended && !rs.destroyed))
            return callback.call(stream, new Error("premature close"));
          if (writable && !(ws && ws.ended && !ws.destroyed))
            return callback.call(stream, new Error("premature close"));
        };

        var onrequest = function () {
          stream.req.on("finish", onfinish);
        };

        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req) onrequest();
          else stream.on("request", onrequest);
        } else if (writable && !ws) {
          // legacy streams
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }

        if (isChildProcess(stream)) stream.on("exit", onexit);

        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false) stream.on("error", onerror);
        stream.on("close", onclose);

        return function () {
          cancelled = true;
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req) stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("exit", onexit);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      };

      module.exports = eos;

      /***/
    },

    /***/ 4070: /***/ (module) => {
      "use strict";
      /*!
       * escape-html
       * Copyright(c) 2012-2013 TJ Holowaychuk
       * Copyright(c) 2015 Andreas Lubbe
       * Copyright(c) 2015 Tiancheng "Timothy" Gu
       * MIT Licensed
       */

      /**
       * Module variables.
       * @private
       */

      var matchHtmlRegExp = /["'&<>]/;

      /**
       * Module exports.
       * @public
       */

      module.exports = escapeHtml;

      /**
       * Escape special characters in the given string of html.
       *
       * @param  {string} string The string to escape for inserting into HTML
       * @return {string}
       * @public
       */

      function escapeHtml(string) {
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);

        if (!match) {
          return str;
        }

        var escape;
        var html = "";
        var index = 0;
        var lastIndex = 0;

        for (index = match.index; index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34: // "
              escape = "&quot;";
              break;
            case 38: // &
              escape = "&amp;";
              break;
            case 39: // '
              escape = "&#39;";
              break;
            case 60: // <
              escape = "&lt;";
              break;
            case 62: // >
              escape = "&gt;";
              break;
            default:
              continue;
          }

          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }

          lastIndex = index + 1;
          html += escape;
        }

        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }

      /***/
    },

    /***/ 7512: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var isObject = __nccwpck_require__(429);

      module.exports = function extend(o /*, objects*/) {
        if (!isObject(o)) {
          o = {};
        }

        var len = arguments.length;
        for (var i = 1; i < len; i++) {
          var obj = arguments[i];

          if (isObject(obj)) {
            assign(o, obj);
          }
        }
        return o;
      };

      function assign(a, b) {
        for (var key in b) {
          if (hasOwn(b, key)) {
            a[key] = b[key];
          }
        }
      }

      /**
       * Returns true if the given `key` is an own property of `obj`.
       */

      function hasOwn(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }

      /***/
    },

    /***/ 5454: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /**
 * Data format:
 *

--FormStreamBoundary1349886663601\r\n
Content-Disposition: form-data; name="foo"\r\n
\r\n
<FIELD-CONTENT>\r\n
--FormStreamBoundary1349886663601\r\n
Content-Disposition: form-data; name="file"; filename="formstream.test.js"\r\n
Content-Type: application/javascript\r\n
\r\n
<FILE-CONTENT>\r\n
--FormStreamBoundary1349886663601\r\n
Content-Disposition: form-data; name="pic"; filename="fawave.png"\r\n
Content-Type: image/png\r\n
\r\n
<IMAGE-CONTENT>\r\n
--FormStreamBoundary1349886663601--

 *
 */

      var Stream = __nccwpck_require__(2781);
      var parseStream = __nccwpck_require__(1473);
      var util = __nccwpck_require__(3837);
      var mime = __nccwpck_require__(9994);
      var path = __nccwpck_require__(1017);
      var fs = __nccwpck_require__(7147);
      var destroy = __nccwpck_require__(3225);

      var PADDING = "--";
      var NEW_LINE = "\r\n";
      var NEW_LINE_BUFFER = Buffer.from(NEW_LINE);

      function FormStream() {
        if (!(this instanceof FormStream)) {
          return new FormStream();
        }

        FormStream.super_.call(this);

        this._boundary = this._generateBoundary();
        this._streams = [];
        this._buffers = [];
        this._endData = Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE);
        this._contentLength = 0;
        this._isAllStreamSizeKnown = true;
        this._knownStreamSize = 0;
      }

      util.inherits(FormStream, Stream);
      module.exports = FormStream;

      FormStream.prototype._generateBoundary = function () {
        // https://github.com/felixge/node-form-data/blob/master/lib/form_data.js#L162
        // This generates a 50 character boundary similar to those used by Firefox.
        // They are optimized for boyer-moore parsing.
        var boundary = "--------------------------";
        for (var i = 0; i < 24; i++) {
          boundary += Math.floor(Math.random() * 10).toString(16);
        }

        return boundary;
      };

      FormStream.prototype.setTotalStreamSize = function (size) {
        // this method should not make any sense if the length of each stream is known.
        if (this._isAllStreamSizeKnown) {
          return this;
        }

        size = size || 0;

        for (var i = 0; i < this._streams.length; i++) {
          size += this._streams[i][0].length;
          size += NEW_LINE_BUFFER.length; // stream field end pedding size
        }

        this._knownStreamSize = size;
        this._isAllStreamSizeKnown = true;

        return this;
      };

      FormStream.prototype.headers = function (options) {
        var headers = {
          "Content-Type": "multipart/form-data; boundary=" + this._boundary
        };

        // calculate total stream size
        this._contentLength += this._knownStreamSize;

        // calculate length of end padding
        this._contentLength += this._endData.length;

        if (this._isAllStreamSizeKnown) {
          headers["Content-Length"] = String(this._contentLength);
        }

        if (options) {
          for (var k in options) {
            headers[k] = options[k];
          }
        }

        return headers;
      };

      FormStream.prototype.file = function (name, filepath, filename, filesize) {
        var mimeType = mime.getType(filepath);

        if (typeof filename === "number" && !filesize) {
          filesize = filename;
          filename = path.basename(filepath);
        } else if (!filename) {
          filename = path.basename(filepath);
        }

        var stream = fs.createReadStream(filepath);

        return this.stream(name, stream, filename, mimeType, filesize);
      };

      /**
       * Add a form field
       * @param  {String} name field name
       * @param  {String|Buffer} value field value
       * @return {this}
       */
      FormStream.prototype.field = function (name, value) {
        if (!Buffer.isBuffer(value)) {
          // field(String, Number)
          // https://github.com/qiniu/nodejs-sdk/issues/123
          if (typeof value === "number") {
            value = String(value);
          }
          value = Buffer.from(value);
        }
        return this.buffer(name, value);
      };

      FormStream.prototype.stream = function (name, stream, filename, mimeType, size) {
        if (typeof mimeType === "number" && !size) {
          size = mimeType;
          mimeType = mime.getType(filename);
        } else if (!mimeType) {
          mimeType = mime.getType(filename);
        }

        stream.once("error", this.emit.bind(this, "error"));
        // if form stream destroy, also destroy the source stream
        this.once("destroy", function () {
          destroy(stream);
        });

        var leading = this._leading({ name: name, filename: filename }, mimeType);

        var ps = parseStream().pause();
        stream.pipe(ps);

        this._streams.push([leading, ps]);

        // if the size of this stream is known, plus the total content-length;
        // otherwise, content-length is unknown.
        if (typeof size === "number") {
          this._knownStreamSize += leading.length;
          this._knownStreamSize += size;
          this._knownStreamSize += NEW_LINE_BUFFER.length;
        } else {
          this._isAllStreamSizeKnown = false;
        }

        process.nextTick(this.resume.bind(this));

        return this;
      };

      FormStream.prototype.buffer = function (name, buffer, filename, mimeType) {
        if (filename && !mimeType) {
          mimeType = mime.getType(filename);
        }

        var disposition = { name: name };
        if (filename) {
          disposition.filename = filename;
        }

        var leading = this._leading(disposition, mimeType);

        this._buffers.push([leading, buffer]);

        // plus buffer length to total content-length
        this._contentLength += leading.length;
        this._contentLength += buffer.length;
        this._contentLength += NEW_LINE_BUFFER.length;

        process.nextTick(this.resume.bind(this));

        return this;
      };

      FormStream.prototype._leading = function (disposition, type) {
        var leading = [PADDING + this._boundary];

        var disps = [];

        if (disposition) {
          for (var k in disposition) {
            disps.push(k + '="' + disposition[k] + '"');
          }
        }

        leading.push("Content-Disposition: form-data; " + disps.join("; "));

        if (type) {
          leading.push("Content-Type: " + type);
        }

        leading.push("");
        leading.push("");

        return Buffer.from(leading.join(NEW_LINE));
      };

      FormStream.prototype._emitBuffers = function () {
        if (!this._buffers.length) {
          return;
        }

        for (var i = 0; i < this._buffers.length; i++) {
          var item = this._buffers[i];
          this.emit("data", item[0]); // part leading
          this.emit("data", item[1]); // part content
          this.emit("data", NEW_LINE_BUFFER);
        }

        this._buffers = [];
      };

      FormStream.prototype._emitStream = function (item) {
        var self = this;
        // item: [ fieldData, stream ]
        self.emit("data", item[0]);

        var stream = item[1];
        stream.on("data", function (data) {
          self.emit("data", data);
        });
        stream.on("end", function () {
          self.emit("data", NEW_LINE_BUFFER);
          return process.nextTick(self.drain.bind(self));
        });
        stream.resume();
      };

      FormStream.prototype._emitEnd = function () {
        // ending format:
        //
        // --{boundary}--\r\n
        this.emit("data", this._endData);
        this.emit("end");
      };

      FormStream.prototype.drain = function () {
        this._emitBuffers();

        var item = this._streams.shift();
        if (item) {
          this._emitStream(item);
        } else {
          this._emitEnd();
        }

        return this;
      };

      FormStream.prototype.resume = function () {
        this.paused = false;

        if (!this._draining) {
          this._draining = true;
          this.drain();
        }

        return this;
      };

      FormStream.prototype.close = FormStream.prototype.destroy = function () {
        this.emit("destroy");
      };

      /***/
    },

    /***/ 9320: /***/ (module) => {
      "use strict";

      /* eslint no-invalid-this: 1 */

      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";

      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);

        var bound;
        var binder = function () {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }

        bound = Function(
          "binder",
          "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }"
        )(binder);

        if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }

        return bound;
      };

      /***/
    },

    /***/ 8334: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var implementation = __nccwpck_require__(9320);

      module.exports = Function.prototype.bind || implementation;

      /***/
    },

    /***/ 4538: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var undefined;

      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;

      // eslint-disable-next-line consistent-return
      var getEvalledConstructor = function (expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {}
      };

      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null; // this is IE 8, which has a broken gOPD
        }
      }

      var throwTypeError = function () {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD
        ? (function () {
            try {
              // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
              arguments.callee; // IE 8 does not throw here
              return throwTypeError;
            } catch (calleeThrows) {
              try {
                // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                return $gOPD(arguments, "callee").get;
              } catch (gOPDthrows) {
                return throwTypeError;
              }
            }
          })()
        : throwTypeError;

      var hasSymbols = __nccwpck_require__(587)();
      var hasProto = __nccwpck_require__(5894)();

      var getProto =
        Object.getPrototypeOf ||
        (hasProto
          ? function (x) {
              return x.__proto__;
            } // eslint-disable-line no-proto
          : null);

      var needsEval = {};

      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined : getProto(Uint8Array);

      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
        "%AsyncFromSyncIteratorPrototype%": undefined,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval, // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
        "%JSON%": typeof JSON === "object" ? JSON : undefined,
        "%Map%": typeof Map === "undefined" ? undefined : Map,
        "%MapIteratorPrototype%":
          typeof Map === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined : Set,
        "%SetIteratorPrototype%":
          typeof Set === "undefined" || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined,
        "%Symbol%": hasSymbols ? Symbol : undefined,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined : WeakSet
      };

      if (getProto) {
        try {
          null.error; // eslint-disable-line no-unused-expressions
        } catch (e) {
          // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
          var errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }

      var doEval = function doEval(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }

        INTRINSICS[name] = value;

        return value;
      };

      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };

      var bind = __nccwpck_require__(8334);
      var hasOwn = __nccwpck_require__(6339);
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);

      /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
      var rePropName =
        /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
      var stringToPath = function stringToPath(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function (match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      /* end adaptation */

      var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }

        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }

          return {
            alias: alias,
            name: intrinsicName,
            value: value
          };
        }

        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };

      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }

        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";

        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;

        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }

        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if (
            (first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") &&
            first !== last
          ) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }

          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";

          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;

              // By convention, when a data property is converted to an accessor
              // property to emulate a data property that does not suffer from
              // the override mistake, that accessor's getter is marked with
              // an `originalValue` property. Here, when we detect this, we
              // uphold the illusion by pretending to see that original data
              // property, i.e., returning the value rather than the getter
              // itself.
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }

            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };

      /***/
    },

    /***/ 5284: /***/ (module) => {
      "use strict";

      function ready(flagOrFunction) {
        this._ready = !!this._ready;
        this._readyCallbacks = this._readyCallbacks || [];

        if (arguments.length === 0) {
          // return a promise
          // support `this.ready().then(onready);` and `yield this.ready()`;
          return new Promise(
            function (resolve) {
              if (this._ready) {
                return resolve();
              }
              this._readyCallbacks.push(resolve);
            }.bind(this)
          );
        } else if (typeof flagOrFunction === "function") {
          this._readyCallbacks.push(flagOrFunction);
        } else {
          this._ready = !!flagOrFunction;
        }

        if (this._ready) {
          this._readyCallbacks.splice(0, Infinity).forEach(function (callback) {
            process.nextTick(callback);
          });
        }
      }

      function mixin(object) {
        object.ready = ready;
      }

      module.exports = mixin;
      module.exports.mixin = mixin;

      /***/
    },

    /***/ 8173: /***/ (module) => {
      "use strict";

      module.exports = clone;

      var getPrototypeOf =
        Object.getPrototypeOf ||
        function (obj) {
          return obj.__proto__;
        };

      function clone(obj) {
        if (obj === null || typeof obj !== "object") return obj;

        if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) };
        else var copy = Object.create(null);

        Object.getOwnPropertyNames(obj).forEach(function (key) {
          Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        });

        return copy;
      }

      /***/
    },

    /***/ 7758: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var fs = __nccwpck_require__(7147);
      var polyfills = __nccwpck_require__(263);
      var legacy = __nccwpck_require__(3086);
      var clone = __nccwpck_require__(8173);

      var util = __nccwpck_require__(3837);

      /* istanbul ignore next - node 0.x polyfill */
      var gracefulQueue;
      var previousSymbol;

      /* istanbul ignore else - node 0.x polyfill */
      if (typeof Symbol === "function" && typeof Symbol.for === "function") {
        gracefulQueue = Symbol.for("graceful-fs.queue");
        // This is used in testing by future versions
        previousSymbol = Symbol.for("graceful-fs.previous");
      } else {
        gracefulQueue = "___graceful-fs.queue";
        previousSymbol = "___graceful-fs.previous";
      }

      function noop() {}

      function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
          get: function () {
            return queue;
          }
        });
      }

      var debug = noop;
      if (util.debuglog) debug = util.debuglog("gfs4");
      else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
        debug = function () {
          var m = util.format.apply(util, arguments);
          m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
          console.error(m);
        };

      // Once time initialization
      if (!fs[gracefulQueue]) {
        // This queue can be shared by multiple loaded instances
        var queue = global[gracefulQueue] || [];
        publishQueue(fs, queue);

        // Patch fs.close/closeSync to shared queue version, because we need
        // to retry() whenever a close happens *anywhere* in the program.
        // This is essential when multiple graceful-fs instances are
        // in play at the same time.
        fs.close = (function (fs$close) {
          function close(fd, cb) {
            return fs$close.call(fs, fd, function (err) {
              // This function uses the graceful-fs shared queue
              if (!err) {
                resetQueue();
              }

              if (typeof cb === "function") cb.apply(this, arguments);
            });
          }

          Object.defineProperty(close, previousSymbol, {
            value: fs$close
          });
          return close;
        })(fs.close);

        fs.closeSync = (function (fs$closeSync) {
          function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
          }

          Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
          });
          return closeSync;
        })(fs.closeSync);

        if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
          process.on("exit", function () {
            debug(fs[gracefulQueue]);
            __nccwpck_require__(9491).equal(fs[gracefulQueue].length, 0);
          });
        }
      }

      if (!global[gracefulQueue]) {
        publishQueue(global, fs[gracefulQueue]);
      }

      module.exports = patch(clone(fs));
      if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
        module.exports = patch(fs);
        fs.__patched = true;
      }

      function patch(fs) {
        // Everything that references the open() function needs to be in here
        polyfills(fs);
        fs.gracefulify = patch;

        fs.createReadStream = createReadStream;
        fs.createWriteStream = createWriteStream;
        var fs$readFile = fs.readFile;
        fs.readFile = readFile;
        function readFile(path, options, cb) {
          if (typeof options === "function") (cb = options), (options = null);

          return go$readFile(path, options, cb);

          function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function (err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (typeof cb === "function") cb.apply(this, arguments);
              }
            });
          }
        }

        var fs$writeFile = fs.writeFile;
        fs.writeFile = writeFile;
        function writeFile(path, data, options, cb) {
          if (typeof options === "function") (cb = options), (options = null);

          return go$writeFile(path, data, options, cb);

          function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function (err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (typeof cb === "function") cb.apply(this, arguments);
              }
            });
          }
        }

        var fs$appendFile = fs.appendFile;
        if (fs$appendFile) fs.appendFile = appendFile;
        function appendFile(path, data, options, cb) {
          if (typeof options === "function") (cb = options), (options = null);

          return go$appendFile(path, data, options, cb);

          function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function (err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (typeof cb === "function") cb.apply(this, arguments);
              }
            });
          }
        }

        var fs$copyFile = fs.copyFile;
        if (fs$copyFile) fs.copyFile = copyFile;
        function copyFile(src, dest, flags, cb) {
          if (typeof flags === "function") {
            cb = flags;
            flags = 0;
          }
          return go$copyFile(src, dest, flags, cb);

          function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function (err) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (typeof cb === "function") cb.apply(this, arguments);
              }
            });
          }
        }

        var fs$readdir = fs.readdir;
        fs.readdir = readdir;
        var noReaddirOptionVersions = /^v[0-5]\./;
        function readdir(path, options, cb) {
          if (typeof options === "function") (cb = options), (options = null);

          var go$readdir = noReaddirOptionVersions.test(process.version)
            ? function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
              }
            : function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
              };

          return go$readdir(path, options, cb);

          function fs$readdirCallback(path, options, cb, startTime) {
            return function (err, files) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$readdir, [path, options, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (files && files.sort) files.sort();

                if (typeof cb === "function") cb.call(this, err, files);
              }
            };
          }
        }

        if (process.version.substr(0, 4) === "v0.8") {
          var legStreams = legacy(fs);
          ReadStream = legStreams.ReadStream;
          WriteStream = legStreams.WriteStream;
        }

        var fs$ReadStream = fs.ReadStream;
        if (fs$ReadStream) {
          ReadStream.prototype = Object.create(fs$ReadStream.prototype);
          ReadStream.prototype.open = ReadStream$open;
        }

        var fs$WriteStream = fs.WriteStream;
        if (fs$WriteStream) {
          WriteStream.prototype = Object.create(fs$WriteStream.prototype);
          WriteStream.prototype.open = WriteStream$open;
        }

        Object.defineProperty(fs, "ReadStream", {
          get: function () {
            return ReadStream;
          },
          set: function (val) {
            ReadStream = val;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(fs, "WriteStream", {
          get: function () {
            return WriteStream;
          },
          set: function (val) {
            WriteStream = val;
          },
          enumerable: true,
          configurable: true
        });

        // legacy names
        var FileReadStream = ReadStream;
        Object.defineProperty(fs, "FileReadStream", {
          get: function () {
            return FileReadStream;
          },
          set: function (val) {
            FileReadStream = val;
          },
          enumerable: true,
          configurable: true
        });
        var FileWriteStream = WriteStream;
        Object.defineProperty(fs, "FileWriteStream", {
          get: function () {
            return FileWriteStream;
          },
          set: function (val) {
            FileWriteStream = val;
          },
          enumerable: true,
          configurable: true
        });

        function ReadStream(path, options) {
          if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
          else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }

        function ReadStream$open() {
          var that = this;
          open(that.path, that.flags, that.mode, function (err, fd) {
            if (err) {
              if (that.autoClose) that.destroy();

              that.emit("error", err);
            } else {
              that.fd = fd;
              that.emit("open", fd);
              that.read();
            }
          });
        }

        function WriteStream(path, options) {
          if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
          else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }

        function WriteStream$open() {
          var that = this;
          open(that.path, that.flags, that.mode, function (err, fd) {
            if (err) {
              that.destroy();
              that.emit("error", err);
            } else {
              that.fd = fd;
              that.emit("open", fd);
            }
          });
        }

        function createReadStream(path, options) {
          return new fs.ReadStream(path, options);
        }

        function createWriteStream(path, options) {
          return new fs.WriteStream(path, options);
        }

        var fs$open = fs.open;
        fs.open = open;
        function open(path, flags, mode, cb) {
          if (typeof mode === "function") (cb = mode), (mode = null);

          return go$open(path, flags, mode, cb);

          function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function (err, fd) {
              if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()]);
              else {
                if (typeof cb === "function") cb.apply(this, arguments);
              }
            });
          }
        }

        return fs;
      }

      function enqueue(elem) {
        debug("ENQUEUE", elem[0].name, elem[1]);
        fs[gracefulQueue].push(elem);
        retry();
      }

      // keep track of the timeout between retry() calls
      var retryTimer;

      // reset the startTime and lastTime to now
      // this resets the start of the 60 second overall timeout as well as the
      // delay between attempts so that we'll retry these jobs sooner
      function resetQueue() {
        var now = Date.now();
        for (var i = 0; i < fs[gracefulQueue].length; ++i) {
          // entries that are only a length of 2 are from an older version, don't
          // bother modifying those since they'll be retried anyway.
          if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now; // startTime
            fs[gracefulQueue][i][4] = now; // lastTime
          }
        }
        // call retry to make sure we're actively processing the queue
        retry();
      }

      function retry() {
        // clear the timer and remove it to help prevent unintended concurrency
        clearTimeout(retryTimer);
        retryTimer = undefined;

        if (fs[gracefulQueue].length === 0) return;

        var elem = fs[gracefulQueue].shift();
        var fn = elem[0];
        var args = elem[1];
        // these items may be unset if they were added by an older graceful-fs
        var err = elem[2];
        var startTime = elem[3];
        var lastTime = elem[4];

        // if we don't have a startTime we have no way of knowing if we've waited
        // long enough, so go ahead and retry this item now
        if (startTime === undefined) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args);
        } else if (Date.now() - startTime >= 60000) {
          // it's been more than 60 seconds total, bail now
          debug("TIMEOUT", fn.name, args);
          var cb = args.pop();
          if (typeof cb === "function") cb.call(null, err);
        } else {
          // the amount of time between the last attempt and right now
          var sinceAttempt = Date.now() - lastTime;
          // the amount of time between when we first tried, and when we last tried
          // rounded up to at least 1
          var sinceStart = Math.max(lastTime - startTime, 1);
          // backoff. wait longer than the total time we've been retrying, but only
          // up to a maximum of 100ms
          var desiredDelay = Math.min(sinceStart * 1.2, 100);
          // it's been long enough since the last retry, do it again
          if (sinceAttempt >= desiredDelay) {
            debug("RETRY", fn.name, args);
            fn.apply(null, args.concat([startTime]));
          } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
          }
        }

        // schedule our next run if one isn't already scheduled
        if (retryTimer === undefined) {
          retryTimer = setTimeout(retry, 0);
        }
      }

      /***/
    },

    /***/ 3086: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var Stream = __nccwpck_require__(2781).Stream;

      module.exports = legacy;

      function legacy(fs) {
        return {
          ReadStream: ReadStream,
          WriteStream: WriteStream
        };

        function ReadStream(path, options) {
          if (!(this instanceof ReadStream)) return new ReadStream(path, options);

          Stream.call(this);

          var self = this;

          this.path = path;
          this.fd = null;
          this.readable = true;
          this.paused = false;

          this.flags = "r";
          this.mode = 438; /*=0666*/
          this.bufferSize = 64 * 1024;

          options = options || {};

          // Mixin options into this
          var keys = Object.keys(options);
          for (var index = 0, length = keys.length; index < length; index++) {
            var key = keys[index];
            this[key] = options[key];
          }

          if (this.encoding) this.setEncoding(this.encoding);

          if (this.start !== undefined) {
            if ("number" !== typeof this.start) {
              throw TypeError("start must be a Number");
            }
            if (this.end === undefined) {
              this.end = Infinity;
            } else if ("number" !== typeof this.end) {
              throw TypeError("end must be a Number");
            }

            if (this.start > this.end) {
              throw new Error("start must be <= end");
            }

            this.pos = this.start;
          }

          if (this.fd !== null) {
            process.nextTick(function () {
              self._read();
            });
            return;
          }

          fs.open(this.path, this.flags, this.mode, function (err, fd) {
            if (err) {
              self.emit("error", err);
              self.readable = false;
              return;
            }

            self.fd = fd;
            self.emit("open", fd);
            self._read();
          });
        }

        function WriteStream(path, options) {
          if (!(this instanceof WriteStream)) return new WriteStream(path, options);

          Stream.call(this);

          this.path = path;
          this.fd = null;
          this.writable = true;

          this.flags = "w";
          this.encoding = "binary";
          this.mode = 438; /*=0666*/
          this.bytesWritten = 0;

          options = options || {};

          // Mixin options into this
          var keys = Object.keys(options);
          for (var index = 0, length = keys.length; index < length; index++) {
            var key = keys[index];
            this[key] = options[key];
          }

          if (this.start !== undefined) {
            if ("number" !== typeof this.start) {
              throw TypeError("start must be a Number");
            }
            if (this.start < 0) {
              throw new Error("start must be >= zero");
            }

            this.pos = this.start;
          }

          this.busy = false;
          this._queue = [];

          if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
            this.flush();
          }
        }
      }

      /***/
    },

    /***/ 263: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var constants = __nccwpck_require__(2057);

      var origCwd = process.cwd;
      var cwd = null;

      var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

      process.cwd = function () {
        if (!cwd) cwd = origCwd.call(process);
        return cwd;
      };
      try {
        process.cwd();
      } catch (er) {}

      // This check is needed until node.js 12 is required
      if (typeof process.chdir === "function") {
        var chdir = process.chdir;
        process.chdir = function (d) {
          cwd = null;
          chdir.call(process, d);
        };
        if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
      }

      module.exports = patch;

      function patch(fs) {
        // (re-)implement some things that are known busted or missing.

        // lchmod, broken prior to 0.6.2
        // back-port the fix here.
        if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
          patchLchmod(fs);
        }

        // lutimes implementation, or no-op
        if (!fs.lutimes) {
          patchLutimes(fs);
        }

        // https://github.com/isaacs/node-graceful-fs/issues/4
        // Chown should not fail on einval or eperm if non-root.
        // It should not fail on enosys ever, as this just indicates
        // that a fs doesn't support the intended operation.

        fs.chown = chownFix(fs.chown);
        fs.fchown = chownFix(fs.fchown);
        fs.lchown = chownFix(fs.lchown);

        fs.chmod = chmodFix(fs.chmod);
        fs.fchmod = chmodFix(fs.fchmod);
        fs.lchmod = chmodFix(fs.lchmod);

        fs.chownSync = chownFixSync(fs.chownSync);
        fs.fchownSync = chownFixSync(fs.fchownSync);
        fs.lchownSync = chownFixSync(fs.lchownSync);

        fs.chmodSync = chmodFixSync(fs.chmodSync);
        fs.fchmodSync = chmodFixSync(fs.fchmodSync);
        fs.lchmodSync = chmodFixSync(fs.lchmodSync);

        fs.stat = statFix(fs.stat);
        fs.fstat = statFix(fs.fstat);
        fs.lstat = statFix(fs.lstat);

        fs.statSync = statFixSync(fs.statSync);
        fs.fstatSync = statFixSync(fs.fstatSync);
        fs.lstatSync = statFixSync(fs.lstatSync);

        // if lchmod/lchown do not exist, then make them no-ops
        if (fs.chmod && !fs.lchmod) {
          fs.lchmod = function (path, mode, cb) {
            if (cb) process.nextTick(cb);
          };
          fs.lchmodSync = function () {};
        }
        if (fs.chown && !fs.lchown) {
          fs.lchown = function (path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
          };
          fs.lchownSync = function () {};
        }

        // on Windows, A/V software can lock the directory, causing this
        // to fail with an EACCES or EPERM if the directory contains newly
        // created files.  Try again on failure, for up to 60 seconds.

        // Set the timeout this long because some Windows Anti-Virus, such as Parity
        // bit9, may lock files for up to a minute, causing npm package install
        // failures. Also, take care to yield the scheduler. Windows scheduling gives
        // CPU to a busy looping process, which can cause the program causing the lock
        // contention to be starved of CPU by node, so the contention doesn't resolve.
        if (platform === "win32") {
          fs.rename =
            typeof fs.rename !== "function"
              ? fs.rename
              : (function (fs$rename) {
                  function rename(from, to, cb) {
                    var start = Date.now();
                    var backoff = 0;
                    fs$rename(from, to, function CB(er) {
                      if (
                        er &&
                        (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") &&
                        Date.now() - start < 60000
                      ) {
                        setTimeout(function () {
                          fs.stat(to, function (stater, st) {
                            if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                            else cb(er);
                          });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                      }
                      if (cb) cb(er);
                    });
                  }
                  if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
                  return rename;
                })(fs.rename);
        }

        // if read() returns EAGAIN, then just try it again.
        fs.read =
          typeof fs.read !== "function"
            ? fs.read
            : (function (fs$read) {
                function read(fd, buffer, offset, length, position, callback_) {
                  var callback;
                  if (callback_ && typeof callback_ === "function") {
                    var eagCounter = 0;
                    callback = function (er, _, __) {
                      if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                      }
                      callback_.apply(this, arguments);
                    };
                  }
                  return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                }

                // This ensures `util.promisify` works as it does for native `fs.read`.
                if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
                return read;
              })(fs.read);

        fs.readSync =
          typeof fs.readSync !== "function"
            ? fs.readSync
            : (function (fs$readSync) {
                return function (fd, buffer, offset, length, position) {
                  var eagCounter = 0;
                  while (true) {
                    try {
                      return fs$readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                      if (er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        continue;
                      }
                      throw er;
                    }
                  }
                };
              })(fs.readSync);

        function patchLchmod(fs) {
          fs.lchmod = function (path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              // prefer to return the chmod error, if one occurs,
              // but still try to close, and report closing errors if they occur.
              fs.fchmod(fd, mode, function (err) {
                fs.close(fd, function (err2) {
                  if (callback) callback(err || err2);
                });
              });
            });
          };

          fs.lchmodSync = function (path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
              ret = fs.fchmodSync(fd, mode);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs.closeSync(fd);
                } catch (er) {}
              } else {
                fs.closeSync(fd);
              }
            }
            return ret;
          };
        }

        function patchLutimes(fs) {
          if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function (path, at, mt, cb) {
              fs.open(path, constants.O_SYMLINK, function (er, fd) {
                if (er) {
                  if (cb) cb(er);
                  return;
                }
                fs.futimes(fd, at, mt, function (er) {
                  fs.close(fd, function (er2) {
                    if (cb) cb(er || er2);
                  });
                });
              });
            };

            fs.lutimesSync = function (path, at, mt) {
              var fd = fs.openSync(path, constants.O_SYMLINK);
              var ret;
              var threw = true;
              try {
                ret = fs.futimesSync(fd, at, mt);
                threw = false;
              } finally {
                if (threw) {
                  try {
                    fs.closeSync(fd);
                  } catch (er) {}
                } else {
                  fs.closeSync(fd);
                }
              }
              return ret;
            };
          } else if (fs.futimes) {
            fs.lutimes = function (_a, _b, _c, cb) {
              if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function () {};
          }
        }

        function chmodFix(orig) {
          if (!orig) return orig;
          return function (target, mode, cb) {
            return orig.call(fs, target, mode, function (er) {
              if (chownErOk(er)) er = null;
              if (cb) cb.apply(this, arguments);
            });
          };
        }

        function chmodFixSync(orig) {
          if (!orig) return orig;
          return function (target, mode) {
            try {
              return orig.call(fs, target, mode);
            } catch (er) {
              if (!chownErOk(er)) throw er;
            }
          };
        }

        function chownFix(orig) {
          if (!orig) return orig;
          return function (target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function (er) {
              if (chownErOk(er)) er = null;
              if (cb) cb.apply(this, arguments);
            });
          };
        }

        function chownFixSync(orig) {
          if (!orig) return orig;
          return function (target, uid, gid) {
            try {
              return orig.call(fs, target, uid, gid);
            } catch (er) {
              if (!chownErOk(er)) throw er;
            }
          };
        }

        function statFix(orig) {
          if (!orig) return orig;
          // Older versions of Node erroneously returned signed integers for
          // uid + gid.
          return function (target, options, cb) {
            if (typeof options === "function") {
              cb = options;
              options = null;
            }
            function callback(er, stats) {
              if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
              }
              if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
          };
        }

        function statFixSync(orig) {
          if (!orig) return orig;
          // Older versions of Node erroneously returned signed integers for
          // uid + gid.
          return function (target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
              if (stats.uid < 0) stats.uid += 0x100000000;
              if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
          };
        }

        // ENOSYS means that the fs doesn't support the op. Just ignore
        // that, because it doesn't matter.
        //
        // if there's no getuid, or if getuid() is something other
        // than 0, and the error is EINVAL or EPERM, then just ignore
        // it.
        //
        // This specific case is a silent failure in cp, install, tar,
        // and most other unix tools that manage permissions.
        //
        // When running as root, or if other types of errors are
        // encountered, then it's strict.
        function chownErOk(er) {
          if (!er) return true;

          if (er.code === "ENOSYS") return true;

          var nonroot = !process.getuid || process.getuid() !== 0;
          if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
          }

          return false;
        }
      }

      /***/
    },

    /***/ 1621: /***/ (module) => {
      "use strict";

      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };

      /***/
    },

    /***/ 5894: /***/ (module) => {
      "use strict";

      var test = {
        foo: {}
      };

      var $Object = Object;

      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };

      /***/
    },

    /***/ 587: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = __nccwpck_require__(7747);

      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }

        return hasSymbolSham();
      };

      /***/
    },

    /***/ 7747: /***/ (module) => {
      "use strict";

      /* eslint complexity: [2, 18], max-statements: [2, 33] */
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }

        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }

        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }

        // temp disabled per https://github.com/ljharb/object.assign/issues/17
        // if (sym instanceof Symbol) { return false; }
        // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
        // if (!(symObj instanceof Symbol)) { return false; }

        // if (typeof Symbol.prototype.toString !== 'function') { return false; }
        // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }

        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }

        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }

        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }

        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }

        return true;
      };

      /***/
    },

    /***/ 6339: /***/ (module) => {
      "use strict";

      var hasOwnProperty = {}.hasOwnProperty;
      var call = Function.prototype.call;

      module.exports = call.bind
        ? call.bind(hasOwnProperty)
        : function (O, P) {
            return call.call(hasOwnProperty, O, P);
          };

      /***/
    },

    /***/ 845: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /*!
       * humanize-ms - index.js
       * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
       * MIT Licensed
       */

      /**
       * Module dependencies.
       */

      var util = __nccwpck_require__(3837);
      var ms = __nccwpck_require__(900);

      module.exports = function (t) {
        if (typeof t === "number") return t;
        var r = ms(t);
        if (r === undefined) {
          var err = new Error(util.format("humanize-ms(%j) result undefined", t));
          console.warn(err.stack);
        }
        return r;
      };

      /***/
    },

    /***/ 9695: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(5118).Buffer;

      // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
      // Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
      // To save memory and loading time, we read table files only when requested.

      exports._dbcs = DBCSCodec;

      var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1000,
        UNASSIGNED_NODE = new Array(0x100),
        DEF_CHAR = -1;

      for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

      // Class DBCSCodec reads and initializes mapping tables.
      function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions) throw new Error("DBCS codec is called without the data.");
        if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

        // Load tables.
        var mappingTable = codecOptions.table();

        // Decode tables: MBCS -> Unicode.

        // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
        // Trie root is decodeTables[0].
        // Values: >=  0 -> unicode character code. can be > 0xFFFF
        //         == UNASSIGNED -> unknown/unassigned sequence.
        //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
        //         <= NODE_START -> index of the next node in our trie to process next byte.
        //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

        // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here.
        this.decodeTableSeq = [];

        // Actual mapping tables consist of chunks. Use them to fill up decode tables.
        for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);

        this.defaultCharUnicode = iconv.defaultCharUnicode;

        // Encode tables: Unicode -> DBCS.

        // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
        // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
        // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
        //         == UNASSIGNED -> no conversion found. Output a default char.
        //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
        this.encodeTable = [];

        // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
        // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
        // means end of sequence (needed when one sequence is a strict subsequence of another).
        // Objects are kept separately from encodeTable to increase performance.
        this.encodeTableSeq = [];

        // Some chars can be decoded, but need not be encoded.
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals)
          for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === "number") skipEncodeChars[val] = true;
            else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
          }

        // Use decode trie to recursively fill out encode tables.
        this._fillEncodeTable(0, 0, skipEncodeChars);

        // Add more encoding pairs when needed.
        if (codecOptions.encodeAdd) {
          for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
              this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
        }

        this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

        // Load & create GB18030 tables when needed.
        if (typeof codecOptions.gb18030 === "function") {
          this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

          // Add GB18030 decode tables.
          var thirdByteNodeIdx = this.decodeTables.length;
          var thirdByteNode = (this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0));

          var fourthByteNodeIdx = this.decodeTables.length;
          var fourthByteNode = (this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0));

          for (var i = 0x81; i <= 0xfe; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
          }
          for (var i = 0x81; i <= 0xfe; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
          for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;
        }
      }

      DBCSCodec.prototype.encoder = DBCSEncoder;
      DBCSCodec.prototype.decoder = DBCSDecoder;

      // Decoder helpers
      DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
        var bytes = [];
        for (; addr > 0; addr >>= 8) bytes.push(addr & 0xff);
        if (bytes.length == 0) bytes.push(0);

        var node = this.decodeTables[0];
        for (var i = bytes.length - 1; i > 0; i--) {
          // Traverse nodes deeper into the trie.
          var val = node[bytes[i]];

          if (val == UNASSIGNED) {
            // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push((node = UNASSIGNED_NODE.slice(0)));
          } else if (val <= NODE_START) {
            // Existing node.
            node = this.decodeTables[NODE_START - val];
          } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
        }
        return node;
      };

      DBCSCodec.prototype._addDecodeChunk = function (chunk) {
        // First element of chunk is the hex mbcs code where we start.
        var curAddr = parseInt(chunk[0], 16);

        // Choose the decoding node where we'll write our chars.
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 0xff;

        // Write all other elements of the chunk to the table.
        for (var k = 1; k < chunk.length; k++) {
          var part = chunk[k];
          if (typeof part === "string") {
            // String, write as-is.
            for (var l = 0; l < part.length; ) {
              var code = part.charCodeAt(l++);
              if (0xd800 <= code && code < 0xdc00) {
                // Decode surrogate
                var codeTrail = part.charCodeAt(l++);
                if (0xdc00 <= codeTrail && codeTrail < 0xe000)
                  writeTable[curAddr++] = 0x10000 + (code - 0xd800) * 0x400 + (codeTrail - 0xdc00);
                else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
              } else if (0x0ff0 < code && code <= 0x0fff) {
                // Character sequence (our own encoding used)
                var len = 0xfff - code + 2;
                var seq = [];
                for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
              } else writeTable[curAddr++] = code; // Basic char
            }
          } else if (typeof part === "number") {
            // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
          } else
            throw new Error(
              "Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]
            );
        }
        if (curAddr > 0xff)
          throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
      };

      // Encoder helpers
      DBCSCodec.prototype._getEncodeBucket = function (uCode) {
        var high = uCode >> 8; // This could be > 0xFF because of astral characters.
        if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
        return this.encodeTable[high];
      };

      DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xff;
        if (bucket[low] <= SEQ_START)
          this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] =
            dbcsCode; // There's already a sequence, set a single-char subsequence of it.
        else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
      };

      DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
        // Get the root of character tree according to first character of the sequence.
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 0xff;

        var node;
        if (bucket[low] <= SEQ_START) {
          // There's already a sequence with  - use it.
          node = this.encodeTableSeq[SEQ_START - bucket[low]];
        } else {
          // There was no sequence object - allocate a new one.
          node = {};
          if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
          bucket[low] = SEQ_START - this.encodeTableSeq.length;
          this.encodeTableSeq.push(node);
        }

        // Traverse the character tree, allocating new nodes as needed.
        for (var j = 1; j < seq.length - 1; j++) {
          var oldVal = node[uCode];
          if (typeof oldVal === "object") node = oldVal;
          else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
          }
        }

        // Set the leaf to given dbcsCode.
        uCode = seq[seq.length - 1];
        node[uCode] = dbcsCode;
      };

      DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
        var node = this.decodeTables[nodeIdx];
        for (var i = 0; i < 0x100; i++) {
          var uCode = node[i];
          var mbCode = prefix + i;
          if (skipEncodeChars[mbCode]) continue;

          if (uCode >= 0) this._setEncodeChar(uCode, mbCode);
          else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
          else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        }
      };

      // == Encoder ==================================================================

      function DBCSEncoder(options, codec) {
        // Encoder state
        this.leadSurrogate = -1;
        this.seqObj = undefined;

        // Static data
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
      }

      DBCSEncoder.prototype.write = function (str) {
        var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;

        while (true) {
          // 0. Get next character.
          if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
          } else {
            var uCode = nextChar;
            nextChar = -1;
          }

          // 1. Handle surrogates.
          if (0xd800 <= uCode && uCode < 0xe000) {
            // Char is one of surrogates.
            if (uCode < 0xdc00) {
              // We've got lead surrogate.
              if (leadSurrogate === -1) {
                leadSurrogate = uCode;
                continue;
              } else {
                leadSurrogate = uCode;
                // Double lead surrogate found.
                uCode = UNASSIGNED;
              }
            } else {
              // We've got trail surrogate.
              if (leadSurrogate !== -1) {
                uCode = 0x10000 + (leadSurrogate - 0xd800) * 0x400 + (uCode - 0xdc00);
                leadSurrogate = -1;
              } else {
                // Incomplete surrogate pair - only trail surrogate found.
                uCode = UNASSIGNED;
              }
            }
          } else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode;
            uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
          }

          // 2. Convert uCode character.
          var dbcsCode = UNASSIGNED;
          if (seqObj !== undefined && uCode != UNASSIGNED) {
            // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === "object") {
              // Sequence continues.
              seqObj = resCode;
              continue;
            } else if (typeof resCode == "number") {
              // Sequence finished. Write it.
              dbcsCode = resCode;
            } else if (resCode == undefined) {
              // Current character is not part of the sequence.

              // Try default character for this sequence
              resCode = seqObj[DEF_CHAR];
              if (resCode !== undefined) {
                dbcsCode = resCode; // Found. Write it.
                nextChar = uCode; // Current character will be written too in the next iteration.
              } else {
                // TODO: What if we have no default? (resCode == undefined)
                // Then, we should write first char of the sequence as-is and try the rest recursively.
                // Didn't do it for now because no encoding has this situation yet.
                // Currently, just skip the sequence and write current char.
              }
            }
            seqObj = undefined;
          } else if (uCode >= 0) {
            // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xff];

            if (dbcsCode <= SEQ_START) {
              // Sequence start
              seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
              continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
              // Use GB18030 algorithm to find character(s) to write.
              var idx = findIdx(this.gb18030.uChars, uCode);
              if (idx != -1) {
                var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
                dbcsCode = dbcsCode % 12600;
                newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
                dbcsCode = dbcsCode % 1260;
                newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
                dbcsCode = dbcsCode % 10;
                newBuf[j++] = 0x30 + dbcsCode;
                continue;
              }
            }
          }

          // 3. Write dbcsCode character.
          if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;

          if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
          } else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8; // high byte
            newBuf[j++] = dbcsCode & 0xff; // low byte
          } else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xff;
            newBuf[j++] = dbcsCode & 0xff;
          }
        }

        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
      };

      DBCSEncoder.prototype.end = function () {
        if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

        var newBuf = Buffer.alloc(10),
          j = 0;

        if (this.seqObj) {
          // We're in the sequence.
          var dbcsCode = this.seqObj[DEF_CHAR];
          if (dbcsCode !== undefined) {
            // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
              newBuf[j++] = dbcsCode;
            } else {
              newBuf[j++] = dbcsCode >> 8; // high byte
              newBuf[j++] = dbcsCode & 0xff; // low byte
            }
          } else {
            // See todo above.
          }
          this.seqObj = undefined;
        }

        if (this.leadSurrogate !== -1) {
          // Incomplete surrogate pair - only lead surrogate found.
          newBuf[j++] = this.defaultCharSingleByte;
          this.leadSurrogate = -1;
        }

        return newBuf.slice(0, j);
      };

      // Export for testing
      DBCSEncoder.prototype.findIdx = findIdx;

      // == Decoder ==================================================================

      function DBCSDecoder(options, codec) {
        // Decoder state
        this.nodeIdx = 0;
        this.prevBuf = Buffer.alloc(0);

        // Static data
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
      }

      DBCSDecoder.prototype.write = function (buf) {
        var newBuf = Buffer.alloc(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBuf = this.prevBuf,
          prevBufOffset = this.prevBuf.length,
          seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
          uCode;

        if (prevBufOffset > 0)
          // Make prev buf overlap a little to make it easier to slice later.
          prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);

        for (var i = 0, j = 0; i < buf.length; i++) {
          var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

          // Lookup in current trie node.
          var uCode = this.decodeTables[nodeIdx][curByte];

          if (uCode >= 0) {
            // Normal character, just use it.
          } else if (uCode === UNASSIGNED) {
            // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
          } else if (uCode === GB18030_CODE) {
            var curSeq =
              seqStart >= 0
                ? buf.slice(seqStart, i + 1)
                : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
            var ptr =
              (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
          } else if (uCode <= NODE_START) {
            // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
          } else if (uCode <= SEQ_START) {
            // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
              uCode = seq[k];
              newBuf[j++] = uCode & 0xff;
              newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
          } else
            throw new Error(
              "iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte
            );

          // Write the character to buffer, handling higher planes using surrogate pair.
          if (uCode > 0xffff) {
            uCode -= 0x10000;
            var uCodeLead = 0xd800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xff;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xdc00 + (uCode % 0x400);
          }
          newBuf[j++] = uCode & 0xff;
          newBuf[j++] = uCode >> 8;

          // Reset trie node.
          nodeIdx = 0;
          seqStart = i + 1;
        }

        this.nodeIdx = nodeIdx;
        this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
        return newBuf.slice(0, j).toString("ucs2");
      };

      DBCSDecoder.prototype.end = function () {
        var ret = "";

        // Try to parse all remaining chars.
        while (this.prevBuf.length > 0) {
          // Skip 1 character in the buffer.
          ret += this.defaultCharUnicode;
          var buf = this.prevBuf.slice(1);

          // Parse remaining as usual.
          this.prevBuf = Buffer.alloc(0);
          this.nodeIdx = 0;
          if (buf.length > 0) ret += this.write(buf);
        }

        this.nodeIdx = 0;
        return ret;
      };

      // Binary search for GB18030. Returns largest i such that table[i] <= val.
      function findIdx(table, val) {
        if (table[0] > val) return -1;

        var l = 0,
          r = table.length;
        while (l < r - 1) {
          // always table[l] <= val < table[r]
          var mid = l + Math.floor((r - l + 1) / 2);
          if (table[mid] <= val) l = mid;
          else r = mid;
        }
        return l;
      }

      /***/
    },

    /***/ 1386: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      // Description of supported double byte encodings and aliases.
      // Tables are not require()-d until they are needed to speed up library load.
      // require()-s are direct to support Browserify.

      module.exports = {
        // == Japanese/ShiftJIS ====================================================
        // All japanese encodings are based on JIS X set of standards:
        // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
        // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
        //              Has several variations in 1978, 1983, 1990 and 1997.
        // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
        // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
        //              2 planes, first is superset of 0208, second - revised 0212.
        //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

        // Byte encodings are:
        //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
        //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
        //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
        //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
        //               0x00-0x7F       - lower part of 0201
        //               0x8E, 0xA1-0xDF - upper part of 0201
        //               (0xA1-0xFE)x2   - 0208 plane (94x94).
        //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
        //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
        //               Used as-is in ISO2022 family.
        //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
        //                0201-1976 Roman, 0208-1978, 0208-1983.
        //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
        //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
        //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
        //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
        //
        // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
        //
        // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

        shiftjis: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7014);
          },
          encodeAdd: { "\u00a5": 0x5c, "\u203E": 0x7e },
          encodeSkipVals: [{ from: 0xed40, to: 0xf940 }]
        },
        csshiftjis: "shiftjis",
        mskanji: "shiftjis",
        sjis: "shiftjis",
        windows31j: "shiftjis",
        ms31j: "shiftjis",
        xsjis: "shiftjis",
        windows932: "shiftjis",
        ms932: "shiftjis",
        932: "shiftjis",
        cp932: "shiftjis",

        eucjp: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(1532);
          },
          encodeAdd: { "\u00a5": 0x5c, "\u203E": 0x7e }
        },

        // TODO: KDDI extension to Shift_JIS
        // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
        // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

        // == Chinese/GBK ==========================================================
        // http://en.wikipedia.org/wiki/GBK
        // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

        // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
        gb2312: "cp936",
        gb231280: "cp936",
        gb23121980: "cp936",
        csgb2312: "cp936",
        csiso58gb231280: "cp936",
        euccn: "cp936",

        // Microsoft's CP936 is a subset and approximation of GBK.
        windows936: "cp936",
        ms936: "cp936",
        936: "cp936",
        cp936: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336);
          }
        },

        // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
        gbk: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          }
        },
        xgbk: "gbk",
        isoir58: "gbk",

        // GB18030 is an algorithmic extension of GBK.
        // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
        // http://icu-project.org/docs/papers/gb18030.html
        // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
        // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
        gb18030: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          },
          gb18030: function () {
            return __nccwpck_require__(6258);
          },
          encodeSkipVals: [0x80],
          encodeAdd: { "": 0xa2e3 }
        },

        chinese: "gb18030",

        // == Korean ===============================================================
        // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
        windows949: "cp949",
        ms949: "cp949",
        949: "cp949",
        cp949: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7348);
          }
        },

        cseuckr: "cp949",
        csksc56011987: "cp949",
        euckr: "cp949",
        isoir149: "cp949",
        korean: "cp949",
        ksc56011987: "cp949",
        ksc56011989: "cp949",
        ksc5601: "cp949",

        // == Big5/Taiwan/Hong Kong ================================================
        // There are lots of tables for Big5 and cp950. Please see the following links for history:
        // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
        // Variations, in roughly number of defined chars:
        //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
        //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
        //  * Big5-2003 (Taiwan standard) almost superset of cp950.
        //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
        //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
        //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
        //    Plus, it has 4 combining sequences.
        //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
        //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
        //    Implementations are not consistent within browsers; sometimes labeled as just big5.
        //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
        //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
        //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
        //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
        //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
        //
        // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
        // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

        windows950: "cp950",
        ms950: "cp950",
        950: "cp950",
        cp950: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284);
          }
        },

        // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
        big5: "big5hkscs",
        big5hkscs: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284).concat(__nccwpck_require__(3480));
          },
          encodeSkipVals: [0xa2cc]
        },

        cnbig5: "big5hkscs",
        csbig5: "big5hkscs",
        xxbig5: "big5hkscs"
      };

      /***/
    },

    /***/ 2733: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      // Update this array if you add/rename/remove files in this directory.
      // We support Browserify by skipping automatic module discovery and requiring modules directly.
      var modules = [
        __nccwpck_require__(2376),
        __nccwpck_require__(1155),
        __nccwpck_require__(1644),
        __nccwpck_require__(6657),
        __nccwpck_require__(1080),
        __nccwpck_require__(1012),
        __nccwpck_require__(9695),
        __nccwpck_require__(1386)
      ];

      // Put all encoding/alias/codec definitions to single object and export it.
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
      }

      /***/
    },

    /***/ 2376: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(5118).Buffer;

      // Export Node.js internal encodings.

      module.exports = {
        // Encodings
        utf8: { type: "_internal", bomAware: true },
        cesu8: { type: "_internal", bomAware: true },
        unicode11utf8: "utf8",

        ucs2: { type: "_internal", bomAware: true },
        utf16le: "ucs2",

        binary: { type: "_internal" },
        base64: { type: "_internal" },
        hex: { type: "_internal" },

        // Codec.
        _internal: InternalCodec
      };

      //------------------------------------------------------------------------------

      function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;

        if (this.enc === "base64") this.encoder = InternalEncoderBase64;
        else if (this.enc === "cesu8") {
          this.enc = "utf8"; // Use utf8 for decoding.
          this.encoder = InternalEncoderCesu8;

          // Add decoder for versions of Node not supporting CESU-8
          if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
          }
        }
      }

      InternalCodec.prototype.encoder = InternalEncoder;
      InternalCodec.prototype.decoder = InternalDecoder;

      //------------------------------------------------------------------------------

      // We use node.js internal decoder. Its signature is the same as ours.
      var StringDecoder = __nccwpck_require__(1576).StringDecoder;

      if (!StringDecoder.prototype.end)
        // Node v0.8 doesn't have this method.
        StringDecoder.prototype.end = function () {};

      function InternalDecoder(options, codec) {
        StringDecoder.call(this, codec.enc);
      }

      InternalDecoder.prototype = StringDecoder.prototype;

      //------------------------------------------------------------------------------
      // Encoder is mostly trivial

      function InternalEncoder(options, codec) {
        this.enc = codec.enc;
      }

      InternalEncoder.prototype.write = function (str) {
        return Buffer.from(str, this.enc);
      };

      InternalEncoder.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // Except base64 encoder, which must keep its state.

      function InternalEncoderBase64(options, codec) {
        this.prevStr = "";
      }

      InternalEncoderBase64.prototype.write = function (str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);

        return Buffer.from(str, "base64");
      };

      InternalEncoderBase64.prototype.end = function () {
        return Buffer.from(this.prevStr, "base64");
      };

      //------------------------------------------------------------------------------
      // CESU-8 encoder is also special.

      function InternalEncoderCesu8(options, codec) {}

      InternalEncoderCesu8.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length * 3),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var charCode = str.charCodeAt(i);
          // Naive implementation, but it works because CESU-8 is especially easy
          // to convert from UTF-16 (which all JS strings are encoded in).
          if (charCode < 0x80) buf[bufIdx++] = charCode;
          else if (charCode < 0x800) {
            buf[bufIdx++] = 0xc0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          } else {
            // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xe0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
          }
        }
        return buf.slice(0, bufIdx);
      };

      InternalEncoderCesu8.prototype.end = function () {};

      //------------------------------------------------------------------------------
      // CESU-8 decoder is not implemented in Node v4.0+

      function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
      }

      InternalDecoderCesu8.prototype.write = function (buf) {
        var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = "";
        for (var i = 0; i < buf.length; i++) {
          var curByte = buf[i];
          if ((curByte & 0xc0) !== 0x80) {
            // Leading byte
            if (contBytes > 0) {
              // Previous code is invalid
              res += this.defaultCharUnicode;
              contBytes = 0;
            }

            if (curByte < 0x80) {
              // Single-byte code
              res += String.fromCharCode(curByte);
            } else if (curByte < 0xe0) {
              // Two-byte code
              acc = curByte & 0x1f;
              contBytes = 1;
              accBytes = 1;
            } else if (curByte < 0xf0) {
              // Three-byte code
              acc = curByte & 0x0f;
              contBytes = 2;
              accBytes = 1;
            } else {
              // Four or more are not supported for CESU-8.
              res += this.defaultCharUnicode;
            }
          } else {
            // Continuation byte
            if (contBytes > 0) {
              // We're waiting for it.
              acc = (acc << 6) | (curByte & 0x3f);
              contBytes--;
              accBytes++;
              if (contBytes === 0) {
                // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;
                else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;
                // Actually add character.
                else res += String.fromCharCode(acc);
              }
            } else {
              // Unexpected continuation byte
              res += this.defaultCharUnicode;
            }
          }
        }
        this.acc = acc;
        this.contBytes = contBytes;
        this.accBytes = accBytes;
        return res;
      };

      InternalDecoderCesu8.prototype.end = function () {
        var res = 0;
        if (this.contBytes > 0) res += this.defaultCharUnicode;
        return res;
      };

      /***/
    },

    /***/ 6657: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(5118).Buffer;

      // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
      // correspond to encoded bytes (if 128 - then lower half is ASCII).

      exports._sbcs = SBCSCodec;
      function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions) throw new Error("SBCS codec is called without the data.");

        // Prepare char buffer for decoding.
        if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
          throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");

        if (codecOptions.chars.length === 128) {
          var asciiString = "";
          for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
          codecOptions.chars = asciiString + codecOptions.chars;
        }

        this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");

        // Encoding buffer.
        var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

        for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

        this.encodeBuf = encodeBuf;
      }

      SBCSCodec.prototype.encoder = SBCSEncoder;
      SBCSCodec.prototype.decoder = SBCSDecoder;

      function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
      }

      SBCSEncoder.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length);
        for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];

        return buf;
      };

      SBCSEncoder.prototype.end = function () {};

      function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
      }

      SBCSDecoder.prototype.write = function (buf) {
        // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer.alloc(buf.length * 2);
        var idx1 = 0,
          idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
          idx1 = buf[i] * 2;
          idx2 = i * 2;
          newBuf[idx2] = decodeBuf[idx1];
          newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
        }
        return newBuf.toString("ucs2");
      };

      SBCSDecoder.prototype.end = function () {};

      /***/
    },

    /***/ 1012: /***/ (module) => {
      "use strict";

      // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
      module.exports = {
        437: "cp437",
        737: "cp737",
        775: "cp775",
        850: "cp850",
        852: "cp852",
        855: "cp855",
        856: "cp856",
        857: "cp857",
        858: "cp858",
        860: "cp860",
        861: "cp861",
        862: "cp862",
        863: "cp863",
        864: "cp864",
        865: "cp865",
        866: "cp866",
        869: "cp869",
        874: "windows874",
        922: "cp922",
        1046: "cp1046",
        1124: "cp1124",
        1125: "cp1125",
        1129: "cp1129",
        1133: "cp1133",
        1161: "cp1161",
        1162: "cp1162",
        1163: "cp1163",
        1250: "windows1250",
        1251: "windows1251",
        1252: "windows1252",
        1253: "windows1253",
        1254: "windows1254",
        1255: "windows1255",
        1256: "windows1256",
        1257: "windows1257",
        1258: "windows1258",
        28591: "iso88591",
        28592: "iso88592",
        28593: "iso88593",
        28594: "iso88594",
        28595: "iso88595",
        28596: "iso88596",
        28597: "iso88597",
        28598: "iso88598",
        28599: "iso88599",
        28600: "iso885910",
        28601: "iso885911",
        28603: "iso885913",
        28604: "iso885914",
        28605: "iso885915",
        28606: "iso885916",
        windows874: {
          type: "_sbcs",
          chars:
            ""
        },
        win874: "windows874",
        cp874: "windows874",
        windows1250: {
          type: "_sbcs",
          chars:
            ""
        },
        win1250: "windows1250",
        cp1250: "windows1250",
        windows1251: {
          type: "_sbcs",
          chars:
            ""
        },
        win1251: "windows1251",
        cp1251: "windows1251",
        windows1252: {
          type: "_sbcs",
          chars:
            ""
        },
        win1252: "windows1252",
        cp1252: "windows1252",
        windows1253: {
          type: "_sbcs",
          chars:
            ""
        },
        win1253: "windows1253",
        cp1253: "windows1253",
        windows1254: {
          type: "_sbcs",
          chars:
            ""
        },
        win1254: "windows1254",
        cp1254: "windows1254",
        windows1255: {
          type: "_sbcs",
          chars:
            ""
        },
        win1255: "windows1255",
        cp1255: "windows1255",
        windows1256: {
          type: "_sbcs",
          chars:
            ""
        },
        win1256: "windows1256",
        cp1256: "windows1256",
        windows1257: {
          type: "_sbcs",
          chars:
            ""
        },
        win1257: "windows1257",
        cp1257: "windows1257",
        windows1258: {
          type: "_sbcs",
          chars:
            ""
        },
        win1258: "windows1258",
        cp1258: "windows1258",
        iso88591: {
          type: "_sbcs",
          chars: ""
        },
        cp28591: "iso88591",
        iso88592: {
          type: "_sbcs",
          chars: ""
        },
        cp28592: "iso88592",
        iso88593: {
          type: "_sbcs",
          chars: ""
        },
        cp28593: "iso88593",
        iso88594: {
          type: "_sbcs",
          chars: ""
        },
        cp28594: "iso88594",
        iso88595: {
          type: "_sbcs",
          chars: ""
        },
        cp28595: "iso88595",
        iso88596: {
          type: "_sbcs",
          chars: ""
        },
        cp28596: "iso88596",
        iso88597: {
          type: "_sbcs",
          chars: ""
        },
        cp28597: "iso88597",
        iso88598: {
          type: "_sbcs",
          chars: ""
        },
        cp28598: "iso88598",
        iso88599: {
          type: "_sbcs",
          chars: ""
        },
        cp28599: "iso88599",
        iso885910: {
          type: "_sbcs",
          chars: ""
        },
        cp28600: "iso885910",
        iso885911: {
          type: "_sbcs",
          chars: ""
        },
        cp28601: "iso885911",
        iso885913: {
          type: "_sbcs",
          chars: ""
        },
        cp28603: "iso885913",
        iso885914: {
          type: "_sbcs",
          chars: ""
        },
        cp28604: "iso885914",
        iso885915: {
          type: "_sbcs",
          chars: ""
        },
        cp28605: "iso885915",
        iso885916: {
          type: "_sbcs",
          chars: ""
        },
        cp28606: "iso885916",
        cp437: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm437: "cp437",
        csibm437: "cp437",
        cp737: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm737: "cp737",
        csibm737: "cp737",
        cp775: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm775: "cp775",
        csibm775: "cp775",
        cp850: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm850: "cp850",
        csibm850: "cp850",
        cp852: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm852: "cp852",
        csibm852: "cp852",
        cp855: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm855: "cp855",
        csibm855: "cp855",
        cp856: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm856: "cp856",
        csibm856: "cp856",
        cp857: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm857: "cp857",
        csibm857: "cp857",
        cp858: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm858: "cp858",
        csibm858: "cp858",
        cp860: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm860: "cp860",
        csibm860: "cp860",
        cp861: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm861: "cp861",
        csibm861: "cp861",
        cp862: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm862: "cp862",
        csibm862: "cp862",
        cp863: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm863: "cp863",
        csibm863: "cp863",
        cp864: {
          type: "_sbcs",
          chars:
            "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        },
        ibm864: "cp864",
        csibm864: "cp864",
        cp865: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm865: "cp865",
        csibm865: "cp865",
        cp866: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm866: "cp866",
        csibm866: "cp866",
        cp869: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm869: "cp869",
        csibm869: "cp869",
        cp922: {
          type: "_sbcs",
          chars: ""
        },
        ibm922: "cp922",
        csibm922: "cp922",
        cp1046: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm1046: "cp1046",
        csibm1046: "cp1046",
        cp1124: {
          type: "_sbcs",
          chars: ""
        },
        ibm1124: "cp1124",
        csibm1124: "cp1124",
        cp1125: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm1125: "cp1125",
        csibm1125: "cp1125",
        cp1129: {
          type: "_sbcs",
          chars: ""
        },
        ibm1129: "cp1129",
        csibm1129: "cp1129",
        cp1133: {
          type: "_sbcs",
          chars: ""
        },
        ibm1133: "cp1133",
        csibm1133: "cp1133",
        cp1161: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm1161: "cp1161",
        csibm1161: "cp1161",
        cp1162: {
          type: "_sbcs",
          chars:
            ""
        },
        ibm1162: "cp1162",
        csibm1162: "cp1162",
        cp1163: {
          type: "_sbcs",
          chars: ""
        },
        ibm1163: "cp1163",
        csibm1163: "cp1163",
        maccroatian: {
          type: "_sbcs",
          chars:
            ""
        },
        maccyrillic: {
          type: "_sbcs",
          chars:
            ""
        },
        macgreek: {
          type: "_sbcs",
          chars:
            ""
        },
        maciceland: {
          type: "_sbcs",
          chars:
            ""
        },
        macroman: {
          type: "_sbcs",
          chars:
            ""
        },
        macromania: {
          type: "_sbcs",
          chars:
            ""
        },
        macthai: {
          type: "_sbcs",
          chars:
            ""
        },
        macturkish: {
          type: "_sbcs",
          chars:
            ""
        },
        macukraine: {
          type: "_sbcs",
          chars:
            ""
        },
        koi8r: {
          type: "_sbcs",
          chars:
            ""
        },
        koi8u: {
          type: "_sbcs",
          chars:
            ""
        },
        koi8ru: {
          type: "_sbcs",
          chars:
            ""
        },
        koi8t: {
          type: "_sbcs",
          chars:
            ""
        },
        armscii8: {
          type: "_sbcs",
          chars: ")(.,-"
        },
        rk1048: {
          type: "_sbcs",
          chars:
            ""
        },
        tcvn: {
          type: "_sbcs",
          chars:
            "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        },
        georgianacademy: {
          type: "_sbcs",
          chars:
            ""
        },
        georgianps: {
          type: "_sbcs",
          chars:
            ""
        },
        pt154: {
          type: "_sbcs",
          chars:
            ""
        },
        viscii: {
          type: "_sbcs",
          chars:
            "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        },
        iso646cn: {
          type: "_sbcs",
          chars:
            "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
        },
        iso646jp: {
          type: "_sbcs",
          chars:
            "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
        },
        hproman8: {
          type: "_sbcs",
          chars: ""
        },
        macintosh: {
          type: "_sbcs",
          chars:
            ""
        },
        ascii: {
          type: "_sbcs",
          chars:
            ""
        },
        tis620: {
          type: "_sbcs",
          chars:
            ""
        }
      };

      /***/
    },

    /***/ 1080: /***/ (module) => {
      "use strict";

      // Manually added data to be used by sbcs codec in addition to generated one.

      module.exports = {
        // Not supported by iconv, not sure why.
        10029: "maccenteuro",
        maccenteuro: {
          type: "_sbcs",
          chars:
            ""
        },

        808: "cp808",
        ibm808: "cp808",
        cp808: {
          type: "_sbcs",
          chars:
            ""
        },

        mik: {
          type: "_sbcs",
          chars:
            ""
        },

        // Aliases of generated encodings.
        ascii8bit: "ascii",
        usascii: "ascii",
        ansix34: "ascii",
        ansix341968: "ascii",
        ansix341986: "ascii",
        csascii: "ascii",
        cp367: "ascii",
        ibm367: "ascii",
        isoir6: "ascii",
        iso646us: "ascii",
        iso646irv: "ascii",
        us: "ascii",

        latin1: "iso88591",
        latin2: "iso88592",
        latin3: "iso88593",
        latin4: "iso88594",
        latin5: "iso88599",
        latin6: "iso885910",
        latin7: "iso885913",
        latin8: "iso885914",
        latin9: "iso885915",
        latin10: "iso885916",

        csisolatin1: "iso88591",
        csisolatin2: "iso88592",
        csisolatin3: "iso88593",
        csisolatin4: "iso88594",
        csisolatincyrillic: "iso88595",
        csisolatinarabic: "iso88596",
        csisolatingreek: "iso88597",
        csisolatinhebrew: "iso88598",
        csisolatin5: "iso88599",
        csisolatin6: "iso885910",

        l1: "iso88591",
        l2: "iso88592",
        l3: "iso88593",
        l4: "iso88594",
        l5: "iso88599",
        l6: "iso885910",
        l7: "iso885913",
        l8: "iso885914",
        l9: "iso885915",
        l10: "iso885916",

        isoir14: "iso646jp",
        isoir57: "iso646cn",
        isoir100: "iso88591",
        isoir101: "iso88592",
        isoir109: "iso88593",
        isoir110: "iso88594",
        isoir144: "iso88595",
        isoir127: "iso88596",
        isoir126: "iso88597",
        isoir138: "iso88598",
        isoir148: "iso88599",
        isoir157: "iso885910",
        isoir166: "tis620",
        isoir179: "iso885913",
        isoir199: "iso885914",
        isoir203: "iso885915",
        isoir226: "iso885916",

        cp819: "iso88591",
        ibm819: "iso88591",

        cyrillic: "iso88595",

        arabic: "iso88596",
        arabic8: "iso88596",
        ecma114: "iso88596",
        asmo708: "iso88596",

        greek: "iso88597",
        greek8: "iso88597",
        ecma118: "iso88597",
        elot928: "iso88597",

        hebrew: "iso88598",
        hebrew8: "iso88598",

        turkish: "iso88599",
        turkish8: "iso88599",

        thai: "iso885911",
        thai8: "iso885911",

        celtic: "iso885914",
        celtic8: "iso885914",
        isoceltic: "iso885914",

        tis6200: "tis620",
        tis62025291: "tis620",
        tis62025330: "tis620",

        10000: "macroman",
        10006: "macgreek",
        10007: "maccyrillic",
        10079: "maciceland",
        10081: "macturkish",

        cspc8codepage437: "cp437",
        cspc775baltic: "cp775",
        cspc850multilingual: "cp850",
        cspcp852: "cp852",
        cspc862latinhebrew: "cp862",
        cpgr: "cp869",

        msee: "cp1250",
        mscyrl: "cp1251",
        msansi: "cp1252",
        msgreek: "cp1253",
        msturk: "cp1254",
        mshebr: "cp1255",
        msarab: "cp1256",
        winbaltrim: "cp1257",

        cp20866: "koi8r",
        20866: "koi8r",
        ibm878: "koi8r",
        cskoi8r: "koi8r",

        cp21866: "koi8u",
        21866: "koi8u",
        ibm1168: "koi8u",

        strk10482002: "rk1048",

        tcvn5712: "tcvn",
        tcvn57121: "tcvn",

        gb198880: "iso646cn",
        cn: "iso646cn",

        csiso14jisc6220ro: "iso646jp",
        jisc62201969ro: "iso646jp",
        jp: "iso646jp",

        cshproman8: "hproman8",
        r8: "hproman8",
        roman8: "hproman8",
        xroman8: "hproman8",
        ibm1051: "hproman8",

        mac: "macintosh",
        csmacintosh: "macintosh"
      };

      /***/
    },

    /***/ 1155: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(5118).Buffer;

      // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

      // == UTF16-BE codec. ==========================================================

      exports.utf16be = Utf16BECodec;
      function Utf16BECodec() {}

      Utf16BECodec.prototype.encoder = Utf16BEEncoder;
      Utf16BECodec.prototype.decoder = Utf16BEDecoder;
      Utf16BECodec.prototype.bomAware = true;

      // -- Encoding

      function Utf16BEEncoder() {}

      Utf16BEEncoder.prototype.write = function (str) {
        var buf = Buffer.from(str, "ucs2");
        for (var i = 0; i < buf.length; i += 2) {
          var tmp = buf[i];
          buf[i] = buf[i + 1];
          buf[i + 1] = tmp;
        }
        return buf;
      };

      Utf16BEEncoder.prototype.end = function () {};

      // -- Decoding

      function Utf16BEDecoder() {
        this.overflowByte = -1;
      }

      Utf16BEDecoder.prototype.write = function (buf) {
        if (buf.length == 0) return "";

        var buf2 = Buffer.alloc(buf.length + 1),
          i = 0,
          j = 0;

        if (this.overflowByte !== -1) {
          buf2[0] = buf[0];
          buf2[1] = this.overflowByte;
          i = 1;
          j = 2;
        }

        for (; i < buf.length - 1; i += 2, j += 2) {
          buf2[j] = buf[i + 1];
          buf2[j + 1] = buf[i];
        }

        this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;

        return buf2.slice(0, j).toString("ucs2");
      };

      Utf16BEDecoder.prototype.end = function () {};

      // == UTF-16 codec =============================================================
      // Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
      // Defaults to UTF-16LE, as it's prevalent and default in Node.
      // http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
      // Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

      // Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

      exports.utf16 = Utf16Codec;
      function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }

      Utf16Codec.prototype.encoder = Utf16Encoder;
      Utf16Codec.prototype.decoder = Utf16Decoder;

      // -- Encoding (pass-through)

      function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder("utf-16le", options);
      }

      Utf16Encoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };

      Utf16Encoder.prototype.end = function () {
        return this.encoder.end();
      };

      // -- Decoding

      function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBytes = [];
        this.initialBytesLen = 0;

        this.options = options || {};
        this.iconv = codec.iconv;
      }

      Utf16Decoder.prototype.write = function (buf) {
        if (!this.decoder) {
          // Codec is not chosen yet. Accumulate initial bytes.
          this.initialBytes.push(buf);
          this.initialBytesLen += buf.length;

          if (this.initialBytesLen < 16)
            // We need more bytes to use space heuristic (see below)
            return "";

          // We have enough bytes -> detect endianness.
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          this.initialBytes.length = this.initialBytesLen = 0;
        }

        return this.decoder.write(buf);
      };

      Utf16Decoder.prototype.end = function () {
        if (!this.decoder) {
          var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
          this.decoder = this.iconv.getDecoder(encoding, this.options);

          var res = this.decoder.write(buf),
            trail = this.decoder.end();

          return trail ? res + trail : res;
        }
        return this.decoder.end();
      };

      function detectEncoding(buf, defaultEncoding) {
        var enc = defaultEncoding || "utf-16le";

        if (buf.length >= 2) {
          // Check BOM.
          if (buf[0] == 0xfe && buf[1] == 0xff)
            // UTF-16BE BOM
            enc = "utf-16be";
          else if (buf[0] == 0xff && buf[1] == 0xfe)
            // UTF-16LE BOM
            enc = "utf-16le";
          else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0,
              asciiCharsBE = 0, // Counts of chars in both positions
              _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
              if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
              if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE) enc = "utf-16be";
            else if (asciiCharsBE < asciiCharsLE) enc = "utf-16le";
          }
        }

        return enc;
      }

      /***/
    },

    /***/ 1644: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(5118).Buffer;

      // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
      // See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

      exports.utf7 = Utf7Codec;
      exports.unicode11utf7 = "utf7"; // Alias UNICODE-1-1-UTF-7
      function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }

      Utf7Codec.prototype.encoder = Utf7Encoder;
      Utf7Codec.prototype.decoder = Utf7Decoder;
      Utf7Codec.prototype.bomAware = true;

      // -- Encoding

      var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

      function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
      }

      Utf7Encoder.prototype.write = function (str) {
        // Naive implementation.
        // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
        return Buffer.from(
          str.replace(
            nonDirectChars,
            function (chunk) {
              return (
                "+" +
                (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) +
                "-"
              );
            }.bind(this)
          )
        );
      };

      Utf7Encoder.prototype.end = function () {};

      // -- Decoding

      function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }

      var base64Regex = /[A-Za-z0-9\/+]/;
      var base64Chars = [];
      for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));

      var plusChar = "+".charCodeAt(0),
        minusChar = "-".charCodeAt(0),
        andChar = "&".charCodeAt(0);

      Utf7Decoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64Chars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "+-" -> "+"
                res += "+";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString();
                res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
              }

              if (buf[i] != minusChar)
                // Minus is absorbed after base64.
                i--;

              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }

        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString();

          var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);

          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }

        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;

        return res;
      };

      Utf7Decoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");

        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };

      // UTF-7-IMAP codec.
      // RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
      // Differences:
      //  * Base64 part is started by "&" instead of "+"
      //  * Direct characters are 0x20-0x7E, except "&" (0x26)
      //  * In Base64, "," is used instead of "/"
      //  * Base64 must not be used to represent direct characters.
      //  * No implicit shift back from Base64 (should always end with '-')
      //  * String must end in non-shifted position.
      //  * "-&" while in base64 is not allowed.

      exports.utf7imap = Utf7IMAPCodec;
      function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
      }

      Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
      Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
      Utf7IMAPCodec.prototype.bomAware = true;

      // -- Encoding

      function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer.alloc(6);
        this.base64AccumIdx = 0;
      }

      Utf7IMAPEncoder.prototype.write = function (str) {
        var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = Buffer.alloc(str.length * 5 + 10),
          bufIdx = 0;

        for (var i = 0; i < str.length; i++) {
          var uChar = str.charCodeAt(i);
          if (0x20 <= uChar && uChar <= 0x7e) {
            // Direct character or '&'.
            if (inBase64) {
              if (base64AccumIdx > 0) {
                bufIdx += buf.write(
                  base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""),
                  bufIdx
                );
                base64AccumIdx = 0;
              }

              buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
              inBase64 = false;
            }

            if (!inBase64) {
              buf[bufIdx++] = uChar; // Write direct character

              if (uChar === andChar)
                // Ampersand -> '&-'
                buf[bufIdx++] = minusChar;
            }
          } else {
            // Non-direct character
            if (!inBase64) {
              buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
              inBase64 = true;
            }
            if (inBase64) {
              base64Accum[base64AccumIdx++] = uChar >> 8;
              base64Accum[base64AccumIdx++] = uChar & 0xff;

              if (base64AccumIdx == base64Accum.length) {
                bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
                base64AccumIdx = 0;
              }
            }
          }
        }

        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;

        return buf.slice(0, bufIdx);
      };

      Utf7IMAPEncoder.prototype.end = function () {
        var buf = Buffer.alloc(10),
          bufIdx = 0;
        if (this.inBase64) {
          if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(
              this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""),
              bufIdx
            );
            this.base64AccumIdx = 0;
          }

          buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
          this.inBase64 = false;
        }

        return buf.slice(0, bufIdx);
      };

      // -- Decoding

      function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }

      var base64IMAPChars = base64Chars.slice();
      base64IMAPChars[",".charCodeAt(0)] = true;

      Utf7IMAPDecoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;

        // The decoder is more involved as we must handle chunks in stream.
        // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            // We decode base64.
            if (!base64IMAPChars[buf[i]]) {
              // Base64 ended.
              if (i == lastI && buf[i] == minusChar) {
                // "&-" -> "&"
                res += "&";
              } else {
                var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, "/");
                res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
              }

              if (buf[i] != minusChar)
                // Minus may be absorbed after base64.
                i--;

              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }

        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
        } else {
          var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");

          var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
          base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
          b64str = b64str.slice(0, canBeDecoded);

          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }

        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;

        return res;
      };

      Utf7IMAPDecoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(Buffer.from(this.base64Accum, "base64"), "utf16-be");

        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };

      /***/
    },

    /***/ 7961: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      var BOMChar = "\uFEFF";

      exports.PrependBOM = PrependBOMWrapper;
      function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
      }

      PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
          str = BOMChar + str;
          this.addBOM = false;
        }

        return this.encoder.write(str);
      };

      PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
      };

      //------------------------------------------------------------------------------

      exports.StripBOM = StripBOMWrapper;
      function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
      }

      StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;

        if (res[0] === BOMChar) {
          res = res.slice(1);
          if (typeof this.options.stripBOM === "function") this.options.stripBOM();
        }

        this.pass = true;
        return res;
      };

      StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
      };

      /***/
    },

    /***/ 393: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(4300).Buffer;
      // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

      // == Extend Node primitives to use iconv-lite =================================

      module.exports = function (iconv) {
        var original = undefined; // Place to keep original methods.

        // Node authors rewrote Buffer internals to make it compatible with
        // Uint8Array and we cannot patch key functions since then.
        // Note: this does use older Buffer API on a purpose
        iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

        iconv.extendNodeEncodings = function extendNodeEncodings() {
          if (original) return;
          original = {};

          if (!iconv.supportsNodeEncodingsExtension) {
            console.error(
              "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"
            );
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
          }

          var nodeNativeEncodings = {
            hex: true,
            utf8: true,
            "utf-8": true,
            ascii: true,
            binary: true,
            base64: true,
            ucs2: true,
            "ucs-2": true,
            utf16le: true,
            "utf-16le": true
          };

          Buffer.isNativeEncoding = function (enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
          };

          // -- SlowBuffer -----------------------------------------------------------
          var SlowBuffer = __nccwpck_require__(4300).SlowBuffer;

          original.SlowBufferToString = SlowBuffer.prototype.toString;
          SlowBuffer.prototype.toString = function (encoding, start, end) {
            encoding = String(encoding || "utf8").toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == "undefined") start = 0;
            if (typeof end == "undefined") end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
          };

          original.SlowBufferWrite = SlowBuffer.prototype.write;
          SlowBuffer.prototype.write = function (string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
              if (!isFinite(length)) {
                encoding = length;
                length = undefined;
              }
            } else {
              // legacy
              var swap = encoding;
              encoding = offset;
              offset = length;
              length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = +length;
              if (length > remaining) {
                length = remaining;
              }
            }
            encoding = String(encoding || "utf8").toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
              return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0))
              throw new RangeError("attempt to write beyond buffer bounds");

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
          };

          // -- Buffer ---------------------------------------------------------------

          original.BufferIsEncoding = Buffer.isEncoding;
          Buffer.isEncoding = function (encoding) {
            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
          };

          original.BufferByteLength = Buffer.byteLength;
          Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {
            encoding = String(encoding || "utf8").toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
          };

          original.BufferToString = Buffer.prototype.toString;
          Buffer.prototype.toString = function (encoding, start, end) {
            encoding = String(encoding || "utf8").toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == "undefined") start = 0;
            if (typeof end == "undefined") end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
          };

          original.BufferWrite = Buffer.prototype.write;
          Buffer.prototype.write = function (string, offset, length, encoding) {
            var _offset = offset,
              _length = length,
              _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
              if (!isFinite(length)) {
                encoding = length;
                length = undefined;
              }
            } else {
              // legacy
              var swap = encoding;
              encoding = offset;
              offset = length;
              length = swap;
            }

            encoding = String(encoding || "utf8").toLowerCase();

            // Use native conversion when possible
            if (Buffer.isNativeEncoding(encoding))
              return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = +length;
              if (length > remaining) {
                length = remaining;
              }
            }

            if (string.length > 0 && (length < 0 || offset < 0))
              throw new RangeError("attempt to write beyond buffer bounds");

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
          };

          // -- Readable -------------------------------------------------------------
          if (iconv.supportsStreams) {
            var Readable = __nccwpck_require__(2781).Readable;

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
              // Use our own decoder, it has the same interface.
              // We cannot use original function as it doesn't handle BOM-s.
              this._readableState.decoder = iconv.getDecoder(enc, options);
              this._readableState.encoding = enc;
            };

            Readable.prototype.collect = iconv._collect;
          }
        };

        // Remove iconv-lite Node primitive extensions.
        iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
          if (!iconv.supportsNodeEncodingsExtension) return;
          if (!original)
            throw new Error(
              "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called."
            );

          delete Buffer.isNativeEncoding;

          var SlowBuffer = __nccwpck_require__(4300).SlowBuffer;

          SlowBuffer.prototype.toString = original.SlowBufferToString;
          SlowBuffer.prototype.write = original.SlowBufferWrite;

          Buffer.isEncoding = original.BufferIsEncoding;
          Buffer.byteLength = original.BufferByteLength;
          Buffer.prototype.toString = original.BufferToString;
          Buffer.prototype.write = original.BufferWrite;

          if (iconv.supportsStreams) {
            var Readable = __nccwpck_require__(2781).Readable;

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
          }

          original = undefined;
        };
      };

      /***/
    },

    /***/ 9032: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      // Some environments don't have global Buffer (e.g. React Native).
      // Solution would be installing npm modules "buffer" and "stream" explicitly.
      var Buffer = __nccwpck_require__(5118).Buffer;

      var bomHandling = __nccwpck_require__(7961),
        iconv = module.exports;

      // All codecs and aliases are kept here, keyed by encoding name/alias.
      // They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
      iconv.encodings = null;

      // Characters emitted in case of error.
      iconv.defaultCharUnicode = "";
      iconv.defaultCharSingleByte = "?";

      // Public API.
      iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || ""); // Ensure string.

        var encoder = iconv.getEncoder(encoding, options);

        var res = encoder.write(str);
        var trail = encoder.end();

        return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
      };

      iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === "string") {
          if (!iconv.skipDecodeWarning) {
            console.error(
              "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"
            );
            iconv.skipDecodeWarning = true;
          }

          buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
        }

        var decoder = iconv.getDecoder(encoding, options);

        var res = decoder.write(buf);
        var trail = decoder.end();

        return trail ? res + trail : res;
      };

      iconv.encodingExists = function encodingExists(enc) {
        try {
          iconv.getCodec(enc);
          return true;
        } catch (e) {
          return false;
        }
      };

      // Legacy aliases to convert functions
      iconv.toEncoding = iconv.encode;
      iconv.fromEncoding = iconv.decode;

      // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
      iconv._codecDataCache = {};
      iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings) iconv.encodings = __nccwpck_require__(2733); // Lazy load all encoding definitions.

        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        var enc = iconv._canonicalizeEncoding(encoding);

        // Traverse iconv.encodings to find actual codec.
        var codecOptions = {};
        while (true) {
          var codec = iconv._codecDataCache[enc];
          if (codec) return codec;

          var codecDef = iconv.encodings[enc];

          switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
              enc = codecDef;
              break;

            case "object": // Alias with options. Can be layered.
              for (var key in codecDef) codecOptions[key] = codecDef[key];

              if (!codecOptions.encodingName) codecOptions.encodingName = enc;

              enc = codecDef.type;
              break;

            case "function": // Codec itself.
              if (!codecOptions.encodingName) codecOptions.encodingName = enc;

              // The codec function must load all tables and return object with .encoder and .decoder methods.
              // It'll be called only once (for each different options object).
              codec = new codecDef(codecOptions, iconv);

              iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
              return codec;

            default:
              throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
          }
        }
      };

      iconv._canonicalizeEncoding = function (encoding) {
        // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
        return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
      };

      iconv.getEncoder = function getEncoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          encoder = new codec.encoder(options, codec);

        if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);

        return encoder;
      };

      iconv.getDecoder = function getDecoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          decoder = new codec.decoder(options, codec);

        if (codec.bomAware && !(options && options.stripBOM === false))
          decoder = new bomHandling.StripBOM(decoder, options);

        return decoder;
      };

      // Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
      var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
      if (nodeVer) {
        // Load streaming support in Node v0.10+
        var nodeVerArr = nodeVer.split(".").map(Number);
        if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
          __nccwpck_require__(6869)(iconv);
        }

        // Load Node primitive extensions.
        __nccwpck_require__(393)(iconv);
      }

      if (false) {
      }

      /***/
    },

    /***/ 6869: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var Buffer = __nccwpck_require__(4300).Buffer,
        Transform = __nccwpck_require__(2781).Transform;

      // == Exports ==================================================================
      module.exports = function (iconv) {
        // Additional Public API.
        iconv.encodeStream = function encodeStream(encoding, options) {
          return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
        };

        iconv.decodeStream = function decodeStream(encoding, options) {
          return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
        };

        iconv.supportsStreams = true;

        // Not published yet.
        iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
        iconv._collect = IconvLiteDecoderStream.prototype.collect;
      };

      // == Encoder stream =======================================================
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
        Transform.call(this, options);
      }

      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });

      IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
        if (typeof chunk != "string") return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };

      IconvLiteEncoderStream.prototype._flush = function (done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };

      IconvLiteEncoderStream.prototype.collect = function (cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function (chunk) {
          chunks.push(chunk);
        });
        this.on("end", function () {
          cb(null, Buffer.concat(chunks));
        });
        return this;
      };

      // == Decoder stream =======================================================
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8"; // We output strings.
        Transform.call(this, options);
      }

      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });

      IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
        if (!Buffer.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };

      IconvLiteDecoderStream.prototype._flush = function (done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };

      IconvLiteDecoderStream.prototype.collect = function (cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function (chunk) {
          res += chunk;
        });
        this.on("end", function () {
          cb(null, res);
        });
        return this;
      };

      /***/
    },

    /***/ 7547: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      var ip = exports;
      var { Buffer } = __nccwpck_require__(4300);
      var os = __nccwpck_require__(2037);

      ip.toBuffer = function (ip, buff, offset) {
        offset = ~~offset;

        var result;

        if (this.isV4Format(ip)) {
          result = buff || new Buffer(offset + 4);
          ip.split(/\./g).map((byte) => {
            result[offset++] = parseInt(byte, 10) & 0xff;
          });
        } else if (this.isV6Format(ip)) {
          var sections = ip.split(":", 8);

          var i;
          for (i = 0; i < sections.length; i++) {
            var isv4 = this.isV4Format(sections[i]);
            var v4Buffer;

            if (isv4) {
              v4Buffer = this.toBuffer(sections[i]);
              sections[i] = v4Buffer.slice(0, 2).toString("hex");
            }

            if (v4Buffer && ++i < 8) {
              sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
            }
          }

          if (sections[0] === "") {
            while (sections.length < 8) sections.unshift("0");
          } else if (sections[sections.length - 1] === "") {
            while (sections.length < 8) sections.push("0");
          } else if (sections.length < 8) {
            for (i = 0; i < sections.length && sections[i] !== ""; i++);
            var argv = [i, 1];
            for (i = 9 - sections.length; i > 0; i--) {
              argv.push("0");
            }
            sections.splice.apply(sections, argv);
          }

          result = buff || new Buffer(offset + 16);
          for (i = 0; i < sections.length; i++) {
            var word = parseInt(sections[i], 16);
            result[offset++] = (word >> 8) & 0xff;
            result[offset++] = word & 0xff;
          }
        }

        if (!result) {
          throw Error(`Invalid ip address: ${ip}`);
        }

        return result;
      };

      ip.toString = function (buff, offset, length) {
        offset = ~~offset;
        length = length || buff.length - offset;

        var result = [];
        var i;
        if (length === 4) {
          // IPv4
          for (i = 0; i < length; i++) {
            result.push(buff[offset + i]);
          }
          result = result.join(".");
        } else if (length === 16) {
          // IPv6
          for (i = 0; i < length; i += 2) {
            result.push(buff.readUInt16BE(offset + i).toString(16));
          }
          result = result.join(":");
          result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
          result = result.replace(/:{3,4}/, "::");
        }

        return result;
      };

      var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
      var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

      ip.isV4Format = function (ip) {
        return ipv4Regex.test(ip);
      };

      ip.isV6Format = function (ip) {
        return ipv6Regex.test(ip);
      };

      function _normalizeFamily(family) {
        if (family === 4) {
          return "ipv4";
        }
        if (family === 6) {
          return "ipv6";
        }
        return family ? family.toLowerCase() : "ipv4";
      }

      ip.fromPrefixLen = function (prefixlen, family) {
        if (prefixlen > 32) {
          family = "ipv6";
        } else {
          family = _normalizeFamily(family);
        }

        var len = 4;
        if (family === "ipv6") {
          len = 16;
        }
        var buff = new Buffer(len);

        for (var i = 0, n = buff.length; i < n; ++i) {
          var bits = 8;
          if (prefixlen < 8) {
            bits = prefixlen;
          }
          prefixlen -= bits;

          buff[i] = ~(0xff >> bits) & 0xff;
        }

        return ip.toString(buff);
      };

      ip.mask = function (addr, mask) {
        addr = ip.toBuffer(addr);
        mask = ip.toBuffer(mask);

        var result = new Buffer(Math.max(addr.length, mask.length));

        // Same protocol - do bitwise and
        var i;
        if (addr.length === mask.length) {
          for (i = 0; i < addr.length; i++) {
            result[i] = addr[i] & mask[i];
          }
        } else if (mask.length === 4) {
          // IPv6 address and IPv4 mask
          // (Mask low bits)
          for (i = 0; i < mask.length; i++) {
            result[i] = addr[addr.length - 4 + i] & mask[i];
          }
        } else {
          // IPv6 mask and IPv4 addr
          for (i = 0; i < result.length - 6; i++) {
            result[i] = 0;
          }

          // ::ffff:ipv4
          result[10] = 0xff;
          result[11] = 0xff;
          for (i = 0; i < addr.length; i++) {
            result[i + 12] = addr[i] & mask[i + 12];
          }
          i += 12;
        }
        for (; i < result.length; i++) {
          result[i] = 0;
        }

        return ip.toString(result);
      };

      ip.cidr = function (cidrString) {
        var cidrParts = cidrString.split("/");

        var addr = cidrParts[0];
        if (cidrParts.length !== 2) {
          throw new Error(`invalid CIDR subnet: ${addr}`);
        }

        var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

        return ip.mask(addr, mask);
      };

      ip.subnet = function (addr, mask) {
        var networkAddress = ip.toLong(ip.mask(addr, mask));

        // Calculate the mask's length.
        var maskBuffer = ip.toBuffer(mask);
        var maskLength = 0;

        for (var i = 0; i < maskBuffer.length; i++) {
          if (maskBuffer[i] === 0xff) {
            maskLength += 8;
          } else {
            var octet = maskBuffer[i] & 0xff;
            while (octet) {
              octet = (octet << 1) & 0xff;
              maskLength++;
            }
          }
        }

        var numberOfAddresses = Math.pow(2, 32 - maskLength);

        return {
          networkAddress: ip.fromLong(networkAddress),
          firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
          lastAddress:
            numberOfAddresses <= 2
              ? ip.fromLong(networkAddress + numberOfAddresses - 1)
              : ip.fromLong(networkAddress + numberOfAddresses - 2),
          broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
          subnetMask: mask,
          subnetMaskLength: maskLength,
          numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
          length: numberOfAddresses,
          contains(other) {
            return networkAddress === ip.toLong(ip.mask(other, mask));
          }
        };
      };

      ip.cidrSubnet = function (cidrString) {
        var cidrParts = cidrString.split("/");

        var addr = cidrParts[0];
        if (cidrParts.length !== 2) {
          throw new Error(`invalid CIDR subnet: ${addr}`);
        }

        var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

        return ip.subnet(addr, mask);
      };

      ip.not = function (addr) {
        var buff = ip.toBuffer(addr);
        for (var i = 0; i < buff.length; i++) {
          buff[i] = 0xff ^ buff[i];
        }
        return ip.toString(buff);
      };

      ip.or = function (a, b) {
        var i;

        a = ip.toBuffer(a);
        b = ip.toBuffer(b);

        // same protocol
        if (a.length === b.length) {
          for (i = 0; i < a.length; ++i) {
            a[i] |= b[i];
          }
          return ip.toString(a);

          // mixed protocols
        }
        var buff = a;
        var other = b;
        if (b.length > a.length) {
          buff = b;
          other = a;
        }

        var offset = buff.length - other.length;
        for (i = offset; i < buff.length; ++i) {
          buff[i] |= other[i - offset];
        }

        return ip.toString(buff);
      };

      ip.isEqual = function (a, b) {
        var i;

        a = ip.toBuffer(a);
        b = ip.toBuffer(b);

        // Same protocol
        if (a.length === b.length) {
          for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        // Swap
        if (b.length === 4) {
          var t = b;
          b = a;
          a = t;
        }

        // a - IPv4, b - IPv6
        for (i = 0; i < 10; i++) {
          if (b[i] !== 0) return false;
        }

        var word = b.readUInt16BE(10);
        if (word !== 0 && word !== 0xffff) return false;

        for (i = 0; i < 4; i++) {
          if (a[i] !== b[i + 12]) return false;
        }

        return true;
      };

      ip.isPrivate = function (addr) {
        return (
          /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
          /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
          /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
          /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
          /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
          /^f[cd][0-9a-f]{2}:/i.test(addr) ||
          /^fe80:/i.test(addr) ||
          /^::1$/.test(addr) ||
          /^::$/.test(addr)
        );
      };

      ip.isPublic = function (addr) {
        return !ip.isPrivate(addr);
      };

      ip.isLoopback = function (addr) {
        return (
          /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) ||
          /^fe80::1$/.test(addr) ||
          /^::1$/.test(addr) ||
          /^::$/.test(addr)
        );
      };

      ip.loopback = function (family) {
        //
        // Default to `ipv4`
        //
        family = _normalizeFamily(family);

        if (family !== "ipv4" && family !== "ipv6") {
          throw new Error("family must be ipv4 or ipv6");
        }

        return family === "ipv4" ? "127.0.0.1" : "fe80::1";
      };

      //
      // ### function address (name, family)
      // #### @name {string|'public'|'private'} **Optional** Name or security
      //      of the network interface.
      // #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
      //      to ipv4).
      //
      // Returns the address for the network interface on the current system with
      // the specified `name`:
      //   * String: First `family` address of the interface.
      //             If not found see `undefined`.
      //   * 'public': the first public ip address of family.
      //   * 'private': the first private ip address of family.
      //   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
      //
      ip.address = function (name, family) {
        var interfaces = os.networkInterfaces();

        //
        // Default to `ipv4`
        //
        family = _normalizeFamily(family);

        //
        // If a specific network interface has been named,
        // return the address.
        //
        if (name && name !== "private" && name !== "public") {
          var res = interfaces[name].filter((details) => {
            var itemFamily = _normalizeFamily(details.family);
            return itemFamily === family;
          });
          if (res.length === 0) {
            return undefined;
          }
          return res[0].address;
        }

        var all = Object.keys(interfaces)
          .map((nic) => {
            //
            // Note: name will only be `public` or `private`
            // when this is called.
            //
            var addresses = interfaces[nic].filter((details) => {
              details.family = _normalizeFamily(details.family);
              if (details.family !== family || ip.isLoopback(details.address)) {
                return false;
              }
              if (!name) {
                return true;
              }

              return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
            });

            return addresses.length ? addresses[0].address : undefined;
          })
          .filter(Boolean);

        return !all.length ? ip.loopback(family) : all[0];
      };

      ip.toLong = function (ip) {
        var ipl = 0;
        ip.split(".").forEach((octet) => {
          ipl <<= 8;
          ipl += parseInt(octet);
        });
        return ipl >>> 0;
      };

      ip.fromLong = function (ipl) {
        return `${ipl >>> 24}.${(ipl >> 16) & 255}.${(ipl >> 8) & 255}.${ipl & 255}`;
      };

      /***/
    },

    /***/ 4202: /***/ function (module, exports) {
      (function (root) {
        var toString = Function.prototype.toString;

        function fnBody(fn) {
          return toString
            .call(fn)
            .replace(/^[^{]*{\s*/, "")
            .replace(/\s*}[^}]*$/, "");
        }

        function isClass(fn) {
          return (
            typeof fn === "function" &&
            (/^class(?:\s|{)/.test(toString.call(fn)) || /^.*classCallCheck\(/.test(fnBody(fn))) // babel.js
          );
        }

        if (true) {
          if (true && module.exports) {
            exports = module.exports = isClass;
          }
          exports.isClass = isClass;
        } else {
        }
      })(this);

      /***/
    },

    /***/ 429: /***/ (module) => {
      "use strict";
      /*!
       * is-extendable <https://github.com/jonschlinkert/is-extendable>
       *
       * Copyright (c) 2015, Jon Schlinkert.
       * Licensed under the MIT License.
       */

      module.exports = function isExtendable(val) {
        return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
      };

      /***/
    },

    /***/ 5565: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var utils = __nccwpck_require__(5898);
      var isStearm = __nccwpck_require__(3362);
      // wait for https://github.com/miguelmota/is-class/pull/6 merge
      var isClass = __nccwpck_require__(4202);

      /**
       * Expose all methods in core-util-is
       */

      Object.keys(utils).map(function (name) {
        exports[transform(name)] = utils[name];
      });

      /**
       * Stream detected by isstream
       */

      exports.stream = isStearm;
      exports.readableStream = isStearm.isReadable;
      exports.writableStream = isStearm.isWritable;
      exports.duplexStream = isStearm.isDuplex;

      /**
       * Class detected by is-class
       */
      exports["class"] = isClass;

      /**
       * Extend method
       */

      exports.finite = Number.isFinite;

      exports[NaN] = Number.isNaN;

      exports.generator = function (obj) {
        return obj && "function" === typeof obj.next && "function" === typeof obj.throw;
      };

      exports.generatorFunction = function (obj) {
        return obj && obj.constructor && "GeneratorFunction" === obj.constructor.name;
      };

      exports.asyncFunction = function (obj) {
        return obj && obj.constructor && "AsyncFunction" === obj.constructor.name;
      };

      exports.promise = function (obj) {
        return obj && "function" === typeof obj.then;
      };

      var MAX_INT_31 = Math.pow(2, 31);

      exports.int = function (obj) {
        return utils.isNumber(obj) && obj % 1 === 0;
      };

      exports.int32 = function (obj) {
        return exports.int(obj) && obj < MAX_INT_31 && obj >= -MAX_INT_31;
      };

      exports.long = function (obj) {
        return exports.int(obj) && (obj >= MAX_INT_31 || obj < -MAX_INT_31);
      };

      exports.Long = function (obj) {
        return exports.object(obj) && exports.number(obj.high) && exports.number(obj.low);
      };

      exports.double = function (obj) {
        return utils.isNumber(obj) && !isNaN(obj) && obj % 1 !== 0;
      };

      exports.bigInt = function (obj) {
        return "bigint" === typeof obj;
      };
      exports.bigint = exports.bigInt;

      /**
       * override core-util-is
       */

      exports.date = function isDate(obj) {
        return obj instanceof Date;
      };

      exports.regExp = function isRegExp(obj) {
        return obj instanceof RegExp;
      };
      exports.regexp = exports.regExp;

      exports.error = function isError(obj) {
        return obj instanceof Error;
      };

      exports.array = Array.isArray;

      /**
       * transform isNull type to null
       * @param {[type]} m [description]
       * @return {[type]} [description]
       */

      function transform(m) {
        var name = m.slice(2);
        name = name[0].toLowerCase() + name.slice(1);
        return name;
      }

      /***/
    },

    /***/ 3362: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var stream = __nccwpck_require__(2781);

      function isStream(obj) {
        return obj instanceof stream.Stream;
      }

      function isReadable(obj) {
        return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
      }

      function isWritable(obj) {
        return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
      }

      function isDuplex(obj) {
        return isReadable(obj) && isWritable(obj);
      }

      module.exports = isStream;
      module.exports.isReadable = isReadable;
      module.exports.isWritable = isWritable;
      module.exports.isDuplex = isDuplex;

      /***/
    },

    /***/ 4139: /***/ function (module) {
      /*
       *  base64.js
       *
       *  Licensed under the BSD 3-Clause License.
       *    http://opensource.org/licenses/BSD-3-Clause
       *
       *  References:
       *    http://en.wikipedia.org/wiki/Base64
       */
      (function (global, factory) {
        true ? (module.exports = factory(global)) : 0;
      })(
        typeof self !== "undefined"
          ? self
          : typeof window !== "undefined"
          ? window
          : typeof global !== "undefined"
          ? global
          : this,
        function (global) {
          "use strict";
          // existing version for noConflict()
          global = global || {};
          var _Base64 = global.Base64;
          var version = "2.6.4";
          // constants
          var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var b64tab = (function (bin) {
            var t = {};
            for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
            return t;
          })(b64chars);
          var fromCharCode = String.fromCharCode;
          // encoder stuff
          var cb_utob = function (c) {
            if (c.length < 2) {
              var cc = c.charCodeAt(0);
              return cc < 0x80
                ? c
                : cc < 0x800
                ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))
                : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +
                  fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +
                  fromCharCode(0x80 | (cc & 0x3f));
            } else {
              var cc = 0x10000 + (c.charCodeAt(0) - 0xd800) * 0x400 + (c.charCodeAt(1) - 0xdc00);
              return (
                fromCharCode(0xf0 | ((cc >>> 18) & 0x07)) +
                fromCharCode(0x80 | ((cc >>> 12) & 0x3f)) +
                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +
                fromCharCode(0x80 | (cc & 0x3f))
              );
            }
          };
          var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
          var utob = function (u) {
            return u.replace(re_utob, cb_utob);
          };
          var cb_encode = function (ccc) {
            var padlen = [0, 2, 1][ccc.length % 3],
              ord =
                (ccc.charCodeAt(0) << 16) |
                ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |
                (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
              chars = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt((ord >>> 12) & 63),
                padlen >= 2 ? "=" : b64chars.charAt((ord >>> 6) & 63),
                padlen >= 1 ? "=" : b64chars.charAt(ord & 63)
              ];
            return chars.join("");
          };
          var btoa =
            global.btoa && typeof global.btoa == "function"
              ? function (b) {
                  return global.btoa(b);
                }
              : function (b) {
                  if (b.match(/[^\x00-\xFF]/)) throw new RangeError("The string contains invalid characters.");
                  return b.replace(/[\s\S]{1,3}/g, cb_encode);
                };
          var _encode = function (u) {
            return btoa(utob(String(u)));
          };
          var mkUriSafe = function (b64) {
            return b64
              .replace(/[+\/]/g, function (m0) {
                return m0 == "+" ? "-" : "_";
              })
              .replace(/=/g, "");
          };
          var encode = function (u, urisafe) {
            return urisafe ? mkUriSafe(_encode(u)) : _encode(u);
          };
          var encodeURI = function (u) {
            return encode(u, true);
          };
          var fromUint8Array;
          if (global.Uint8Array)
            fromUint8Array = function (a, urisafe) {
              // return btoa(fromCharCode.apply(null, a));
              var b64 = "";
              for (var i = 0, l = a.length; i < l; i += 3) {
                var a0 = a[i],
                  a1 = a[i + 1],
                  a2 = a[i + 2];
                var ord = (a0 << 16) | (a1 << 8) | a2;
                b64 +=
                  b64chars.charAt(ord >>> 18) +
                  b64chars.charAt((ord >>> 12) & 63) +
                  (typeof a1 != "undefined" ? b64chars.charAt((ord >>> 6) & 63) : "=") +
                  (typeof a2 != "undefined" ? b64chars.charAt(ord & 63) : "=");
              }
              return urisafe ? mkUriSafe(b64) : b64;
            };
          // decoder stuff
          var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
          var cb_btou = function (cccc) {
            switch (cccc.length) {
              case 4:
                var cp =
                    ((0x07 & cccc.charCodeAt(0)) << 18) |
                    ((0x3f & cccc.charCodeAt(1)) << 12) |
                    ((0x3f & cccc.charCodeAt(2)) << 6) |
                    (0x3f & cccc.charCodeAt(3)),
                  offset = cp - 0x10000;
                return fromCharCode((offset >>> 10) + 0xd800) + fromCharCode((offset & 0x3ff) + 0xdc00);
              case 3:
                return fromCharCode(
                  ((0x0f & cccc.charCodeAt(0)) << 12) | ((0x3f & cccc.charCodeAt(1)) << 6) | (0x3f & cccc.charCodeAt(2))
                );
              default:
                return fromCharCode(((0x1f & cccc.charCodeAt(0)) << 6) | (0x3f & cccc.charCodeAt(1)));
            }
          };
          var btou = function (b) {
            return b.replace(re_btou, cb_btou);
          };
          var cb_decode = function (cccc) {
            var len = cccc.length,
              padlen = len % 4,
              n =
                (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) |
                (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) |
                (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) |
                (len > 3 ? b64tab[cccc.charAt(3)] : 0),
              chars = [fromCharCode(n >>> 16), fromCharCode((n >>> 8) & 0xff), fromCharCode(n & 0xff)];
            chars.length -= [0, 0, 2, 1][padlen];
            return chars.join("");
          };
          var _atob =
            global.atob && typeof global.atob == "function"
              ? function (a) {
                  return global.atob(a);
                }
              : function (a) {
                  return a.replace(/\S{1,4}/g, cb_decode);
                };
          var atob = function (a) {
            return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ""));
          };
          var _decode = function (a) {
            return btou(_atob(a));
          };
          var _fromURI = function (a) {
            return String(a)
              .replace(/[-_]/g, function (m0) {
                return m0 == "-" ? "+" : "/";
              })
              .replace(/[^A-Za-z0-9\+\/]/g, "");
          };
          var decode = function (a) {
            return _decode(_fromURI(a));
          };
          var toUint8Array;
          if (global.Uint8Array)
            toUint8Array = function (a) {
              return Uint8Array.from(atob(_fromURI(a)), function (c) {
                return c.charCodeAt(0);
              });
            };
          var noConflict = function () {
            var Base64 = global.Base64;
            global.Base64 = _Base64;
            return Base64;
          };
          // export Base64
          global.Base64 = {
            VERSION: version,
            atob: atob,
            btoa: btoa,
            fromBase64: decode,
            toBase64: encode,
            utob: utob,
            encode: encode,
            encodeURI: encodeURI,
            btou: btou,
            decode: decode,
            noConflict: noConflict,
            fromUint8Array: fromUint8Array,
            toUint8Array: toUint8Array
          };
          // if ES5 is available, make Base64.extendString() available
          if (typeof Object.defineProperty === "function") {
            var noEnum = function (v) {
              return { value: v, enumerable: false, writable: true, configurable: true };
            };
            global.Base64.extendString = function () {
              Object.defineProperty(
                String.prototype,
                "fromBase64",
                noEnum(function () {
                  return decode(this);
                })
              );
              Object.defineProperty(
                String.prototype,
                "toBase64",
                noEnum(function (urisafe) {
                  return encode(this, urisafe);
                })
              );
              Object.defineProperty(
                String.prototype,
                "toBase64URI",
                noEnum(function () {
                  return encode(this, true);
                })
              );
            };
          }
          //
          // export Base64 to the namespace
          //
          if (global["Meteor"]) {
            // Meteor.js
            Base64 = global.Base64;
          }
          // module.exports and AMD are mutually exclusive.
          // module.exports has precedence.
          if (true && module.exports) {
            module.exports.Base64 = global.Base64;
          } else if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([], function () {
              return global.Base64;
            });
          }
          // that's it!
          return { Base64: global.Base64 };
        }
      );

      /***/
    },

    /***/ 3094: /***/ function (__unused_webpack_module, exports) {
      (function (global, factory) {
        if (typeof define === "function" && define.amd) {
          define(["exports"], factory);
        } else if (true) {
          factory(exports);
        } else {
          var mod;
        }
      })(
        typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this,
        function (_exports) {
          "use strict";

          Object.defineProperty(_exports, "__esModule", {
            value: true
          });
          _exports.toXML = _exports.default = void 0;

          function _toConsumableArray(arr) {
            return (
              _arrayWithoutHoles(arr) ||
              _iterableToArray(arr) ||
              _unsupportedIterableToArray(arr) ||
              _nonIterableSpread()
            );
          }

          function _nonIterableSpread() {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }

          function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
              return _arrayLikeToArray(o, minLen);
          }

          function _iterableToArray(iter) {
            if ((typeof Symbol !== "undefined" && iter[Symbol.iterator] != null) || iter["@@iterator"] != null)
              return Array.from(iter);
          }

          function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) return _arrayLikeToArray(arr);
          }

          function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for (var i = 0, arr2 = new Array(len); i < len; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }

          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              enumerableOnly &&
                (symbols = symbols.filter(function (sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                })),
                keys.push.apply(keys, symbols);
            }
            return keys;
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = null != arguments[i] ? arguments[i] : {};
              i % 2
                ? ownKeys(Object(source), !0).forEach(function (key) {
                    _defineProperty(target, key, source[key]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
                : ownKeys(Object(source)).forEach(function (key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
            }
            return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }

          function _typeof(obj) {
            "@babel/helpers - typeof";
            return (
              (_typeof =
                "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                  ? function (obj) {
                      return typeof obj;
                    }
                  : function (obj) {
                      return obj &&
                        "function" == typeof Symbol &&
                        obj.constructor === Symbol &&
                        obj !== Symbol.prototype
                        ? "symbol"
                        : typeof obj;
                    }),
              _typeof(obj)
            );
          }

          var ARRAY = "array";
          var BOOLEAN = "boolean";
          var DATE = "date";
          var NULL = "null";
          var NUMBER = "number";
          var OBJECT = "object";
          var SPECIAL_OBJECT = "special-object";
          var STRING = "string";
          var PRIVATE_VARS = ["_selfCloseTag", "_attrs"];
          var PRIVATE_VARS_REGEXP = new RegExp(PRIVATE_VARS.join("|"), "g");
          /**
           * Determines the indent string based on current tree depth.
           */

          var getIndentStr = function getIndentStr() {
            var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return indent.repeat(depth);
          };
          /**
           * Sugar function supplementing JS's quirky typeof operator, plus some extra help to detect
           * "special objects" expected by jstoxml.
           * Example:
           * getType(new Date());
           * -> 'date'
           */

          var getType = function getType(val) {
            return (
              (Array.isArray(val) && ARRAY) ||
              (_typeof(val) === OBJECT && val !== null && val._name && SPECIAL_OBJECT) ||
              (val instanceof Date && DATE) ||
              (val === null && NULL) ||
              _typeof(val)
            );
          };
          /**
           * Replaces matching values in a string with a new value.
           * Example:
           * filterStr('foo&bar', { '&': '&amp;' });
           * -> 'foo&amp;bar'
           */

          var filterStr = function filterStr() {
            var inputStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
            var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // Passthrough/no-op for nonstrings (e.g. number, boolean).
            if (typeof inputStr !== "string") {
              return inputStr;
            }

            var regexp = new RegExp("(".concat(Object.keys(filter).join("|"), ")(?!(\\w|#)*;)"), "g");
            return String(inputStr).replace(regexp, function (str, entity) {
              return filter[entity] || "";
            });
          };
          /**
           * Maps an object or array of arribute keyval pairs to a string.
           * Examples:
           * { foo: 'bar', baz: 'g' } -> 'foo="bar" baz="g"'
           * [ { : true }, { foo: 'bar' } ] -> ' foo="bar"'
           */

          var getAttributeKeyVals = function getAttributeKeyVals() {
            var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var filter = arguments.length > 1 ? arguments[1] : undefined;
            var keyVals = [];

            if (Array.isArray(attributes)) {
              // Array containing complex objects and potentially duplicate attributes.
              keyVals = attributes.map(function (attr) {
                var key = Object.keys(attr)[0];
                var val = attr[key];
                var filteredVal = filter ? filterStr(val, filter) : val;
                var valStr = filteredVal === true ? "" : '="'.concat(filteredVal, '"');
                return "".concat(key).concat(valStr);
              });
            } else {
              var keys = Object.keys(attributes);
              keyVals = keys.map(function (key) {
                // Simple object - keyval pairs.
                // For boolean true, simply output the key.
                var filteredVal = filter ? filterStr(attributes[key], filter) : attributes[key];
                var valStr = attributes[key] === true ? "" : '="'.concat(filteredVal, '"');
                return "".concat(key).concat(valStr);
              });
            }

            return keyVals;
          };
          /**
           * Converts an attributes object/array to a string of keyval pairs.
           * Example:
           * formatAttributes({ a: 1, b: 2 })
           * -> 'a="1" b="2"'
           */

          var formatAttributes = function formatAttributes() {
            var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var filter = arguments.length > 1 ? arguments[1] : undefined;
            var keyVals = getAttributeKeyVals(attributes, filter);
            if (keyVals.length === 0) return "";
            var keysValsJoined = keyVals.join(" ");
            return " ".concat(keysValsJoined);
          };
          /**
           * Converts an object to a jstoxml array.
           * Example:
           * objToArray({ foo: 'bar', baz: 2 });
           * ->
           * [
           *   {
           *     _name: 'foo',
           *     _content: 'bar'
           *   },
           *   {
           *     _name: 'baz',
           *     _content: 2
           *   }
           * ]
           */

          var objToArray = function objToArray() {
            var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return Object.keys(obj).map(function (key) {
              return {
                _name: key,
                _content: obj[key]
              };
            });
          };
          /**
           * Determines if a value is a primitive JavaScript value (not including Symbol).
           * Example:
           * isPrimitive(4);
           * -> true
           */

          var PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN];

          var isPrimitive = function isPrimitive(val) {
            return PRIMITIVE_TYPES.includes(getType(val));
          };
          /**
           * Determines if a value is a simple primitive type that can fit onto one line.  Needed for
           * determining any needed indenting and line breaks.
           * Example:
           * isSimpleType(new Date());
           * -> true
           */

          var SIMPLE_TYPES = [].concat(PRIMITIVE_TYPES, [DATE, SPECIAL_OBJECT]);

          var isSimpleType = function isSimpleType(val) {
            return SIMPLE_TYPES.includes(getType(val));
          };
          /**
           * Determines if an XML string is a simple primitive, or contains nested data.
           * Example:
           * isSimpleXML('<foo />');
           * -> false
           */

          var isSimpleXML = function isSimpleXML(xmlStr) {
            return !xmlStr.match("<");
          };
          /**
           * Assembles an XML header as defined by the config.
           */

          var DEFAULT_XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>';

          var getHeaderString = function getHeaderString(_ref) {
            var header = _ref.header,
              indent = _ref.indent,
              isOutputStart = _ref.isOutputStart;
            var shouldOutputHeader = header && isOutputStart;
            if (!shouldOutputHeader) return "";
            var shouldUseDefaultHeader = _typeof(header) === BOOLEAN; // return `${shouldUseDefaultHeader ? DEFAULT_XML_HEADER : header}${indent ? "\n" : ""
            //   }`;

            return shouldUseDefaultHeader ? DEFAULT_XML_HEADER : header;
          };
          /**
           * Recursively traverses an object tree and converts the output to an XML string.
           * Example:
           * toXML({ foo: 'bar' });
           * -> <foo>bar</foo>
           */

          var defaultEntityFilter = {
            "<": "&lt;",
            ">": "&gt;",
            "&": "&amp;"
          };

          var toXML = function toXML() {
            var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var _config$depth = config.depth,
              depth = _config$depth === void 0 ? 0 : _config$depth,
              indent = config.indent,
              _isFirstItem = config._isFirstItem,
              _config$_isOutputStar = config._isOutputStart,
              _isOutputStart = _config$_isOutputStar === void 0 ? true : _config$_isOutputStar,
              header = config.header,
              _config$attributesFil = config.attributesFilter,
              rawAttributesFilter = _config$attributesFil === void 0 ? {} : _config$attributesFil,
              _config$filter = config.filter,
              rawFilter = _config$filter === void 0 ? {} : _config$filter;

            var shouldTurnOffAttributesFilter = typeof rawAttributesFilter === "boolean" && !rawAttributesFilter;
            var attributesFilter = shouldTurnOffAttributesFilter
              ? {}
              : _objectSpread(
                  _objectSpread(_objectSpread({}, defaultEntityFilter), {
                    '"': "&quot;"
                  }),
                  rawAttributesFilter
                );
            var shouldTurnOffFilter = typeof rawFilter === "boolean" && !rawFilter;
            var filter = shouldTurnOffFilter ? {} : _objectSpread(_objectSpread({}, defaultEntityFilter), rawFilter); // Determine indent string based on depth.

            var indentStr = getIndentStr(indent, depth); // For branching based on value type.

            var valType = getType(obj);
            var headerStr = getHeaderString({
              header: header,
              indent: indent,
              depth: depth,
              isOutputStart: _isOutputStart
            });
            var isOutputStart = _isOutputStart && !headerStr && _isFirstItem && depth === 0;
            var outputStr = "";

            switch (valType) {
              case "special-object": {
                // Processes a specially-formatted object used by jstoxml.
                var _name = obj._name,
                  _content = obj._content; // Output text content without a tag wrapper.

                if (_content === null) {
                  outputStr = _name;
                  break;
                } // Handles arrays of primitive values. (#33)

                var isArrayOfPrimitives = Array.isArray(_content) && _content.every(isPrimitive);

                if (isArrayOfPrimitives) {
                  var primitives = _content.map(function (a) {
                    return toXML(
                      {
                        _name: _name,
                        _content: a
                      },
                      _objectSpread(
                        _objectSpread({}, config),
                        {},
                        {
                          depth: depth,
                          _isOutputStart: false
                        }
                      )
                    );
                  });

                  return primitives.join("");
                } // Don't output private vars (such as _attrs).

                if (_name.match(PRIVATE_VARS_REGEXP)) break; // Process the nested new value and create new config.

                var newVal = toXML(
                  _content,
                  _objectSpread(
                    _objectSpread({}, config),
                    {},
                    {
                      depth: depth + 1,
                      _isOutputStart: isOutputStart
                    }
                  )
                );
                var newValType = getType(newVal);
                var isNewValSimple = isSimpleXML(newVal); // Pre-tag output (indent and line breaks).

                var preIndentStr = indent && !isOutputStart ? "\n" : "";
                var preTag = "".concat(preIndentStr).concat(indentStr); // Special handling for comments, preserving preceding line breaks/indents.

                if (_name === "_comment") {
                  outputStr += "".concat(preTag, "<!-- ").concat(_content, " -->");
                  break;
                } // Tag output.

                var valIsEmpty = newValType === "undefined" || newVal === "";
                var shouldSelfClose =
                  _typeof(obj._selfCloseTag) === BOOLEAN ? valIsEmpty && obj._selfCloseTag : valIsEmpty;
                var selfCloseStr = shouldSelfClose ? "/" : "";
                var attributesString = formatAttributes(obj._attrs, attributesFilter);
                var tag = "<".concat(_name).concat(attributesString).concat(selfCloseStr, ">"); // Post-tag output (closing tag, indent, line breaks).

                var preTagCloseStr = indent && !isNewValSimple ? "\n".concat(indentStr) : "";
                var postTag = !shouldSelfClose ? "".concat(newVal).concat(preTagCloseStr, "</").concat(_name, ">") : "";
                outputStr += "".concat(preTag).concat(tag).concat(postTag);
                break;
              }

              case "object": {
                // Iterates over keyval pairs in an object, converting each item to a special-object.
                var keys = Object.keys(obj);
                var outputArr = keys.map(function (key, index) {
                  var newConfig = _objectSpread(
                    _objectSpread({}, config),
                    {},
                    {
                      _isFirstItem: index === 0,
                      _isLastItem: index + 1 === keys.length,
                      _isOutputStart: isOutputStart
                    }
                  );

                  var outputObj = {
                    _name: key
                  };

                  if (getType(obj[key]) === "object") {
                    // Sub-object contains an object.
                    // Move private vars up as needed.  Needed to support certain types of objects
                    // E.g. { foo: { _attrs: { a: 1 } } } -> <foo a="1"/>
                    PRIVATE_VARS.forEach(function (privateVar) {
                      var val = obj[key][privateVar];

                      if (typeof val !== "undefined") {
                        outputObj[privateVar] = val;
                        delete obj[key][privateVar];
                      }
                    });
                    var hasContent = typeof obj[key]._content !== "undefined";

                    if (hasContent) {
                      // _content has sibling keys, so pass as an array (edge case).
                      // E.g. { foo: 'bar', _content: { baz: 2 } } -> <foo>bar</foo><baz>2</baz>
                      if (Object.keys(obj[key]).length > 1) {
                        var newContentObj = Object.assign({}, obj[key]);
                        delete newContentObj._content;
                        outputObj._content = [].concat(_toConsumableArray(objToArray(newContentObj)), [
                          obj[key]._content
                        ]);
                      }
                    }
                  } // Fallthrough: just pass the key as the content for the new special-object.

                  if (typeof outputObj._content === "undefined") outputObj._content = obj[key];
                  var xml = toXML(outputObj, newConfig, key);
                  return xml;
                }, config);
                outputStr = outputArr.join("");
                break;
              }

              case "function": {
                // Executes a user-defined function and returns output.
                var fnResult = obj(config);
                outputStr = toXML(fnResult, config);
                break;
              }

              case "array": {
                // Iterates and converts each value in an array.
                var _outputArr = obj.map(function (singleVal, index) {
                  var newConfig = _objectSpread(
                    _objectSpread({}, config),
                    {},
                    {
                      _isFirstItem: index === 0,
                      _isLastItem: index + 1 === obj.length,
                      _isOutputStart: isOutputStart
                    }
                  );

                  return toXML(singleVal, newConfig);
                });

                outputStr = _outputArr.join("");
                break;
              }
              // number, string, boolean, date, null, etc

              default: {
                outputStr = filterStr(obj, filter);
                break;
              }
            }

            return "".concat(headerStr).concat(outputStr);
          };

          _exports.toXML = toXML;
          var _default = {
            toXML: toXML
          };
          _exports.default = _default;
        }
      );

      /***/
    },

    /***/ 1149: /***/ (module) => {
      "use strict";
      /*!
       * merge-descriptors
       * Copyright(c) 2014 Jonathan Ong
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */

      /**
       * Module exports.
       * @public
       */

      module.exports = merge;

      /**
       * Module variables.
       * @private
       */

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      /**
       * Merge the property descriptors of `src` into `dest`
       *
       * @param {object} dest Object to add descriptors to
       * @param {object} src Object to clone descriptors from
       * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
       * @returns {object} Reference to dest
       * @public
       */

      function merge(dest, src, redefine) {
        if (!dest) {
          throw new TypeError("argument dest is required");
        }

        if (!src) {
          throw new TypeError("argument src is required");
        }

        if (redefine === undefined) {
          // Default to true
          redefine = true;
        }

        Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
          if (!redefine && hasOwnProperty.call(dest, name)) {
            // Skip desriptor
            return;
          }

          // Copy descriptor
          var descriptor = Object.getOwnPropertyDescriptor(src, name);
          Object.defineProperty(dest, name, descriptor);
        });

        return dest;
      }

      /***/
    },

    /***/ 6038: /***/ (module) => {
      "use strict";

      /**
       * @param typeMap [Object] Map of MIME type -> Array[extensions]
       * @param ...
       */
      function Mime() {
        this._types = Object.create(null);
        this._extensions = Object.create(null);

        for (let i = 0; i < arguments.length; i++) {
          this.define(arguments[i]);
        }

        this.define = this.define.bind(this);
        this.getType = this.getType.bind(this);
        this.getExtension = this.getExtension.bind(this);
      }

      /**
       * Define mimetype -> extension mappings.  Each key is a mime-type that maps
       * to an array of extensions associated with the type.  The first extension is
       * used as the default extension for the type.
       *
       * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
       *
       * If a type declares an extension that has already been defined, an error will
       * be thrown.  To suppress this error and force the extension to be associated
       * with the new type, pass `force`=true.  Alternatively, you may prefix the
       * extension with "*" to map the type to extension, without mapping the
       * extension to the type.
       *
       * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
       *
       *
       * @param map (Object) type definitions
       * @param force (Boolean) if true, force overriding of existing definitions
       */
      Mime.prototype.define = function (typeMap, force) {
        for (let type in typeMap) {
          let extensions = typeMap[type].map(function (t) {
            return t.toLowerCase();
          });
          type = type.toLowerCase();

          for (let i = 0; i < extensions.length; i++) {
            const ext = extensions[i];

            // '*' prefix = not the preferred type for this extension.  So fixup the
            // extension, and skip it.
            if (ext[0] === "*") {
              continue;
            }

            if (!force && ext in this._types) {
              throw new Error(
                'Attempt to change mapping for "' +
                  ext +
                  '" extension from "' +
                  this._types[ext] +
                  '" to "' +
                  type +
                  '". Pass `force=true` to allow this, otherwise remove "' +
                  ext +
                  '" from the list of extensions for "' +
                  type +
                  '".'
              );
            }

            this._types[ext] = type;
          }

          // Use first extension as default
          if (force || !this._extensions[type]) {
            const ext = extensions[0];
            this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
          }
        }
      };

      /**
       * Lookup a mime type based on extension
       */
      Mime.prototype.getType = function (path) {
        path = String(path);
        let last = path.replace(/^.*[/\\]/, "").toLowerCase();
        let ext = last.replace(/^.*\./, "").toLowerCase();

        let hasPath = last.length < path.length;
        let hasDot = ext.length < last.length - 1;

        return ((hasDot || !hasPath) && this._types[ext]) || null;
      };

      /**
       * Return file extension associated with a mime type
       */
      Mime.prototype.getExtension = function (type) {
        type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
        return (type && this._extensions[type.toLowerCase()]) || null;
      };

      module.exports = Mime;

      /***/
    },

    /***/ 9994: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      let Mime = __nccwpck_require__(6038);
      module.exports = new Mime(__nccwpck_require__(3114), __nccwpck_require__(8809));

      /***/
    },

    /***/ 8809: /***/ (module) => {
      module.exports = {
        "application/prs.cww": ["cww"],
        "application/vnd.1000minds.decision-model+xml": ["1km"],
        "application/vnd.3gpp.pic-bw-large": ["plb"],
        "application/vnd.3gpp.pic-bw-small": ["psb"],
        "application/vnd.3gpp.pic-bw-var": ["pvb"],
        "application/vnd.3gpp2.tcap": ["tcap"],
        "application/vnd.3m.post-it-notes": ["pwn"],
        "application/vnd.accpac.simply.aso": ["aso"],
        "application/vnd.accpac.simply.imp": ["imp"],
        "application/vnd.acucobol": ["acu"],
        "application/vnd.acucorp": ["atc", "acutc"],
        "application/vnd.adobe.air-application-installer-package+zip": ["air"],
        "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
        "application/vnd.adobe.fxp": ["fxp", "fxpl"],
        "application/vnd.adobe.xdp+xml": ["xdp"],
        "application/vnd.adobe.xfdf": ["xfdf"],
        "application/vnd.ahead.space": ["ahead"],
        "application/vnd.airzip.filesecure.azf": ["azf"],
        "application/vnd.airzip.filesecure.azs": ["azs"],
        "application/vnd.amazon.ebook": ["azw"],
        "application/vnd.americandynamics.acc": ["acc"],
        "application/vnd.amiga.ami": ["ami"],
        "application/vnd.android.package-archive": ["apk"],
        "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
        "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
        "application/vnd.antix.game-component": ["atx"],
        "application/vnd.apple.installer+xml": ["mpkg"],
        "application/vnd.apple.keynote": ["key"],
        "application/vnd.apple.mpegurl": ["m3u8"],
        "application/vnd.apple.numbers": ["numbers"],
        "application/vnd.apple.pages": ["pages"],
        "application/vnd.apple.pkpass": ["pkpass"],
        "application/vnd.aristanetworks.swi": ["swi"],
        "application/vnd.astraea-software.iota": ["iota"],
        "application/vnd.audiograph": ["aep"],
        "application/vnd.balsamiq.bmml+xml": ["bmml"],
        "application/vnd.blueice.multipass": ["mpm"],
        "application/vnd.bmi": ["bmi"],
        "application/vnd.businessobjects": ["rep"],
        "application/vnd.chemdraw+xml": ["cdxml"],
        "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
        "application/vnd.cinderella": ["cdy"],
        "application/vnd.citationstyles.style+xml": ["csl"],
        "application/vnd.claymore": ["cla"],
        "application/vnd.cloanto.rp9": ["rp9"],
        "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
        "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
        "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
        "application/vnd.commonspace": ["csp"],
        "application/vnd.contact.cmsg": ["cdbcmsg"],
        "application/vnd.cosmocaller": ["cmc"],
        "application/vnd.crick.clicker": ["clkx"],
        "application/vnd.crick.clicker.keyboard": ["clkk"],
        "application/vnd.crick.clicker.palette": ["clkp"],
        "application/vnd.crick.clicker.template": ["clkt"],
        "application/vnd.crick.clicker.wordbank": ["clkw"],
        "application/vnd.criticaltools.wbs+xml": ["wbs"],
        "application/vnd.ctc-posml": ["pml"],
        "application/vnd.cups-ppd": ["ppd"],
        "application/vnd.curl.car": ["car"],
        "application/vnd.curl.pcurl": ["pcurl"],
        "application/vnd.dart": ["dart"],
        "application/vnd.data-vision.rdz": ["rdz"],
        "application/vnd.dbf": ["dbf"],
        "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
        "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
        "application/vnd.dece.unspecified": ["uvx", "uvvx"],
        "application/vnd.dece.zip": ["uvz", "uvvz"],
        "application/vnd.denovo.fcselayout-link": ["fe_launch"],
        "application/vnd.dna": ["dna"],
        "application/vnd.dolby.mlp": ["mlp"],
        "application/vnd.dpgraph": ["dpg"],
        "application/vnd.dreamfactory": ["dfac"],
        "application/vnd.ds-keypoint": ["kpxx"],
        "application/vnd.dvb.ait": ["ait"],
        "application/vnd.dvb.service": ["svc"],
        "application/vnd.dynageo": ["geo"],
        "application/vnd.ecowin.chart": ["mag"],
        "application/vnd.enliven": ["nml"],
        "application/vnd.epson.esf": ["esf"],
        "application/vnd.epson.msf": ["msf"],
        "application/vnd.epson.quickanime": ["qam"],
        "application/vnd.epson.salt": ["slt"],
        "application/vnd.epson.ssf": ["ssf"],
        "application/vnd.eszigno3+xml": ["es3", "et3"],
        "application/vnd.ezpix-album": ["ez2"],
        "application/vnd.ezpix-package": ["ez3"],
        "application/vnd.fdf": ["fdf"],
        "application/vnd.fdsn.mseed": ["mseed"],
        "application/vnd.fdsn.seed": ["seed", "dataless"],
        "application/vnd.flographit": ["gph"],
        "application/vnd.fluxtime.clip": ["ftc"],
        "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
        "application/vnd.frogans.fnc": ["fnc"],
        "application/vnd.frogans.ltf": ["ltf"],
        "application/vnd.fsc.weblaunch": ["fsc"],
        "application/vnd.fujitsu.oasys": ["oas"],
        "application/vnd.fujitsu.oasys2": ["oa2"],
        "application/vnd.fujitsu.oasys3": ["oa3"],
        "application/vnd.fujitsu.oasysgp": ["fg5"],
        "application/vnd.fujitsu.oasysprs": ["bh2"],
        "application/vnd.fujixerox.ddd": ["ddd"],
        "application/vnd.fujixerox.docuworks": ["xdw"],
        "application/vnd.fujixerox.docuworks.binder": ["xbd"],
        "application/vnd.fuzzysheet": ["fzs"],
        "application/vnd.genomatix.tuxedo": ["txd"],
        "application/vnd.geogebra.file": ["ggb"],
        "application/vnd.geogebra.tool": ["ggt"],
        "application/vnd.geometry-explorer": ["gex", "gre"],
        "application/vnd.geonext": ["gxt"],
        "application/vnd.geoplan": ["g2w"],
        "application/vnd.geospace": ["g3w"],
        "application/vnd.gmx": ["gmx"],
        "application/vnd.google-apps.document": ["gdoc"],
        "application/vnd.google-apps.presentation": ["gslides"],
        "application/vnd.google-apps.spreadsheet": ["gsheet"],
        "application/vnd.google-earth.kml+xml": ["kml"],
        "application/vnd.google-earth.kmz": ["kmz"],
        "application/vnd.grafeq": ["gqf", "gqs"],
        "application/vnd.groove-account": ["gac"],
        "application/vnd.groove-help": ["ghf"],
        "application/vnd.groove-identity-message": ["gim"],
        "application/vnd.groove-injector": ["grv"],
        "application/vnd.groove-tool-message": ["gtm"],
        "application/vnd.groove-tool-template": ["tpl"],
        "application/vnd.groove-vcard": ["vcg"],
        "application/vnd.hal+xml": ["hal"],
        "application/vnd.handheld-entertainment+xml": ["zmm"],
        "application/vnd.hbci": ["hbci"],
        "application/vnd.hhe.lesson-player": ["les"],
        "application/vnd.hp-hpgl": ["hpgl"],
        "application/vnd.hp-hpid": ["hpid"],
        "application/vnd.hp-hps": ["hps"],
        "application/vnd.hp-jlyt": ["jlt"],
        "application/vnd.hp-pcl": ["pcl"],
        "application/vnd.hp-pclxl": ["pclxl"],
        "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
        "application/vnd.ibm.minipay": ["mpy"],
        "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
        "application/vnd.ibm.rights-management": ["irm"],
        "application/vnd.ibm.secure-container": ["sc"],
        "application/vnd.iccprofile": ["icc", "icm"],
        "application/vnd.igloader": ["igl"],
        "application/vnd.immervision-ivp": ["ivp"],
        "application/vnd.immervision-ivu": ["ivu"],
        "application/vnd.insors.igm": ["igm"],
        "application/vnd.intercon.formnet": ["xpw", "xpx"],
        "application/vnd.intergeo": ["i2g"],
        "application/vnd.intu.qbo": ["qbo"],
        "application/vnd.intu.qfx": ["qfx"],
        "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
        "application/vnd.irepository.package+xml": ["irp"],
        "application/vnd.is-xpr": ["xpr"],
        "application/vnd.isac.fcs": ["fcs"],
        "application/vnd.jam": ["jam"],
        "application/vnd.jcp.javame.midlet-rms": ["rms"],
        "application/vnd.jisp": ["jisp"],
        "application/vnd.joost.joda-archive": ["joda"],
        "application/vnd.kahootz": ["ktz", "ktr"],
        "application/vnd.kde.karbon": ["karbon"],
        "application/vnd.kde.kchart": ["chrt"],
        "application/vnd.kde.kformula": ["kfo"],
        "application/vnd.kde.kivio": ["flw"],
        "application/vnd.kde.kontour": ["kon"],
        "application/vnd.kde.kpresenter": ["kpr", "kpt"],
        "application/vnd.kde.kspread": ["ksp"],
        "application/vnd.kde.kword": ["kwd", "kwt"],
        "application/vnd.kenameaapp": ["htke"],
        "application/vnd.kidspiration": ["kia"],
        "application/vnd.kinar": ["kne", "knp"],
        "application/vnd.koan": ["skp", "skd", "skt", "skm"],
        "application/vnd.kodak-descriptor": ["sse"],
        "application/vnd.las.las+xml": ["lasxml"],
        "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
        "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
        "application/vnd.lotus-1-2-3": ["123"],
        "application/vnd.lotus-approach": ["apr"],
        "application/vnd.lotus-freelance": ["pre"],
        "application/vnd.lotus-notes": ["nsf"],
        "application/vnd.lotus-organizer": ["org"],
        "application/vnd.lotus-screencam": ["scm"],
        "application/vnd.lotus-wordpro": ["lwp"],
        "application/vnd.macports.portpkg": ["portpkg"],
        "application/vnd.mapbox-vector-tile": ["mvt"],
        "application/vnd.mcd": ["mcd"],
        "application/vnd.medcalcdata": ["mc1"],
        "application/vnd.mediastation.cdkey": ["cdkey"],
        "application/vnd.mfer": ["mwf"],
        "application/vnd.mfmp": ["mfm"],
        "application/vnd.micrografx.flo": ["flo"],
        "application/vnd.micrografx.igx": ["igx"],
        "application/vnd.mif": ["mif"],
        "application/vnd.mobius.daf": ["daf"],
        "application/vnd.mobius.dis": ["dis"],
        "application/vnd.mobius.mbk": ["mbk"],
        "application/vnd.mobius.mqy": ["mqy"],
        "application/vnd.mobius.msl": ["msl"],
        "application/vnd.mobius.plc": ["plc"],
        "application/vnd.mobius.txf": ["txf"],
        "application/vnd.mophun.application": ["mpn"],
        "application/vnd.mophun.certificate": ["mpc"],
        "application/vnd.mozilla.xul+xml": ["xul"],
        "application/vnd.ms-artgalry": ["cil"],
        "application/vnd.ms-cab-compressed": ["cab"],
        "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
        "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
        "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
        "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
        "application/vnd.ms-fontobject": ["eot"],
        "application/vnd.ms-htmlhelp": ["chm"],
        "application/vnd.ms-ims": ["ims"],
        "application/vnd.ms-lrm": ["lrm"],
        "application/vnd.ms-officetheme": ["thmx"],
        "application/vnd.ms-outlook": ["msg"],
        "application/vnd.ms-pki.seccat": ["cat"],
        "application/vnd.ms-pki.stl": ["*stl"],
        "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
        "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
        "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
        "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
        "application/vnd.ms-project": ["mpp", "mpt"],
        "application/vnd.ms-word.document.macroenabled.12": ["docm"],
        "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
        "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
        "application/vnd.ms-wpl": ["wpl"],
        "application/vnd.ms-xpsdocument": ["xps"],
        "application/vnd.mseq": ["mseq"],
        "application/vnd.musician": ["mus"],
        "application/vnd.muvee.style": ["msty"],
        "application/vnd.mynfc": ["taglet"],
        "application/vnd.neurolanguage.nlu": ["nlu"],
        "application/vnd.nitf": ["ntf", "nitf"],
        "application/vnd.noblenet-directory": ["nnd"],
        "application/vnd.noblenet-sealer": ["nns"],
        "application/vnd.noblenet-web": ["nnw"],
        "application/vnd.nokia.n-gage.ac+xml": ["*ac"],
        "application/vnd.nokia.n-gage.data": ["ngdat"],
        "application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
        "application/vnd.nokia.radio-preset": ["rpst"],
        "application/vnd.nokia.radio-presets": ["rpss"],
        "application/vnd.novadigm.edm": ["edm"],
        "application/vnd.novadigm.edx": ["edx"],
        "application/vnd.novadigm.ext": ["ext"],
        "application/vnd.oasis.opendocument.chart": ["odc"],
        "application/vnd.oasis.opendocument.chart-template": ["otc"],
        "application/vnd.oasis.opendocument.database": ["odb"],
        "application/vnd.oasis.opendocument.formula": ["odf"],
        "application/vnd.oasis.opendocument.formula-template": ["odft"],
        "application/vnd.oasis.opendocument.graphics": ["odg"],
        "application/vnd.oasis.opendocument.graphics-template": ["otg"],
        "application/vnd.oasis.opendocument.image": ["odi"],
        "application/vnd.oasis.opendocument.image-template": ["oti"],
        "application/vnd.oasis.opendocument.presentation": ["odp"],
        "application/vnd.oasis.opendocument.presentation-template": ["otp"],
        "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
        "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
        "application/vnd.oasis.opendocument.text": ["odt"],
        "application/vnd.oasis.opendocument.text-master": ["odm"],
        "application/vnd.oasis.opendocument.text-template": ["ott"],
        "application/vnd.oasis.opendocument.text-web": ["oth"],
        "application/vnd.olpc-sugar": ["xo"],
        "application/vnd.oma.dd2+xml": ["dd2"],
        "application/vnd.openblox.game+xml": ["obgx"],
        "application/vnd.openofficeorg.extension": ["oxt"],
        "application/vnd.openstreetmap.data+xml": ["osm"],
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
        "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
        "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
        "application/vnd.osgeo.mapguide.package": ["mgp"],
        "application/vnd.osgi.dp": ["dp"],
        "application/vnd.osgi.subsystem": ["esa"],
        "application/vnd.palm": ["pdb", "pqa", "oprc"],
        "application/vnd.pawaafile": ["paw"],
        "application/vnd.pg.format": ["str"],
        "application/vnd.pg.osasli": ["ei6"],
        "application/vnd.picsel": ["efif"],
        "application/vnd.pmi.widget": ["wg"],
        "application/vnd.pocketlearn": ["plf"],
        "application/vnd.powerbuilder6": ["pbd"],
        "application/vnd.previewsystems.box": ["box"],
        "application/vnd.proteus.magazine": ["mgz"],
        "application/vnd.publishare-delta-tree": ["qps"],
        "application/vnd.pvi.ptid1": ["ptid"],
        "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
        "application/vnd.rar": ["rar"],
        "application/vnd.realvnc.bed": ["bed"],
        "application/vnd.recordare.musicxml": ["mxl"],
        "application/vnd.recordare.musicxml+xml": ["musicxml"],
        "application/vnd.rig.cryptonote": ["cryptonote"],
        "application/vnd.rim.cod": ["cod"],
        "application/vnd.rn-realmedia": ["rm"],
        "application/vnd.rn-realmedia-vbr": ["rmvb"],
        "application/vnd.route66.link66+xml": ["link66"],
        "application/vnd.sailingtracker.track": ["st"],
        "application/vnd.seemail": ["see"],
        "application/vnd.sema": ["sema"],
        "application/vnd.semd": ["semd"],
        "application/vnd.semf": ["semf"],
        "application/vnd.shana.informed.formdata": ["ifm"],
        "application/vnd.shana.informed.formtemplate": ["itp"],
        "application/vnd.shana.informed.interchange": ["iif"],
        "application/vnd.shana.informed.package": ["ipk"],
        "application/vnd.simtech-mindmapper": ["twd", "twds"],
        "application/vnd.smaf": ["mmf"],
        "application/vnd.smart.teacher": ["teacher"],
        "application/vnd.software602.filler.form+xml": ["fo"],
        "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
        "application/vnd.spotfire.dxp": ["dxp"],
        "application/vnd.spotfire.sfs": ["sfs"],
        "application/vnd.stardivision.calc": ["sdc"],
        "application/vnd.stardivision.draw": ["sda"],
        "application/vnd.stardivision.impress": ["sdd"],
        "application/vnd.stardivision.math": ["smf"],
        "application/vnd.stardivision.writer": ["sdw", "vor"],
        "application/vnd.stardivision.writer-global": ["sgl"],
        "application/vnd.stepmania.package": ["smzip"],
        "application/vnd.stepmania.stepchart": ["sm"],
        "application/vnd.sun.wadl+xml": ["wadl"],
        "application/vnd.sun.xml.calc": ["sxc"],
        "application/vnd.sun.xml.calc.template": ["stc"],
        "application/vnd.sun.xml.draw": ["sxd"],
        "application/vnd.sun.xml.draw.template": ["std"],
        "application/vnd.sun.xml.impress": ["sxi"],
        "application/vnd.sun.xml.impress.template": ["sti"],
        "application/vnd.sun.xml.math": ["sxm"],
        "application/vnd.sun.xml.writer": ["sxw"],
        "application/vnd.sun.xml.writer.global": ["sxg"],
        "application/vnd.sun.xml.writer.template": ["stw"],
        "application/vnd.sus-calendar": ["sus", "susp"],
        "application/vnd.svd": ["svd"],
        "application/vnd.symbian.install": ["sis", "sisx"],
        "application/vnd.syncml+xml": ["xsm"],
        "application/vnd.syncml.dm+wbxml": ["bdm"],
        "application/vnd.syncml.dm+xml": ["xdm"],
        "application/vnd.syncml.dmddf+xml": ["ddf"],
        "application/vnd.tao.intent-module-archive": ["tao"],
        "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
        "application/vnd.tmobile-livetv": ["tmo"],
        "application/vnd.trid.tpt": ["tpt"],
        "application/vnd.triscape.mxs": ["mxs"],
        "application/vnd.trueapp": ["tra"],
        "application/vnd.ufdl": ["ufd", "ufdl"],
        "application/vnd.uiq.theme": ["utz"],
        "application/vnd.umajin": ["umj"],
        "application/vnd.unity": ["unityweb"],
        "application/vnd.uoml+xml": ["uoml"],
        "application/vnd.vcx": ["vcx"],
        "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
        "application/vnd.visionary": ["vis"],
        "application/vnd.vsf": ["vsf"],
        "application/vnd.wap.wbxml": ["wbxml"],
        "application/vnd.wap.wmlc": ["wmlc"],
        "application/vnd.wap.wmlscriptc": ["wmlsc"],
        "application/vnd.webturbo": ["wtb"],
        "application/vnd.wolfram.player": ["nbp"],
        "application/vnd.wordperfect": ["wpd"],
        "application/vnd.wqd": ["wqd"],
        "application/vnd.wt.stf": ["stf"],
        "application/vnd.xara": ["xar"],
        "application/vnd.xfdl": ["xfdl"],
        "application/vnd.yamaha.hv-dic": ["hvd"],
        "application/vnd.yamaha.hv-script": ["hvs"],
        "application/vnd.yamaha.hv-voice": ["hvp"],
        "application/vnd.yamaha.openscoreformat": ["osf"],
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
        "application/vnd.yamaha.smaf-audio": ["saf"],
        "application/vnd.yamaha.smaf-phrase": ["spf"],
        "application/vnd.yellowriver-custom-menu": ["cmp"],
        "application/vnd.zul": ["zir", "zirz"],
        "application/vnd.zzazz.deck+xml": ["zaz"],
        "application/x-7z-compressed": ["7z"],
        "application/x-abiword": ["abw"],
        "application/x-ace-compressed": ["ace"],
        "application/x-apple-diskimage": ["*dmg"],
        "application/x-arj": ["arj"],
        "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
        "application/x-authorware-map": ["aam"],
        "application/x-authorware-seg": ["aas"],
        "application/x-bcpio": ["bcpio"],
        "application/x-bdoc": ["*bdoc"],
        "application/x-bittorrent": ["torrent"],
        "application/x-blorb": ["blb", "blorb"],
        "application/x-bzip": ["bz"],
        "application/x-bzip2": ["bz2", "boz"],
        "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
        "application/x-cdlink": ["vcd"],
        "application/x-cfs-compressed": ["cfs"],
        "application/x-chat": ["chat"],
        "application/x-chess-pgn": ["pgn"],
        "application/x-chrome-extension": ["crx"],
        "application/x-cocoa": ["cco"],
        "application/x-conference": ["nsc"],
        "application/x-cpio": ["cpio"],
        "application/x-csh": ["csh"],
        "application/x-debian-package": ["*deb", "udeb"],
        "application/x-dgc-compressed": ["dgc"],
        "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
        "application/x-doom": ["wad"],
        "application/x-dtbncx+xml": ["ncx"],
        "application/x-dtbook+xml": ["dtb"],
        "application/x-dtbresource+xml": ["res"],
        "application/x-dvi": ["dvi"],
        "application/x-envoy": ["evy"],
        "application/x-eva": ["eva"],
        "application/x-font-bdf": ["bdf"],
        "application/x-font-ghostscript": ["gsf"],
        "application/x-font-linux-psf": ["psf"],
        "application/x-font-pcf": ["pcf"],
        "application/x-font-snf": ["snf"],
        "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
        "application/x-freearc": ["arc"],
        "application/x-futuresplash": ["spl"],
        "application/x-gca-compressed": ["gca"],
        "application/x-glulx": ["ulx"],
        "application/x-gnumeric": ["gnumeric"],
        "application/x-gramps-xml": ["gramps"],
        "application/x-gtar": ["gtar"],
        "application/x-hdf": ["hdf"],
        "application/x-httpd-php": ["php"],
        "application/x-install-instructions": ["install"],
        "application/x-iso9660-image": ["*iso"],
        "application/x-iwork-keynote-sffkey": ["*key"],
        "application/x-iwork-numbers-sffnumbers": ["*numbers"],
        "application/x-iwork-pages-sffpages": ["*pages"],
        "application/x-java-archive-diff": ["jardiff"],
        "application/x-java-jnlp-file": ["jnlp"],
        "application/x-keepass2": ["kdbx"],
        "application/x-latex": ["latex"],
        "application/x-lua-bytecode": ["luac"],
        "application/x-lzh-compressed": ["lzh", "lha"],
        "application/x-makeself": ["run"],
        "application/x-mie": ["mie"],
        "application/x-mobipocket-ebook": ["prc", "mobi"],
        "application/x-ms-application": ["application"],
        "application/x-ms-shortcut": ["lnk"],
        "application/x-ms-wmd": ["wmd"],
        "application/x-ms-wmz": ["wmz"],
        "application/x-ms-xbap": ["xbap"],
        "application/x-msaccess": ["mdb"],
        "application/x-msbinder": ["obd"],
        "application/x-mscardfile": ["crd"],
        "application/x-msclip": ["clp"],
        "application/x-msdos-program": ["*exe"],
        "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"],
        "application/x-msmediaview": ["mvb", "m13", "m14"],
        "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"],
        "application/x-msmoney": ["mny"],
        "application/x-mspublisher": ["pub"],
        "application/x-msschedule": ["scd"],
        "application/x-msterminal": ["trm"],
        "application/x-mswrite": ["wri"],
        "application/x-netcdf": ["nc", "cdf"],
        "application/x-ns-proxy-autoconfig": ["pac"],
        "application/x-nzb": ["nzb"],
        "application/x-perl": ["pl", "pm"],
        "application/x-pilot": ["*prc", "*pdb"],
        "application/x-pkcs12": ["p12", "pfx"],
        "application/x-pkcs7-certificates": ["p7b", "spc"],
        "application/x-pkcs7-certreqresp": ["p7r"],
        "application/x-rar-compressed": ["*rar"],
        "application/x-redhat-package-manager": ["rpm"],
        "application/x-research-info-systems": ["ris"],
        "application/x-sea": ["sea"],
        "application/x-sh": ["sh"],
        "application/x-shar": ["shar"],
        "application/x-shockwave-flash": ["swf"],
        "application/x-silverlight-app": ["xap"],
        "application/x-sql": ["sql"],
        "application/x-stuffit": ["sit"],
        "application/x-stuffitx": ["sitx"],
        "application/x-subrip": ["srt"],
        "application/x-sv4cpio": ["sv4cpio"],
        "application/x-sv4crc": ["sv4crc"],
        "application/x-t3vm-image": ["t3"],
        "application/x-tads": ["gam"],
        "application/x-tar": ["tar"],
        "application/x-tcl": ["tcl", "tk"],
        "application/x-tex": ["tex"],
        "application/x-tex-tfm": ["tfm"],
        "application/x-texinfo": ["texinfo", "texi"],
        "application/x-tgif": ["*obj"],
        "application/x-ustar": ["ustar"],
        "application/x-virtualbox-hdd": ["hdd"],
        "application/x-virtualbox-ova": ["ova"],
        "application/x-virtualbox-ovf": ["ovf"],
        "application/x-virtualbox-vbox": ["vbox"],
        "application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
        "application/x-virtualbox-vdi": ["vdi"],
        "application/x-virtualbox-vhd": ["vhd"],
        "application/x-virtualbox-vmdk": ["vmdk"],
        "application/x-wais-source": ["src"],
        "application/x-web-app-manifest+json": ["webapp"],
        "application/x-x509-ca-cert": ["der", "crt", "pem"],
        "application/x-xfig": ["fig"],
        "application/x-xliff+xml": ["*xlf"],
        "application/x-xpinstall": ["xpi"],
        "application/x-xz": ["xz"],
        "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
        "audio/vnd.dece.audio": ["uva", "uvva"],
        "audio/vnd.digital-winds": ["eol"],
        "audio/vnd.dra": ["dra"],
        "audio/vnd.dts": ["dts"],
        "audio/vnd.dts.hd": ["dtshd"],
        "audio/vnd.lucent.voice": ["lvp"],
        "audio/vnd.ms-playready.media.pya": ["pya"],
        "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
        "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
        "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
        "audio/vnd.rip": ["rip"],
        "audio/x-aac": ["aac"],
        "audio/x-aiff": ["aif", "aiff", "aifc"],
        "audio/x-caf": ["caf"],
        "audio/x-flac": ["flac"],
        "audio/x-m4a": ["*m4a"],
        "audio/x-matroska": ["mka"],
        "audio/x-mpegurl": ["m3u"],
        "audio/x-ms-wax": ["wax"],
        "audio/x-ms-wma": ["wma"],
        "audio/x-pn-realaudio": ["ram", "ra"],
        "audio/x-pn-realaudio-plugin": ["rmp"],
        "audio/x-realaudio": ["*ra"],
        "audio/x-wav": ["*wav"],
        "chemical/x-cdx": ["cdx"],
        "chemical/x-cif": ["cif"],
        "chemical/x-cmdf": ["cmdf"],
        "chemical/x-cml": ["cml"],
        "chemical/x-csml": ["csml"],
        "chemical/x-xyz": ["xyz"],
        "image/prs.btif": ["btif"],
        "image/prs.pti": ["pti"],
        "image/vnd.adobe.photoshop": ["psd"],
        "image/vnd.airzip.accelerator.azv": ["azv"],
        "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
        "image/vnd.djvu": ["djvu", "djv"],
        "image/vnd.dvb.subtitle": ["*sub"],
        "image/vnd.dwg": ["dwg"],
        "image/vnd.dxf": ["dxf"],
        "image/vnd.fastbidsheet": ["fbs"],
        "image/vnd.fpx": ["fpx"],
        "image/vnd.fst": ["fst"],
        "image/vnd.fujixerox.edmics-mmr": ["mmr"],
        "image/vnd.fujixerox.edmics-rlc": ["rlc"],
        "image/vnd.microsoft.icon": ["ico"],
        "image/vnd.ms-dds": ["dds"],
        "image/vnd.ms-modi": ["mdi"],
        "image/vnd.ms-photo": ["wdp"],
        "image/vnd.net-fpx": ["npx"],
        "image/vnd.pco.b16": ["b16"],
        "image/vnd.tencent.tap": ["tap"],
        "image/vnd.valve.source.texture": ["vtf"],
        "image/vnd.wap.wbmp": ["wbmp"],
        "image/vnd.xiff": ["xif"],
        "image/vnd.zbrush.pcx": ["pcx"],
        "image/x-3ds": ["3ds"],
        "image/x-cmu-raster": ["ras"],
        "image/x-cmx": ["cmx"],
        "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
        "image/x-icon": ["*ico"],
        "image/x-jng": ["jng"],
        "image/x-mrsid-image": ["sid"],
        "image/x-ms-bmp": ["*bmp"],
        "image/x-pcx": ["*pcx"],
        "image/x-pict": ["pic", "pct"],
        "image/x-portable-anymap": ["pnm"],
        "image/x-portable-bitmap": ["pbm"],
        "image/x-portable-graymap": ["pgm"],
        "image/x-portable-pixmap": ["ppm"],
        "image/x-rgb": ["rgb"],
        "image/x-tga": ["tga"],
        "image/x-xbitmap": ["xbm"],
        "image/x-xpixmap": ["xpm"],
        "image/x-xwindowdump": ["xwd"],
        "message/vnd.wfa.wsc": ["wsc"],
        "model/vnd.collada+xml": ["dae"],
        "model/vnd.dwf": ["dwf"],
        "model/vnd.gdl": ["gdl"],
        "model/vnd.gtw": ["gtw"],
        "model/vnd.mts": ["mts"],
        "model/vnd.opengex": ["ogex"],
        "model/vnd.parasolid.transmit.binary": ["x_b"],
        "model/vnd.parasolid.transmit.text": ["x_t"],
        "model/vnd.sap.vds": ["vds"],
        "model/vnd.usdz+zip": ["usdz"],
        "model/vnd.valve.source.compiled-map": ["bsp"],
        "model/vnd.vtu": ["vtu"],
        "text/prs.lines.tag": ["dsc"],
        "text/vnd.curl": ["curl"],
        "text/vnd.curl.dcurl": ["dcurl"],
        "text/vnd.curl.mcurl": ["mcurl"],
        "text/vnd.curl.scurl": ["scurl"],
        "text/vnd.dvb.subtitle": ["sub"],
        "text/vnd.fly": ["fly"],
        "text/vnd.fmi.flexstor": ["flx"],
        "text/vnd.graphviz": ["gv"],
        "text/vnd.in3d.3dml": ["3dml"],
        "text/vnd.in3d.spot": ["spot"],
        "text/vnd.sun.j2me.app-descriptor": ["jad"],
        "text/vnd.wap.wml": ["wml"],
        "text/vnd.wap.wmlscript": ["wmls"],
        "text/x-asm": ["s", "asm"],
        "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
        "text/x-component": ["htc"],
        "text/x-fortran": ["f", "for", "f77", "f90"],
        "text/x-handlebars-template": ["hbs"],
        "text/x-java-source": ["java"],
        "text/x-lua": ["lua"],
        "text/x-markdown": ["mkd"],
        "text/x-nfo": ["nfo"],
        "text/x-opml": ["opml"],
        "text/x-org": ["*org"],
        "text/x-pascal": ["p", "pas"],
        "text/x-processing": ["pde"],
        "text/x-sass": ["sass"],
        "text/x-scss": ["scss"],
        "text/x-setext": ["etx"],
        "text/x-sfv": ["sfv"],
        "text/x-suse-ymp": ["ymp"],
        "text/x-uuencode": ["uu"],
        "text/x-vcalendar": ["vcs"],
        "text/x-vcard": ["vcf"],
        "video/vnd.dece.hd": ["uvh", "uvvh"],
        "video/vnd.dece.mobile": ["uvm", "uvvm"],
        "video/vnd.dece.pd": ["uvp", "uvvp"],
        "video/vnd.dece.sd": ["uvs", "uvvs"],
        "video/vnd.dece.video": ["uvv", "uvvv"],
        "video/vnd.dvb.file": ["dvb"],
        "video/vnd.fvt": ["fvt"],
        "video/vnd.mpegurl": ["mxu", "m4u"],
        "video/vnd.ms-playready.media.pyv": ["pyv"],
        "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
        "video/vnd.vivo": ["viv"],
        "video/x-f4v": ["f4v"],
        "video/x-fli": ["fli"],
        "video/x-flv": ["flv"],
        "video/x-m4v": ["m4v"],
        "video/x-matroska": ["mkv", "mk3d", "mks"],
        "video/x-mng": ["mng"],
        "video/x-ms-asf": ["asf", "asx"],
        "video/x-ms-vob": ["vob"],
        "video/x-ms-wm": ["wm"],
        "video/x-ms-wmv": ["wmv"],
        "video/x-ms-wmx": ["wmx"],
        "video/x-ms-wvx": ["wvx"],
        "video/x-msvideo": ["avi"],
        "video/x-sgi-movie": ["movie"],
        "video/x-smv": ["smv"],
        "x-conference/x-cooltalk": ["ice"]
      };

      /***/
    },

    /***/ 3114: /***/ (module) => {
      module.exports = {
        "application/andrew-inset": ["ez"],
        "application/applixware": ["aw"],
        "application/atom+xml": ["atom"],
        "application/atomcat+xml": ["atomcat"],
        "application/atomdeleted+xml": ["atomdeleted"],
        "application/atomsvc+xml": ["atomsvc"],
        "application/atsc-dwd+xml": ["dwd"],
        "application/atsc-held+xml": ["held"],
        "application/atsc-rsat+xml": ["rsat"],
        "application/bdoc": ["bdoc"],
        "application/calendar+xml": ["xcs"],
        "application/ccxml+xml": ["ccxml"],
        "application/cdfx+xml": ["cdfx"],
        "application/cdmi-capability": ["cdmia"],
        "application/cdmi-container": ["cdmic"],
        "application/cdmi-domain": ["cdmid"],
        "application/cdmi-object": ["cdmio"],
        "application/cdmi-queue": ["cdmiq"],
        "application/cu-seeme": ["cu"],
        "application/dash+xml": ["mpd"],
        "application/davmount+xml": ["davmount"],
        "application/docbook+xml": ["dbk"],
        "application/dssc+der": ["dssc"],
        "application/dssc+xml": ["xdssc"],
        "application/ecmascript": ["es", "ecma"],
        "application/emma+xml": ["emma"],
        "application/emotionml+xml": ["emotionml"],
        "application/epub+zip": ["epub"],
        "application/exi": ["exi"],
        "application/express": ["exp"],
        "application/fdt+xml": ["fdt"],
        "application/font-tdpfr": ["pfr"],
        "application/geo+json": ["geojson"],
        "application/gml+xml": ["gml"],
        "application/gpx+xml": ["gpx"],
        "application/gxf": ["gxf"],
        "application/gzip": ["gz"],
        "application/hjson": ["hjson"],
        "application/hyperstudio": ["stk"],
        "application/inkml+xml": ["ink", "inkml"],
        "application/ipfix": ["ipfix"],
        "application/its+xml": ["its"],
        "application/java-archive": ["jar", "war", "ear"],
        "application/java-serialized-object": ["ser"],
        "application/java-vm": ["class"],
        "application/javascript": ["js", "mjs"],
        "application/json": ["json", "map"],
        "application/json5": ["json5"],
        "application/jsonml+json": ["jsonml"],
        "application/ld+json": ["jsonld"],
        "application/lgr+xml": ["lgr"],
        "application/lost+xml": ["lostxml"],
        "application/mac-binhex40": ["hqx"],
        "application/mac-compactpro": ["cpt"],
        "application/mads+xml": ["mads"],
        "application/manifest+json": ["webmanifest"],
        "application/marc": ["mrc"],
        "application/marcxml+xml": ["mrcx"],
        "application/mathematica": ["ma", "nb", "mb"],
        "application/mathml+xml": ["mathml"],
        "application/mbox": ["mbox"],
        "application/mediaservercontrol+xml": ["mscml"],
        "application/metalink+xml": ["metalink"],
        "application/metalink4+xml": ["meta4"],
        "application/mets+xml": ["mets"],
        "application/mmt-aei+xml": ["maei"],
        "application/mmt-usd+xml": ["musd"],
        "application/mods+xml": ["mods"],
        "application/mp21": ["m21", "mp21"],
        "application/mp4": ["mp4s", "m4p"],
        "application/msword": ["doc", "dot"],
        "application/mxf": ["mxf"],
        "application/n-quads": ["nq"],
        "application/n-triples": ["nt"],
        "application/node": ["cjs"],
        "application/octet-stream": [
          "bin",
          "dms",
          "lrf",
          "mar",
          "so",
          "dist",
          "distz",
          "pkg",
          "bpk",
          "dump",
          "elc",
          "deploy",
          "exe",
          "dll",
          "deb",
          "dmg",
          "iso",
          "img",
          "msi",
          "msp",
          "msm",
          "buffer"
        ],
        "application/oda": ["oda"],
        "application/oebps-package+xml": ["opf"],
        "application/ogg": ["ogx"],
        "application/omdoc+xml": ["omdoc"],
        "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
        "application/oxps": ["oxps"],
        "application/p2p-overlay+xml": ["relo"],
        "application/patch-ops-error+xml": ["xer"],
        "application/pdf": ["pdf"],
        "application/pgp-encrypted": ["pgp"],
        "application/pgp-signature": ["asc", "sig"],
        "application/pics-rules": ["prf"],
        "application/pkcs10": ["p10"],
        "application/pkcs7-mime": ["p7m", "p7c"],
        "application/pkcs7-signature": ["p7s"],
        "application/pkcs8": ["p8"],
        "application/pkix-attr-cert": ["ac"],
        "application/pkix-cert": ["cer"],
        "application/pkix-crl": ["crl"],
        "application/pkix-pkipath": ["pkipath"],
        "application/pkixcmp": ["pki"],
        "application/pls+xml": ["pls"],
        "application/postscript": ["ai", "eps", "ps"],
        "application/provenance+xml": ["provx"],
        "application/pskc+xml": ["pskcxml"],
        "application/raml+yaml": ["raml"],
        "application/rdf+xml": ["rdf", "owl"],
        "application/reginfo+xml": ["rif"],
        "application/relax-ng-compact-syntax": ["rnc"],
        "application/resource-lists+xml": ["rl"],
        "application/resource-lists-diff+xml": ["rld"],
        "application/rls-services+xml": ["rs"],
        "application/route-apd+xml": ["rapd"],
        "application/route-s-tsid+xml": ["sls"],
        "application/route-usd+xml": ["rusd"],
        "application/rpki-ghostbusters": ["gbr"],
        "application/rpki-manifest": ["mft"],
        "application/rpki-roa": ["roa"],
        "application/rsd+xml": ["rsd"],
        "application/rss+xml": ["rss"],
        "application/rtf": ["rtf"],
        "application/sbml+xml": ["sbml"],
        "application/scvp-cv-request": ["scq"],
        "application/scvp-cv-response": ["scs"],
        "application/scvp-vp-request": ["spq"],
        "application/scvp-vp-response": ["spp"],
        "application/sdp": ["sdp"],
        "application/senml+xml": ["senmlx"],
        "application/sensml+xml": ["sensmlx"],
        "application/set-payment-initiation": ["setpay"],
        "application/set-registration-initiation": ["setreg"],
        "application/shf+xml": ["shf"],
        "application/sieve": ["siv", "sieve"],
        "application/smil+xml": ["smi", "smil"],
        "application/sparql-query": ["rq"],
        "application/sparql-results+xml": ["srx"],
        "application/srgs": ["gram"],
        "application/srgs+xml": ["grxml"],
        "application/sru+xml": ["sru"],
        "application/ssdl+xml": ["ssdl"],
        "application/ssml+xml": ["ssml"],
        "application/swid+xml": ["swidtag"],
        "application/tei+xml": ["tei", "teicorpus"],
        "application/thraud+xml": ["tfi"],
        "application/timestamped-data": ["tsd"],
        "application/toml": ["toml"],
        "application/trig": ["trig"],
        "application/ttml+xml": ["ttml"],
        "application/ubjson": ["ubj"],
        "application/urc-ressheet+xml": ["rsheet"],
        "application/urc-targetdesc+xml": ["td"],
        "application/voicexml+xml": ["vxml"],
        "application/wasm": ["wasm"],
        "application/widget": ["wgt"],
        "application/winhlp": ["hlp"],
        "application/wsdl+xml": ["wsdl"],
        "application/wspolicy+xml": ["wspolicy"],
        "application/xaml+xml": ["xaml"],
        "application/xcap-att+xml": ["xav"],
        "application/xcap-caps+xml": ["xca"],
        "application/xcap-diff+xml": ["xdf"],
        "application/xcap-el+xml": ["xel"],
        "application/xcap-ns+xml": ["xns"],
        "application/xenc+xml": ["xenc"],
        "application/xhtml+xml": ["xhtml", "xht"],
        "application/xliff+xml": ["xlf"],
        "application/xml": ["xml", "xsl", "xsd", "rng"],
        "application/xml-dtd": ["dtd"],
        "application/xop+xml": ["xop"],
        "application/xproc+xml": ["xpl"],
        "application/xslt+xml": ["*xsl", "xslt"],
        "application/xspf+xml": ["xspf"],
        "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
        "application/yang": ["yang"],
        "application/yin+xml": ["yin"],
        "application/zip": ["zip"],
        "audio/3gpp": ["*3gpp"],
        "audio/adpcm": ["adp"],
        "audio/amr": ["amr"],
        "audio/basic": ["au", "snd"],
        "audio/midi": ["mid", "midi", "kar", "rmi"],
        "audio/mobile-xmf": ["mxmf"],
        "audio/mp3": ["*mp3"],
        "audio/mp4": ["m4a", "mp4a"],
        "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
        "audio/ogg": ["oga", "ogg", "spx", "opus"],
        "audio/s3m": ["s3m"],
        "audio/silk": ["sil"],
        "audio/wav": ["wav"],
        "audio/wave": ["*wav"],
        "audio/webm": ["weba"],
        "audio/xm": ["xm"],
        "font/collection": ["ttc"],
        "font/otf": ["otf"],
        "font/ttf": ["ttf"],
        "font/woff": ["woff"],
        "font/woff2": ["woff2"],
        "image/aces": ["exr"],
        "image/apng": ["apng"],
        "image/avif": ["avif"],
        "image/bmp": ["bmp"],
        "image/cgm": ["cgm"],
        "image/dicom-rle": ["drle"],
        "image/emf": ["emf"],
        "image/fits": ["fits"],
        "image/g3fax": ["g3"],
        "image/gif": ["gif"],
        "image/heic": ["heic"],
        "image/heic-sequence": ["heics"],
        "image/heif": ["heif"],
        "image/heif-sequence": ["heifs"],
        "image/hej2k": ["hej2"],
        "image/hsj2": ["hsj2"],
        "image/ief": ["ief"],
        "image/jls": ["jls"],
        "image/jp2": ["jp2", "jpg2"],
        "image/jpeg": ["jpeg", "jpg", "jpe"],
        "image/jph": ["jph"],
        "image/jphc": ["jhc"],
        "image/jpm": ["jpm"],
        "image/jpx": ["jpx", "jpf"],
        "image/jxr": ["jxr"],
        "image/jxra": ["jxra"],
        "image/jxrs": ["jxrs"],
        "image/jxs": ["jxs"],
        "image/jxsc": ["jxsc"],
        "image/jxsi": ["jxsi"],
        "image/jxss": ["jxss"],
        "image/ktx": ["ktx"],
        "image/ktx2": ["ktx2"],
        "image/png": ["png"],
        "image/sgi": ["sgi"],
        "image/svg+xml": ["svg", "svgz"],
        "image/t38": ["t38"],
        "image/tiff": ["tif", "tiff"],
        "image/tiff-fx": ["tfx"],
        "image/webp": ["webp"],
        "image/wmf": ["wmf"],
        "message/disposition-notification": ["disposition-notification"],
        "message/global": ["u8msg"],
        "message/global-delivery-status": ["u8dsn"],
        "message/global-disposition-notification": ["u8mdn"],
        "message/global-headers": ["u8hdr"],
        "message/rfc822": ["eml", "mime"],
        "model/3mf": ["3mf"],
        "model/gltf+json": ["gltf"],
        "model/gltf-binary": ["glb"],
        "model/iges": ["igs", "iges"],
        "model/mesh": ["msh", "mesh", "silo"],
        "model/mtl": ["mtl"],
        "model/obj": ["obj"],
        "model/step+xml": ["stpx"],
        "model/step+zip": ["stpz"],
        "model/step-xml+zip": ["stpxz"],
        "model/stl": ["stl"],
        "model/vrml": ["wrl", "vrml"],
        "model/x3d+binary": ["*x3db", "x3dbz"],
        "model/x3d+fastinfoset": ["x3db"],
        "model/x3d+vrml": ["*x3dv", "x3dvz"],
        "model/x3d+xml": ["x3d", "x3dz"],
        "model/x3d-vrml": ["x3dv"],
        "text/cache-manifest": ["appcache", "manifest"],
        "text/calendar": ["ics", "ifb"],
        "text/coffeescript": ["coffee", "litcoffee"],
        "text/css": ["css"],
        "text/csv": ["csv"],
        "text/html": ["html", "htm", "shtml"],
        "text/jade": ["jade"],
        "text/jsx": ["jsx"],
        "text/less": ["less"],
        "text/markdown": ["markdown", "md"],
        "text/mathml": ["mml"],
        "text/mdx": ["mdx"],
        "text/n3": ["n3"],
        "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
        "text/richtext": ["rtx"],
        "text/rtf": ["*rtf"],
        "text/sgml": ["sgml", "sgm"],
        "text/shex": ["shex"],
        "text/slim": ["slim", "slm"],
        "text/spdx": ["spdx"],
        "text/stylus": ["stylus", "styl"],
        "text/tab-separated-values": ["tsv"],
        "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
        "text/turtle": ["ttl"],
        "text/uri-list": ["uri", "uris", "urls"],
        "text/vcard": ["vcard"],
        "text/vtt": ["vtt"],
        "text/xml": ["*xml"],
        "text/yaml": ["yaml", "yml"],
        "video/3gpp": ["3gp", "3gpp"],
        "video/3gpp2": ["3g2"],
        "video/h261": ["h261"],
        "video/h263": ["h263"],
        "video/h264": ["h264"],
        "video/iso.segment": ["m4s"],
        "video/jpeg": ["jpgv"],
        "video/jpm": ["*jpm", "jpgm"],
        "video/mj2": ["mj2", "mjp2"],
        "video/mp2t": ["ts"],
        "video/mp4": ["mp4", "mp4v", "mpg4"],
        "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
        "video/ogg": ["ogv"],
        "video/quicktime": ["qt", "mov"],
        "video/webm": ["webm"]
      };

      /***/
    },

    /***/ 3973: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = minimatch;
      minimatch.Minimatch = Minimatch;

      var path = (function () {
        try {
          return __nccwpck_require__(1017);
        } catch (e) {}
      })() || {
        sep: "/"
      };
      minimatch.sep = path.sep;

      var GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {});
      var expand = __nccwpck_require__(3717);

      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };

      // any single thing other than /
      // don't need to escape / when using new RegExp()
      var qmark = "[^/]";

      // * => any number of characters
      var star = qmark + "*?";

      // ** when dots are allowed.  Anything goes, except .. and .
      // not (^ or / followed by one or two dots followed by $ or /),
      // followed by anything, any number of times.
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";

      // not a ^ or / followed by a dot,
      // followed by anything, any number of times.
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";

      // characters that need to be escaped in RegExp.
      var reSpecials = charSet("().*{}+?[]^$\\!");

      // "abc" -> { a:true, b:true, c:true }
      function charSet(s) {
        return s.split("").reduce(function (set, c) {
          set[c] = true;
          return set;
        }, {});
      }

      // normalizes slashes.
      var slashSplit = /\/+/;

      minimatch.filter = filter;
      function filter(pattern, options) {
        options = options || {};
        return function (p, i, list) {
          return minimatch(p, pattern, options);
        };
      }

      function ext(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function (k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function (k) {
          t[k] = b[k];
        });
        return t;
      }

      minimatch.defaults = function (def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch;
        }

        var orig = minimatch;

        var m = function minimatch(p, pattern, options) {
          return orig(p, pattern, ext(def, options));
        };

        m.Minimatch = function Minimatch(pattern, options) {
          return new orig.Minimatch(pattern, ext(def, options));
        };
        m.Minimatch.defaults = function defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        };

        m.filter = function filter(pattern, options) {
          return orig.filter(pattern, ext(def, options));
        };

        m.defaults = function defaults(options) {
          return orig.defaults(ext(def, options));
        };

        m.makeRe = function makeRe(pattern, options) {
          return orig.makeRe(pattern, ext(def, options));
        };

        m.braceExpand = function braceExpand(pattern, options) {
          return orig.braceExpand(pattern, ext(def, options));
        };

        m.match = function (list, pattern, options) {
          return orig.match(list, pattern, ext(def, options));
        };

        return m;
      };

      Minimatch.defaults = function (def) {
        return minimatch.defaults(def).Minimatch;
      };

      function minimatch(p, pattern, options) {
        assertValidPattern(pattern);

        if (!options) options = {};

        // shortcut: comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }

        return new Minimatch(pattern, options).match(p);
      }

      function Minimatch(pattern, options) {
        if (!(this instanceof Minimatch)) {
          return new Minimatch(pattern, options);
        }

        assertValidPattern(pattern);

        if (!options) options = {};

        pattern = pattern.trim();

        // windows support: need to use /, not \
        if (!options.allowWindowsEscape && path.sep !== "/") {
          pattern = pattern.split(path.sep).join("/");
        }

        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;

        // make the set of regexps etc.
        this.make();
      }

      Minimatch.prototype.debug = function () {};

      Minimatch.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;

        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }

        // step 1: figure out negation, etc.
        this.parseNegate();

        // step 2: expand braces
        var set = (this.globSet = this.braceExpand());

        if (options.debug)
          this.debug = function debug() {
            console.error.apply(console, arguments);
          };

        this.debug(this.pattern, set);

        // step 3: now we have a set, so turn each one into a series of path-portion
        // matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        set = this.globParts = set.map(function (s) {
          return s.split(slashSplit);
        });

        this.debug(this.pattern, set);

        // glob --> regexps
        set = set.map(function (s, si, set) {
          return s.map(this.parse, this);
        }, this);

        this.debug(this.pattern, set);

        // filter out everything that didn't compile properly.
        set = set.filter(function (s) {
          return s.indexOf(false) === -1;
        });

        this.debug(this.pattern, set);

        this.set = set;
      }

      Minimatch.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;

        if (options.nonegate) return;

        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }

        if (negateOffset) this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }

      // Brace expansion:
      // a{b,c}d -> abd acd
      // a{b,}c -> abc ac
      // a{0..3}d -> a0d a1d a2d a3d
      // a{b,c{d,e}f}g -> abg acdfg acefg
      // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
      //
      // Invalid sets are not expanded.
      // a{2..}b -> a{2..}b
      // a{b}c -> a{b}c
      minimatch.braceExpand = function (pattern, options) {
        return braceExpand(pattern, options);
      };

      Minimatch.prototype.braceExpand = braceExpand;

      function braceExpand(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch) {
            options = this.options;
          } else {
            options = {};
          }
        }

        pattern = typeof pattern === "undefined" ? this.pattern : pattern;

        assertValidPattern(pattern);

        // Thanks to Yeting Li <https://github.com/yetingli> for
        // improving this regexp to avoid a ReDOS vulnerability.
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          // shortcut. no need to expand.
          return [pattern];
        }

        return expand(pattern);
      }

      var MAX_PATTERN_LENGTH = 1024 * 64;
      var assertValidPattern = function (pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }

        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };

      // parse a component of the expanded set.
      // At this point, no pattern may contain "/" in it
      // so we're going to return a 2d array, where each entry is the full
      // pattern, split on '/', and then turned into a regular expression.
      // A regexp is made at the end which joins each array with an
      // escaped /, and another full one which joins each regexp with |.
      //
      // Following the lead of Bash 4.1, note that "**" only has special meaning
      // when it is the *only* thing in a path portion.  Otherwise, any series
      // of * is equivalent to a single *.  Globstar behavior is enabled by
      // default, and can be disabled by setting options.noglobstar.
      Minimatch.prototype.parse = parse;
      var SUBPARSE = {};
      function parse(pattern, isSub) {
        assertValidPattern(pattern);

        var options = this.options;

        // shortcuts
        if (pattern === "**") {
          if (!options.noglobstar) return GLOBSTAR;
          else pattern = "*";
        }
        if (pattern === "") return "";

        var re = "";
        var hasMagic = !!options.nocase;
        var escaping = false;
        // ? => one single character
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        // . and .. never match anything that doesn't start with .,
        // even when options.dot is set.
        var patternStart =
          pattern.charAt(0) === "."
            ? "" // anything
            : // not (start or / followed by . or .. followed by / or end)
            options.dot
            ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))"
            : "(?!\\.)";
        var self = this;

        function clearStateChar() {
          if (stateChar) {
            // we had some state-tracking character
            // that wasn't consumed by this pass.
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }

        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s\t%s %s %j", pattern, i, re, c);

          // skip over any that are escaped.
          if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }

          switch (c) {
            /* istanbul ignore next */
            case "/": {
              // completely not allowed, even escaped.
              // Should already be path-split by now.
              return false;
            }

            case "\\":
              clearStateChar();
              escaping = true;
              continue;

            // the various stateChar values
            // for the "extglob" stuff.
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c);

              // all of those are literals inside a class, except that
              // the glob [!a] means [^a] in regexp
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }

              // if we already have a stateChar, then it means
              // that there was something like ** or +? in there.
              // Handle the stateChar, then proceed with this one.
              self.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              // if extglob is disabled, then +(asdf|foo) isn't a thing.
              // just clear the statechar *now*, rather than even diving into
              // the patternList stuff.
              if (options.noext) clearStateChar();
              continue;

            case "(":
              if (inClass) {
                re += "(";
                continue;
              }

              if (!stateChar) {
                re += "\\(";
                continue;
              }

              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              // negation is (?:(?!js)[^/]*)
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;

            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }

              clearStateChar();
              hasMagic = true;
              var pl = patternListStack.pop();
              // negation is (?:(?!js)[^/]*)
              // The others are (?:<pattern>)<type>
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;

            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }

              clearStateChar();
              re += "|";
              continue;

            // these are mostly the same in regexp and glob
            case "[":
              // swallow any state-tracking char before the [
              clearStateChar();

              if (inClass) {
                re += "\\" + c;
                continue;
              }

              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;

            case "]":
              //  a right bracket shall lose its special
              //  meaning and represent itself in
              //  a bracket expression if it occurs
              //  first in the list.  -- POSIX.2 2.8.3.2
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }

              // handle the case where we left a class open.
              // "[z-a]" is valid, equivalent to "\[z-a\]"
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }

              // finish up the class.
              hasMagic = true;
              inClass = false;
              re += c;
              continue;

            default:
              // swallow any state char that wasn't consumed
              clearStateChar();

              if (escaping) {
                // no need
                escaping = false;
              } else if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }

              re += c;
          } // switch
        } // for

        // handle the case where we left a class open.
        // "[abc" is valid, equivalent to "\[abc"
        if (inClass) {
          // split where the last [ was, and escape it
          // this is a huge pita.  We now have to re-walk
          // the contents of the would-be class to re-translate
          // any characters that were passed through as-is
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }

        // handle the case where we had a +( thing at the *end*
        // of the pattern.
        // each pattern list stack adds 3 chars, and we need to go through
        // and escape any | chars that were passed through as-is for the regexp.
        // Go through and escape them, taking care not to double-escape any
        // | chars that were already escaped.
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          // maybe some even number of \, then maybe 1 \, followed by a |
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
            if (!$2) {
              // the | isn't already escaped, so escape it.
              $2 = "\\";
            }

            // need to escape all those slashes *again*, without escaping the
            // one that we need for escaping the | character.  As it works out,
            // escaping an even number of slashes can be done by simply repeating
            // it exactly after itself.  That's why this trick works.
            //
            // I am sorry that you have to see this.
            return $1 + $1 + $2 + "|";
          });

          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;

          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }

        // handle trailing things that only matter at the very end.
        clearStateChar();
        if (escaping) {
          // trailing \\
          re += "\\\\";
        }

        // only need to apply the nodot start if the re starts with
        // something that could conceivably capture a dot
        var addPatternStart = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart = true;
        }

        // Hack to work around lack of negative lookbehind in JS
        // A pattern like: *.!(x).!(y|z) needs to ensure that a name
        // like 'a.xyz.yz' doesn't match.  So, the first negative
        // lookahead, has to look ALL the way ahead, to the end of
        // the pattern.
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];

          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);

          nlLast += nlAfter;

          // Handle nested stuff like *(*.js|!(*.json)), where open parens
          // mean that we should *not* include the ) in the bit that is considered
          // "after" the negated section.
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;

          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }

        // if the re is not "" at this point, then we need to make sure
        // it doesn't match against an empty path part.
        // Otherwise a/* will match a/, which it should not.
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }

        if (addPatternStart) {
          re = patternStart + re;
        }

        // parsing just a piece of a larger pattern.
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }

        // skip the regexp for non-magical patterns
        // unescape anything in it, though, so that it'll be
        // an exact match against a file etc.
        if (!hasMagic) {
          return globUnescape(pattern);
        }

        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) /* istanbul ignore next - should be impossible */ {
          // If it was an invalid regular expression, then it can't match
          // anything.  This trick looks for a character after the end of
          // the string, which is of course impossible, except in multi-line
          // mode, but it's not a /m regex.
          return new RegExp("$.");
        }

        regExp._glob = pattern;
        regExp._src = re;

        return regExp;
      }

      minimatch.makeRe = function (pattern, options) {
        return new Minimatch(pattern, options || {}).makeRe();
      };

      Minimatch.prototype.makeRe = makeRe;
      function makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;

        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        var set = this.set;

        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;

        var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        var flags = options.nocase ? "i" : "";

        var re = set
          .map(function (pattern) {
            return pattern
              .map(function (p) {
                return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
              })
              .join("\\/");
          })
          .join("|");

        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = "^(?:" + re + ")$";

        // can match anything, as long as it's not this.
        if (this.negate) re = "^(?!" + re + ").*$";

        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) /* istanbul ignore next - should be impossible */ {
          this.regexp = false;
        }
        return this.regexp;
      }

      minimatch.match = function (list, pattern, options) {
        options = options || {};
        var mm = new Minimatch(pattern, options);
        list = list.filter(function (f) {
          return mm.match(f);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };

      Minimatch.prototype.match = function match(f, partial) {
        if (typeof partial === "undefined") partial = this.partial;
        this.debug("match", f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) return false;
        if (this.empty) return f === "";

        if (f === "/" && partial) return true;

        var options = this.options;

        // windows: need to use /, not \
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }

        // treat the test path as a set of pathparts.
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);

        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.

        var set = this.set;
        this.debug(this.pattern, "set", set);

        // Find the basename of the path by looking for the last non-empty segment
        var filename;
        var i;
        for (i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }

        for (i = 0; i < set.length; i++) {
          var pattern = set[i];
          var file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
          }
        }

        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) return false;
        return this.negate;
      };

      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      Minimatch.prototype.matchOne = function (file, pattern, partial) {
        var options = this.options;

        this.debug("matchOne", { this: this, file: file, pattern: pattern });

        this.debug("matchOne", file.length, pattern.length);

        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];

          this.debug(pattern, p, f);

          // should be impossible.
          // some invalid regexp stuff in the set.
          /* istanbul ignore if */
          if (p === false) return false;

          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);

            // "**"
            // a/**/b/**/c would match the following:
            // a/b/x/y/z/c
            // a/x/y/z/b/c
            // a/b/x/b/x/c
            // a/b/c
            // To do this, take the rest of the pattern after
            // the **, and see if it would match the file remainder.
            // If so, return success.
            // If not, the ** "swallows" a segment, and try again.
            // This is recursively awful.
            //
            // a/**/b/**/c matching a/b/x/y/z/c
            // - a matches a
            // - doublestar
            //   - matchOne(b/x/y/z/c, b/**/c)
            //     - b matches b
            //     - doublestar
            //       - matchOne(x/y/z/c, c) -> no
            //       - matchOne(y/z/c, c) -> no
            //       - matchOne(z/c, c) -> no
            //       - matchOne(c, c) yes, hit
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              // a ** at the end will just swallow the rest.
              // We have found a match.
              // however, it will not swallow /.x, unless
              // options.dot is set.
              // . and .. are *never* matched by **, for explosively
              // exponential reasons.
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || (!options.dot && file[fi].charAt(0) === ".")) return false;
              }
              return true;
            }

            // ok, let's see if we can swallow whatever we can.
            while (fr < fl) {
              var swallowee = file[fr];

              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);

              // XXX remove this slice.  Just pass the start index.
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                // found a match.
                return true;
              } else {
                // can't swallow "." or ".." ever.
                // can only swallow ".foo" when explicitly asked.
                if (swallowee === "." || swallowee === ".." || (!options.dot && swallowee.charAt(0) === ".")) {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }

                // ** swallows a segment, and continue.
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }

            // no match was found.
            // However, in partial mode, we can't say this is necessarily over.
            // If there's more *pattern* left, then
            /* istanbul ignore if */
            if (partial) {
              // ran out of file
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }

          // something other than **
          // non-magic patterns just have to match exactly
          // patterns with magic have been turned into regexps.
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }

          if (!hit) return false;
        }

        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*

        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
          // ran out of pattern and filename at the same time.
          // an exact hit!
          return true;
        } else if (fi === fl) {
          // ran out of file, but still had pattern left.
          // this is ok if we're doing the match as part of
          // a glob fs traversal.
          return partial;
        } /* istanbul ignore else */ else if (pi === pl) {
          // ran out of pattern, still have file left.
          // this is only acceptable if we're on the very last
          // empty segment of a file with a trailing slash.
          // a/* should match a/b/
          return fi === fl - 1 && file[fi] === "";
        }

        // should be unreachable.
        /* istanbul ignore next */
        throw new Error("wtf?");
      };

      // replace stuff like \* with *
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }

      function regExpEscape(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      /***/
    },

    /***/ 6186: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var path = __nccwpck_require__(1017);
      var fs = __nccwpck_require__(7147);
      var _0777 = parseInt("0777", 8);

      module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

      function mkdirP(p, opts, f, made) {
        if (typeof opts === "function") {
          f = opts;
          opts = {};
        } else if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }

        var mode = opts.mode;
        var xfs = opts.fs || fs;

        if (mode === undefined) {
          mode = _0777;
        }
        if (!made) made = null;

        var cb = f || /* istanbul ignore next */ function () {};
        p = path.resolve(p);

        xfs.mkdir(p, mode, function (er) {
          if (!er) {
            made = made || p;
            return cb(null, made);
          }
          switch (er.code) {
            case "ENOENT":
              /* istanbul ignore if */
              if (path.dirname(p) === p) return cb(er);
              mkdirP(path.dirname(p), opts, function (er, made) {
                /* istanbul ignore if */
                if (er) cb(er, made);
                else mkdirP(p, opts, cb, made);
              });
              break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
              xfs.stat(p, function (er2, stat) {
                // if the stat fails, then that's super weird.
                // let the original error be the failure reason.
                if (er2 || !stat.isDirectory()) cb(er, made);
                else cb(null, made);
              });
              break;
          }
        });
      }

      mkdirP.sync = function sync(p, opts, made) {
        if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }

        var mode = opts.mode;
        var xfs = opts.fs || fs;

        if (mode === undefined) {
          mode = _0777;
        }
        if (!made) made = null;

        p = path.resolve(p);

        try {
          xfs.mkdirSync(p, mode);
          made = made || p;
        } catch (err0) {
          switch (err0.code) {
            case "ENOENT":
              made = sync(path.dirname(p), opts, made);
              sync(p, opts, made);
              break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
              var stat;
              try {
                stat = xfs.statSync(p);
              } catch (err1) /* istanbul ignore next */ {
                throw err0;
              }
              /* istanbul ignore if */
              if (!stat.isDirectory()) throw err0;
              break;
          }
        }

        return made;
      };

      /***/
    },

    /***/ 900: /***/ (module) => {
      /**
       * Helpers.
       */

      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;

      /**
       * Parse or format the given `val`.
       *
       * Options:
       *
       *  - `long` verbose formatting [false]
       *
       * @param {String|Number} val
       * @param {Object} [options]
       * @throws {Error} throw an error if val is not a non-empty string or a number
       * @return {String|Number}
       * @api public
       */

      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };

      /**
       * Parse the given `str` and return milliseconds.
       *
       * @param {String} str
       * @return {Number}
       * @api private
       */

      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match =
          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return undefined;
        }
      }

      /**
       * Short format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }

      /**
       * Long format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }

      /**
       * Pluralization helper.
       */

      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }

      /***/
    },

    /***/ 5573: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      var Promise = __nccwpck_require__(5768);
      var fs;
      try {
        fs = __nccwpck_require__(7758);
      } catch (err) {
        fs = __nccwpck_require__(7147);
      }

      var api = [
        "appendFile",
        "chmod",
        "chown",
        "close",
        "fchmod",
        "fchown",
        "fdatasync",
        "fstat",
        "fsync",
        "ftruncate",
        "futimes",
        "lchown",
        "link",
        "lstat",
        "mkdir",
        "open",
        "read",
        "readFile",
        "readdir",
        "readlink",
        "realpath",
        "rename",
        "rmdir",
        "stat",
        "symlink",
        "truncate",
        "unlink",
        "utimes",
        "write",
        "writeFile"
      ];

      typeof fs.access === "function" && api.push("access");
      typeof fs.copyFile === "function" && api.push("copyFile");
      typeof fs.mkdtemp === "function" && api.push("mkdtemp");

      __nccwpck_require__(8690).withCallback(fs, exports, api);

      exports.exists = function (filename, callback) {
        // callback
        if (typeof callback === "function") {
          return fs.stat(filename, function (err) {
            callback(null, !err);
          });
        }
        // or promise
        return new Promise(function (resolve) {
          fs.stat(filename, function (err) {
            resolve(!err);
          });
        });
      };

      /***/
    },

    /***/ 504: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor =
        Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize =
        hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor =
        Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize =
        hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString =
        typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      // ie, `has-tostringtag/shams
      var toStringTag =
        typeof Symbol === "function" &&
        Symbol.toStringTag &&
        (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol")
          ? Symbol.toStringTag
          : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;

      var gPO =
        (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) ||
        ([].__proto__ === Array.prototype // eslint-disable-line no-proto
          ? function (O) {
              return O.__proto__; // eslint-disable-line no-proto
            }
          : null);

      function addNumericSeparator(num, str) {
        if (
          num === Infinity ||
          num === -Infinity ||
          num !== num ||
          (num && num > -1000 && num < 1000) ||
          $test.call(/e/, str)
        ) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return (
              $replace.call(intStr, sepRegex, "$&_") +
              "." +
              $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "")
            );
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }

      var utilInspect = __nccwpck_require__(7265);
      var inspectCustom = utilInspect.custom;
      var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

      module.exports = function inspect_(obj, options, depth, seen) {
        var opts = options || {};

        if (has(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (
          has(opts, "maxStringLength") &&
          (typeof opts.maxStringLength === "number"
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null)
        ) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }

        if (
          has(opts, "indent") &&
          opts.indent !== null &&
          opts.indent !== "\t" &&
          !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
        ) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;

        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }

        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }

        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray(obj) ? "[Array]" : "[Object]";
        }

        var indent = getIndent(opts, depth);

        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }

        function inspect(value, from, noIndent) {
          if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }

        if (typeof obj === "function" && !isRegExp(obj)) {
          // in older engines, regexes are callable
          var name = nameOf(obj);
          var keys = arrObjKeys(obj, inspect);
          return (
            "[Function" +
            (name ? ": " + name : " (anonymous)") +
            "]" +
            (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "")
          );
        }
        if (isSymbol(obj)) {
          var symString = hasShammedSymbols
            ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1")
            : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
          var s = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i = 0; i < attrs.length; i++) {
            s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
          }
          s += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s += "...";
          }
          s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s;
        }
        if (isArray(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect);
          if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
            return (
              "{ [" +
              String(obj) +
              "] " +
              $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") +
              " }"
            );
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap(obj)) {
          var mapParts = [];
          if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
              mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
            });
          }
          return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet(obj)) {
          var setParts = [];
          if (setForEach) {
            setForEach.call(obj, function (value) {
              setParts.push(inspect(value, obj));
            });
          }
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
          return markBoxed(inspect(Number(obj)));
        }
        if (isBigInt(obj)) {
          return markBoxed(inspect(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString(obj)) {
          return markBoxed(inspect(String(obj)));
        }
        if (!isDate(obj) && !isRegExp(obj)) {
          var ys = arrObjKeys(obj, inspect);
          var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag =
            !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj
              ? $slice.call(toStr(obj), 8, -1)
              : protoTag
              ? "Object"
              : "";
          var constructorTag =
            isPlainObject || typeof obj.constructor !== "function"
              ? ""
              : obj.constructor.name
              ? obj.constructor.name + " "
              : "";
          var tag =
            constructorTag +
            (stringTag || protoTag
              ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] "
              : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };

      function wrapQuotes(s, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s + quoteChar;
      }

      function quote(s) {
        return $replace.call(String(s), /"/g, "&quot;");
      }

      function isArray(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }

      // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
      function isSymbol(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e) {}
        return false;
      }

      function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
          return false;
        }
        try {
          bigIntValueOf.call(obj);
          return true;
        } catch (e) {}
        return false;
      }

      var hasOwn =
        Object.prototype.hasOwnProperty ||
        function (key) {
          return key in this;
        };
      function has(obj, key) {
        return hasOwn.call(obj, key);
      }

      function toStr(obj) {
        return objectToString.call(obj);
      }

      function nameOf(f) {
        if (f.name) {
          return f.name;
        }
        var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
        if (m) {
          return m[1];
        }
        return null;
      }

      function indexOf(xs, x) {
        if (xs.indexOf) {
          return xs.indexOf(x);
        }
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) {
            return i;
          }
        }
        return -1;
      }

      function isMap(x) {
        if (!mapSize || !x || typeof x !== "object") {
          return false;
        }
        try {
          mapSize.call(x);
          try {
            setSize.call(x);
          } catch (s) {
            return true;
          }
          return x instanceof Map; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
      }

      function isWeakMap(x) {
        if (!weakMapHas || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x, weakMapHas);
          try {
            weakSetHas.call(x, weakSetHas);
          } catch (s) {
            return true;
          }
          return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
      }

      function isWeakRef(x) {
        if (!weakRefDeref || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x);
          return true;
        } catch (e) {}
        return false;
      }

      function isSet(x) {
        if (!setSize || !x || typeof x !== "object") {
          return false;
        }
        try {
          setSize.call(x);
          try {
            mapSize.call(x);
          } catch (m) {
            return true;
          }
          return x instanceof Set; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
      }

      function isWeakSet(x) {
        if (!weakSetHas || !x || typeof x !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x, weakSetHas);
          try {
            weakMapHas.call(x, weakMapHas);
          } catch (s) {
            return true;
          }
          return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
        } catch (e) {}
        return false;
      }

      function isElement(x) {
        if (!x || typeof x !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
          return true;
        }
        return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
      }

      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        // eslint-disable-next-line no-control-regex
        var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s, "single", opts);
      }

      function lowbyte(c) {
        var n = c.charCodeAt(0);
        var x = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n];
        if (x) {
          return "\\" + x;
        }
        return "\\x" + (n < 0x10 ? "0" : "") + $toUpperCase.call(n.toString(16));
      }

      function markBoxed(str) {
        return "Object(" + str + ")";
      }

      function weakCollectionOf(type) {
        return type + " { ? }";
      }

      function collectionOf(type, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type + " (" + size + ") {" + joinedEntries + "}";
      }

      function singleLineValues(xs) {
        for (var i = 0; i < xs.length; i++) {
          if (indexOf(xs[i], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }

      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "\t") {
          baseIndent = "\t";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }

      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }

      function arrObjKeys(obj, inspect) {
        var isArr = isArray(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k = 0; k < syms.length; k++) {
            symMap["$" + syms[k]] = syms[k];
          }
        }

        for (var key in obj) {
          // eslint-disable-line no-restricted-syntax
          if (!has(obj, key)) {
            continue;
          } // eslint-disable-line no-restricted-syntax, no-continue
          if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
          } // eslint-disable-line no-restricted-syntax, no-continue
          if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
          } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
          } else {
            xs.push(key + ": " + inspect(obj[key], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
              xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
            }
          }
        }
        return xs;
      }

      /***/
    },

    /***/ 7265: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(3837).inspect;

      /***/
    },

    /***/ 1223: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var wrappy = __nccwpck_require__(2940);
      module.exports = wrappy(once);
      module.exports.strict = wrappy(onceStrict);

      once.proto = once(function () {
        Object.defineProperty(Function.prototype, "once", {
          value: function () {
            return once(this);
          },
          configurable: true
        });

        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function () {
            return onceStrict(this);
          },
          configurable: true
        });
      });

      function once(fn) {
        var f = function () {
          if (f.called) return f.value;
          f.called = true;
          return (f.value = fn.apply(this, arguments));
        };
        f.called = false;
        return f;
      }

      function onceStrict(fn) {
        var f = function () {
          if (f.called) throw new Error(f.onceError);
          f.called = true;
          return (f.value = fn.apply(this, arguments));
        };
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }

      /***/
    },

    /***/ 4824: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var os = __nccwpck_require__(2037);
      var osxRelease = __nccwpck_require__(8344);
      var winRelease = __nccwpck_require__(9513);

      module.exports = function (platform, release) {
        if (!platform && release) {
          throw new Error("You can't specify a `release` without specfying `platform`");
        }

        platform = platform || os.platform();
        release = release || os.release();

        var id;

        if (platform === "darwin") {
          id = osxRelease(release).name;
          return "OS X" + (id ? " " + id : "");
        }

        if (platform === "linux") {
          id = release.replace(/^(\d+\.\d+).*/, "$1");
          return "Linux" + (id ? " " + id : "");
        }

        if (platform === "win32") {
          id = winRelease(release);
          return "Windows" + (id ? " " + id : "");
        }

        return platform;
      };

      /***/
    },

    /***/ 8344: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var os = __nccwpck_require__(2037);

      var nameMap = {
        15: "El Capitan",
        14: "Yosemite",
        13: "Mavericks",
        12: "Mountain Lion",
        11: "Lion",
        10: "Snow Leopard",
        9: "Leopard",
        8: "Tiger",
        7: "Panther",
        6: "Jaguar",
        5: "Puma"
      };

      module.exports = function (release) {
        release = (release || os.release()).split(".")[0];
        return {
          name: nameMap[release],
          version: "10." + (Number(release) - 4)
        };
      };

      /***/
    },

    /***/ 1473: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      //through@2 handles this by default!
      module.exports = __nccwpck_require__(421);

      /***/
    },

    /***/ 8208: /***/ function (module, exports, __nccwpck_require__) {
      /* module decorator */ module = __nccwpck_require__.nmd(module);
      /*!
       * Platform.js v1.3.6
       * Copyright 2014-2020 Benjamin Tan
       * Copyright 2011-2013 John-David Dalton
       * Available under MIT license
       */
      (function () {
        "use strict";

        /** Used to determine if values are of the language type `Object`. */
        var objectTypes = {
          function: true,
          object: true
        };

        /** Used as a reference to the global object. */
        var root = (objectTypes[typeof window] && window) || this;

        /** Backup possible global object. */
        var oldRoot = root;

        /** Detect free variable `exports`. */
        var freeExports = objectTypes[typeof exports] && exports;

        /** Detect free variable `module`. */
        var freeModule = objectTypes["object"] && module && !module.nodeType && module;

        /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
        var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
        if (
          freeGlobal &&
          (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)
        ) {
          root = freeGlobal;
        }

        /**
         * Used as the maximum length of an array-like object.
         * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
         * for more details.
         */
        var maxSafeInteger = Math.pow(2, 53) - 1;

        /** Regular expression to detect Opera. */
        var reOpera = /\bOpera/;

        /** Possible global object. */
        var thisBinding = this;

        /** Used for native method references. */
        var objectProto = Object.prototype;

        /** Used to check for own properties of an object. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to resolve the internal `[[Class]]` of values. */
        var toString = objectProto.toString;

        /*--------------------------------------------------------------------------*/

        /**
         * Capitalizes a string value.
         *
         * @private
         * @param {string} string The string to capitalize.
         * @returns {string} The capitalized string.
         */
        function capitalize(string) {
          string = String(string);
          return string.charAt(0).toUpperCase() + string.slice(1);
        }

        /**
         * A utility function to clean up the OS name.
         *
         * @private
         * @param {string} os The OS name to clean up.
         * @param {string} [pattern] A `RegExp` pattern matching the OS name.
         * @param {string} [label] A label for the OS.
         */
        function cleanupOS(os, pattern, label) {
          // Platform tokens are defined at:
          // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
          // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
          var data = {
            "10.0": "10",
            6.4: "10 Technical Preview",
            6.3: "8.1",
            6.2: "8",
            6.1: "Server 2008 R2 / 7",
            "6.0": "Server 2008 / Vista",
            5.2: "Server 2003 / XP 64-bit",
            5.1: "XP",
            5.01: "2000 SP1",
            "5.0": "2000",
            "4.0": "NT",
            "4.90": "ME"
          };
          // Detect Windows version from platform tokens.
          if (
            pattern &&
            label &&
            /^Win/i.test(os) &&
            !/^Windows Phone /i.test(os) &&
            (data = data[/[\d.]+$/.exec(os)])
          ) {
            os = "Windows " + data;
          }
          // Correct character case and cleanup string.
          os = String(os);

          if (pattern && label) {
            os = os.replace(RegExp(pattern, "i"), label);
          }

          os = format(
            os
              .replace(/ ce$/i, " CE")
              .replace(/\bhpw/i, "web")
              .replace(/\bMacintosh\b/, "Mac OS")
              .replace(/_PowerPC\b/i, " OS")
              .replace(/\b(OS X) [^ \d]+/i, "$1")
              .replace(/\bMac (OS X)\b/, "$1")
              .replace(/\/(\d)/, " $1")
              .replace(/_/g, ".")
              .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "")
              .replace(/\bx86\.64\b/gi, "x86_64")
              .replace(/\b(Windows Phone) OS\b/, "$1")
              .replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1")
              .split(" on ")[0]
          );

          return os;
        }

        /**
         * An iteration utility for arrays and objects.
         *
         * @private
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} callback The function called per iteration.
         */
        function each(object, callback) {
          var index = -1,
            length = object ? object.length : 0;

          if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
            while (++index < length) {
              callback(object[index], index, object);
            }
          } else {
            forOwn(object, callback);
          }
        }

        /**
         * Trim and conditionally capitalize string values.
         *
         * @private
         * @param {string} string The string to format.
         * @returns {string} The formatted string.
         */
        function format(string) {
          string = trim(string);
          return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
        }

        /**
         * Iterates over an object's own properties, executing the `callback` for each.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} callback The function executed per own property.
         */
        function forOwn(object, callback) {
          for (var key in object) {
            if (hasOwnProperty.call(object, key)) {
              callback(object[key], key, object);
            }
          }
        }

        /**
         * Gets the internal `[[Class]]` of a value.
         *
         * @private
         * @param {*} value The value.
         * @returns {string} The `[[Class]]`.
         */
        function getClassOf(value) {
          return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
        }

        /**
         * Host objects can return type values that are different from their actual
         * data type. The objects we are concerned with usually return non-primitive
         * types of "object", "function", or "unknown".
         *
         * @private
         * @param {*} object The owner of the property.
         * @param {string} property The property to check.
         * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
         */
        function isHostType(object, property) {
          var type = object != null ? typeof object[property] : "number";
          return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
        }

        /**
         * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
         *
         * @private
         * @param {string} string The string to qualify.
         * @returns {string} The qualified string.
         */
        function qualify(string) {
          return String(string).replace(/([ -])(?!$)/g, "$1?");
        }

        /**
         * A bare-bones `Array#reduce` like utility function.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function called per iteration.
         * @returns {*} The accumulated result.
         */
        function reduce(array, callback) {
          var accumulator = null;
          each(array, function (value, index) {
            accumulator = callback(accumulator, value, index, array);
          });
          return accumulator;
        }

        /**
         * Removes leading and trailing whitespace from a string.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} The trimmed string.
         */
        function trim(string) {
          return String(string).replace(/^ +| +$/g, "");
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Creates a new platform object.
         *
         * @memberOf platform
         * @param {Object|string} [ua=navigator.userAgent] The user agent string or
         *  context object.
         * @returns {Object} A platform object.
         */
        function parse(ua) {
          /** The environment context object. */
          var context = root;

          /** Used to flag when a custom context is provided. */
          var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";

          // Juggle arguments.
          if (isCustomContext) {
            context = ua;
            ua = null;
          }

          /** Browser navigator object. */
          var nav = context.navigator || {};

          /** Browser user agent string. */
          var userAgent = nav.userAgent || "";

          ua || (ua = userAgent);

          /** Used to flag when `thisBinding` is the [ModuleScope]. */
          var isModuleScope = isCustomContext || thisBinding == oldRoot;

          /** Used to detect if browser is like Chrome. */
          var likeChrome = isCustomContext
            ? !!nav.likeChrome
            : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

          /** Internal `[[Class]]` value shortcuts. */
          var objectClass = "Object",
            airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject",
            enviroClass = isCustomContext ? objectClass : "Environment",
            javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java),
            phantomClass = isCustomContext ? objectClass : "RuntimeObject";

          /** Detect Java environments. */
          var java = /\bJava/.test(javaClass) && context.java;

          /** Detect Rhino. */
          var rhino = java && getClassOf(context.environment) == enviroClass;

          /** A character to represent alpha. */
          var alpha = java ? "a" : "\u03b1";

          /** A character to represent beta. */
          var beta = java ? "b" : "\u03b2";

          /** Browser document object. */
          var doc = context.document || {};

          /**
           * Detect Opera browser (Presto-based).
           * http://www.howtocreate.co.uk/operaStuff/operaObject.html
           * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
           */
          var opera = context.operamini || context.opera;

          /** Opera `[[Class]]`. */
          var operaClass = reOpera.test(
            (operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera))
          )
            ? operaClass
            : (opera = null);

          /*------------------------------------------------------------------------*/

          /** Temporary variable used over the script's lifetime. */
          var data;

          /** The CPU architecture. */
          var arch = ua;

          /** Platform description array. */
          var description = [];

          /** Platform alpha/beta indicator. */
          var prerelease = null;

          /** A flag to indicate that environment features should be used to resolve the platform. */
          var useFeatures = ua == userAgent;

          /** The browser/environment version. */
          var version = useFeatures && opera && typeof opera.version == "function" && opera.version();

          /** A flag to indicate if the OS ends with "/ Version" */
          var isSpecialCasedOS;

          /* Detectable layout engines (order is important). */
          var layout = getLayout([
            { label: "EdgeHTML", pattern: "Edge" },
            "Trident",
            { label: "WebKit", pattern: "AppleWebKit" },
            "iCab",
            "Presto",
            "NetFront",
            "Tasman",
            "KHTML",
            "Gecko"
          ]);

          /* Detectable browser names (order is important). */
          var name = getName([
            "Adobe AIR",
            "Arora",
            "Avant Browser",
            "Breach",
            "Camino",
            "Electron",
            "Epiphany",
            "Fennec",
            "Flock",
            "Galeon",
            "GreenBrowser",
            "iCab",
            "Iceweasel",
            "K-Meleon",
            "Konqueror",
            "Lunascape",
            "Maxthon",
            { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
            "Midori",
            "Nook Browser",
            "PaleMoon",
            "PhantomJS",
            "Raven",
            "Rekonq",
            "RockMelt",
            { label: "Samsung Internet", pattern: "SamsungBrowser" },
            "SeaMonkey",
            { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
            "Sleipnir",
            "SlimBrowser",
            { label: "SRWare Iron", pattern: "Iron" },
            "Sunrise",
            "Swiftfox",
            "Vivaldi",
            "Waterfox",
            "WebPositive",
            { label: "Yandex Browser", pattern: "YaBrowser" },
            { label: "UC Browser", pattern: "UCBrowser" },
            "Opera Mini",
            { label: "Opera Mini", pattern: "OPiOS" },
            "Opera",
            { label: "Opera", pattern: "OPR" },
            "Chromium",
            "Chrome",
            { label: "Chrome", pattern: "(?:HeadlessChrome)" },
            { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
            { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
            { label: "Firefox for iOS", pattern: "FxiOS" },
            { label: "IE", pattern: "IEMobile" },
            { label: "IE", pattern: "MSIE" },
            "Safari"
          ]);

          /* Detectable products (order is important). */
          var product = getProduct([
            { label: "BlackBerry", pattern: "BB10" },
            "BlackBerry",
            { label: "Galaxy S", pattern: "GT-I9000" },
            { label: "Galaxy S2", pattern: "GT-I9100" },
            { label: "Galaxy S3", pattern: "GT-I9300" },
            { label: "Galaxy S4", pattern: "GT-I9500" },
            { label: "Galaxy S5", pattern: "SM-G900" },
            { label: "Galaxy S6", pattern: "SM-G920" },
            { label: "Galaxy S6 Edge", pattern: "SM-G925" },
            { label: "Galaxy S7", pattern: "SM-G930" },
            { label: "Galaxy S7 Edge", pattern: "SM-G935" },
            "Google TV",
            "Lumia",
            "iPad",
            "iPod",
            "iPhone",
            "Kindle",
            { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
            "Nexus",
            "Nook",
            "PlayBook",
            "PlayStation Vita",
            "PlayStation",
            "TouchPad",
            "Transformer",
            { label: "Wii U", pattern: "WiiU" },
            "Wii",
            "Xbox One",
            { label: "Xbox 360", pattern: "Xbox" },
            "Xoom"
          ]);

          /* Detectable manufacturers. */
          var manufacturer = getManufacturer({
            Apple: { iPad: 1, iPhone: 1, iPod: 1 },
            Alcatel: {},
            Archos: {},
            Amazon: { Kindle: 1, "Kindle Fire": 1 },
            Asus: { Transformer: 1 },
            "Barnes & Noble": { Nook: 1 },
            BlackBerry: { PlayBook: 1 },
            Google: { "Google TV": 1, Nexus: 1 },
            HP: { TouchPad: 1 },
            HTC: {},
            Huawei: {},
            Lenovo: {},
            LG: {},
            Microsoft: { Xbox: 1, "Xbox One": 1 },
            Motorola: { Xoom: 1 },
            Nintendo: { "Wii U": 1, Wii: 1 },
            Nokia: { Lumia: 1 },
            Oppo: {},
            Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
            Sony: { PlayStation: 1, "PlayStation Vita": 1 },
            Xiaomi: { Mi: 1, Redmi: 1 }
          });

          /* Detectable operating systems (order is important). */
          var os = getOS([
            "Windows Phone",
            "KaiOS",
            "Android",
            "CentOS",
            { label: "Chrome OS", pattern: "CrOS" },
            "Debian",
            { label: "DragonFly BSD", pattern: "DragonFly" },
            "Fedora",
            "FreeBSD",
            "Gentoo",
            "Haiku",
            "Kubuntu",
            "Linux Mint",
            "OpenBSD",
            "Red Hat",
            "SuSE",
            "Ubuntu",
            "Xubuntu",
            "Cygwin",
            "Symbian OS",
            "hpwOS",
            "webOS ",
            "webOS",
            "Tablet OS",
            "Tizen",
            "Linux",
            "Mac OS X",
            "Macintosh",
            "Mac",
            "Windows 98;",
            "Windows "
          ]);

          /*------------------------------------------------------------------------*/

          /**
           * Picks the layout engine from an array of guesses.
           *
           * @private
           * @param {Array} guesses An array of guesses.
           * @returns {null|string} The detected layout engine.
           */
          function getLayout(guesses) {
            return reduce(guesses, function (result, guess) {
              return (
                result ||
                (RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess))
              );
            });
          }

          /**
           * Picks the manufacturer from an array of guesses.
           *
           * @private
           * @param {Array} guesses An object of guesses.
           * @returns {null|string} The detected manufacturer.
           */
          function getManufacturer(guesses) {
            return reduce(guesses, function (result, value, key) {
              // Lookup the manufacturer by product or scan the UA for the manufacturer.
              return (
                result ||
                ((value[product] ||
                  value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
                  RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) &&
                  key)
              );
            });
          }

          /**
           * Picks the browser name from an array of guesses.
           *
           * @private
           * @param {Array} guesses An array of guesses.
           * @returns {null|string} The detected browser name.
           */
          function getName(guesses) {
            return reduce(guesses, function (result, guess) {
              return (
                result ||
                (RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess))
              );
            });
          }

          /**
           * Picks the OS name from an array of guesses.
           *
           * @private
           * @param {Array} guesses An array of guesses.
           * @returns {null|string} The detected OS name.
           */
          function getOS(guesses) {
            return reduce(guesses, function (result, guess) {
              var pattern = guess.pattern || qualify(guess);
              if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                result = cleanupOS(result, pattern, guess.label || guess);
              }
              return result;
            });
          }

          /**
           * Picks the product name from an array of guesses.
           *
           * @private
           * @param {Array} guesses An array of guesses.
           * @returns {null|string} The detected product name.
           */
          function getProduct(guesses) {
            return reduce(guesses, function (result, guess) {
              var pattern = guess.pattern || qualify(guess);
              if (
                !result &&
                (result =
                  RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) ||
                  RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) ||
                  RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))
              ) {
                // Split by forward slash and append product version if needed.
                if (
                  (result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split(
                    "/"
                  ))[1] &&
                  !/[\d.]+/.test(result[0])
                ) {
                  result[0] += " " + result[1];
                }
                // Correct character case and cleanup string.
                guess = guess.label || guess;
                result = format(
                  result[0]
                    .replace(RegExp(pattern, "i"), guess)
                    .replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ")
                    .replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2")
                );
              }
              return result;
            });
          }

          /**
           * Resolves the version using an array of UA patterns.
           *
           * @private
           * @param {Array} patterns An array of UA patterns.
           * @returns {null|string} The detected version.
           */
          function getVersion(patterns) {
            return reduce(patterns, function (result, pattern) {
              return (
                result ||
                (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] ||
                null
              );
            });
          }

          /**
           * Returns `platform.description` when the platform object is coerced to a string.
           *
           * @name toString
           * @memberOf platform
           * @returns {string} Returns `platform.description` if available, else an empty string.
           */
          function toStringPlatform() {
            return this.description || "";
          }

          /*------------------------------------------------------------------------*/

          // Convert layout to an array so we can add extra details.
          layout && (layout = [layout]);

          // Detect Android products.
          // Browsers on Android devices typically provide their product IDS after "Android;"
          // up to "Build" or ") AppleWebKit".
          // Example:
          // "Mozilla/5.0 (Linux; Android 8.1.0; Moto G (5) Plus) AppleWebKit/537.36
          // (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36"
          if (
            /\bAndroid\b/.test(os) &&
            !product &&
            (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))
          ) {
            product =
              trim(data[1])
                // Replace any language codes (eg. "en-US").
                .replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
          }
          // Detect product names that contain their manufacturer's name.
          if (manufacturer && !product) {
            product = getProduct([manufacturer]);
          } else if (manufacturer && product) {
            product = product
              .replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ")
              .replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
          }
          // Clean up Google TV.
          if ((data = /\bGoogle TV\b/.exec(product))) {
            product = data[0];
          }
          // Detect simulators.
          if (/\bSimulator\b/i.test(ua)) {
            product = (product ? product + " " : "") + "Simulator";
          }
          // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
          if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
            description.push("running in Turbo/Uncompressed mode");
          }
          // Detect IE Mobile 11.
          if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
            data = parse(ua.replace(/like iPhone OS/, ""));
            manufacturer = data.manufacturer;
            product = data.product;
          }
          // Detect iOS.
          else if (/^iP/.test(product)) {
            name || (name = "Safari");
            os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
          }
          // Detect Kubuntu.
          else if (name == "Konqueror" && /^Linux\b/i.test(os)) {
            os = "Kubuntu";
          }
          // Detect Android browsers.
          else if (
            (manufacturer &&
              manufacturer != "Google" &&
              ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
            (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))
          ) {
            name = "Android Browser";
            os = /\bAndroid\b/.test(os) ? os : "Android";
          }
          // Detect Silk desktop/accelerated modes.
          else if (name == "Silk") {
            if (!/\bMobi/i.test(ua)) {
              os = "Android";
              description.unshift("desktop mode");
            }
            if (/Accelerated *= *true/i.test(ua)) {
              description.unshift("accelerated");
            }
          }
          // Detect UC Browser speed mode.
          else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
            description.push("speed mode");
          }
          // Detect PaleMoon identifying as Firefox.
          else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
            description.push("identifying as Firefox " + data[1]);
          }
          // Detect Firefox OS and products running Firefox.
          else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
            os || (os = "Firefox OS");
            product || (product = data[1]);
          }
          // Detect false positives for Firefox/Safari.
          else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
            // Escape the `/` for Firefox 1.
            if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
              // Clear name of false positives.
              name = null;
            }
            // Reassign a generic name.
            if (
              (data = product || manufacturer || os) &&
              (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))
            ) {
              name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
            }
          }
          // Add Chrome version to description for Electron.
          else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
            description.push("Chromium " + data);
          }
          // Detect non-Opera (Presto-based) versions (order is important).
          if (!version) {
            version = getVersion([
              "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
              "Version",
              qualify(name),
              "(?:Firefox|Minefield|NetFront)"
            ]);
          }
          // Detect stubborn layout engines.
          if (
            (data =
              (layout == "iCab" && parseFloat(version) > 3 && "WebKit") ||
              (/\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto")) ||
              (/\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit") ||
              (!layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident")) ||
              (layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront"))
          ) {
            layout = [data];
          }
          // Detect Windows Phone 7 desktop mode.
          if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
            name += " Mobile";
            os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
            description.unshift("desktop mode");
          }
          // Detect Windows Phone 8.x desktop mode.
          else if (/\bWPDesktop\b/i.test(ua)) {
            name = "IE Mobile";
            os = "Windows Phone 8.x";
            description.unshift("desktop mode");
            version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
          }
          // Detect IE 11 identifying as other browsers.
          else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
            if (name) {
              description.push("identifying as " + name + (version ? " " + version : ""));
            }
            name = "IE";
            version = data[1];
          }
          // Leverage environment features.
          if (useFeatures) {
            // Detect server-side environments.
            // Rhino has a global function while others have a global object.
            if (isHostType(context, "global")) {
              if (java) {
                data = java.lang.System;
                arch = data.getProperty("os.arch");
                os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
              }
              if (rhino) {
                try {
                  version = context.require("ringo/engine").version.join(".");
                  name = "RingoJS";
                } catch (e) {
                  if ((data = context.system) && data.global.system == context.system) {
                    name = "Narwhal";
                    os || (os = data[0].os || null);
                  }
                }
                if (!name) {
                  name = "Rhino";
                }
              } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                if (typeof data.versions == "object") {
                  if (typeof data.versions.electron == "string") {
                    description.push("Node " + data.versions.node);
                    name = "Electron";
                    version = data.versions.electron;
                  } else if (typeof data.versions.nw == "string") {
                    description.push("Chromium " + version, "Node " + data.versions.node);
                    name = "NW.js";
                    version = data.versions.nw;
                  }
                }
                if (!name) {
                  name = "Node.js";
                  arch = data.arch;
                  os = data.platform;
                  version = /[\d.]+/.exec(data.version);
                  version = version ? version[0] : null;
                }
              }
            }
            // Detect Adobe AIR.
            else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
              name = "Adobe AIR";
              os = data.flash.system.Capabilities.os;
            }
            // Detect PhantomJS.
            else if (getClassOf((data = context.phantom)) == phantomClass) {
              name = "PhantomJS";
              version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
            }
            // Detect IE compatibility modes.
            else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
              // We're in compatibility mode when the Trident version + 4 doesn't
              // equal the document mode.
              version = [version, doc.documentMode];
              if ((data = +data[1] + 4) != version[1]) {
                description.push("IE " + version[1] + " mode");
                layout && (layout[1] = "");
                version[1] = data;
              }
              version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
            }
            // Detect IE 11 masking as other browsers.
            else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
              description.push("masking as " + name + " " + version);
              name = "IE";
              version = "11.0";
              layout = ["Trident"];
              os = "Windows";
            }
            os = os && format(os);
          }
          // Detect prerelease phases.
          if (
            version &&
            (data =
              /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
              /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) ||
              (/\bMinefield\b/i.test(ua) && "a"))
          ) {
            prerelease = /b/i.test(data) ? "beta" : "alpha";
            version =
              version.replace(RegExp(data + "\\+?$"), "") +
              (prerelease == "beta" ? beta : alpha) +
              (/\d+\+?/.exec(data) || "");
          }
          // Detect Firefox Mobile.
          if (name == "Fennec" || (name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os))) {
            name = "Firefox Mobile";
          }
          // Obscure Maxthon's unreliable version.
          else if (name == "Maxthon" && version) {
            version = version.replace(/\.[\d.]+/, ".x");
          }
          // Detect Xbox 360 and Xbox One.
          else if (/\bXbox\b/i.test(product)) {
            if (product == "Xbox 360") {
              os = null;
            }
            if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
              description.unshift("mobile mode");
            }
          }
          // Add mobile postfix.
          else if (
            (/^(?:Chrome|IE|Opera)$/.test(name) || (name && !product && !/Browser|Mobi/.test(name))) &&
            (os == "Windows CE" || /Mobi/i.test(ua))
          ) {
            name += " Mobile";
          }
          // Detect IE platform preview.
          else if (name == "IE" && useFeatures) {
            try {
              if (context.external === null) {
                description.unshift("platform preview");
              }
            } catch (e) {
              description.unshift("embedded");
            }
          }
          // Detect BlackBerry OS version.
          // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
          else if (
            (/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) &&
            (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)
          ) {
            data = [data, /BB10/.test(ua)];
            os = (data[1] ? ((product = null), (manufacturer = "BlackBerry")) : "Device Software") + " " + data[0];
            version = null;
          }
          // Detect Opera identifying/masking itself as another browser.
          // http://www.opera.com/support/kb/view/843/
          else if (
            this != forOwn &&
            product != "Wii" &&
            ((useFeatures && opera) ||
              (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
              (name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os)) ||
              (name == "IE" &&
                ((os && !/^Win/.test(os) && version > 5.5) ||
                  (/\bWindows XP\b/.test(os) && version > 8) ||
                  (version == 8 && !/\bTrident\b/.test(ua))))) &&
            !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, "") + ";"))) &&
            data.name
          ) {
            // When "identifying", the UA contains both Opera and the other browser's name.
            data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
            if (reOpera.test(name)) {
              if (/\bIE\b/.test(data) && os == "Mac OS") {
                os = null;
              }
              data = "identify" + data;
            }
            // When "masking", the UA contains only the other browser's name.
            else {
              data = "mask" + data;
              if (operaClass) {
                name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
              } else {
                name = "Opera";
              }
              if (/\bIE\b/.test(data)) {
                os = null;
              }
              if (!useFeatures) {
                version = null;
              }
            }
            layout = ["Presto"];
            description.push(data);
          }
          // Detect WebKit Nightly and approximate Chrome/Safari versions.
          if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
            // Correct build number for numeric comparison.
            // (e.g. "532.5" becomes "532.05")
            data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
            // Nightly builds are postfixed with a "+".
            if (name == "Safari" && data[1].slice(-1) == "+") {
              name = "WebKit Nightly";
              prerelease = "alpha";
              version = data[1].slice(0, -1);
            }
            // Clear incorrect browser versions.
            else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
              version = null;
            }
            // Use the full Chrome version when available.
            data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
            // Detect Blink layout engine.
            if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
              layout = ["Blink"];
            }
            // Detect JavaScriptCore.
            // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
            if (!useFeatures || (!likeChrome && !data[1])) {
              layout && (layout[1] = "like Safari");
              data =
                ((data = data[0]),
                data < 400
                  ? 1
                  : data < 500
                  ? 2
                  : data < 526
                  ? 3
                  : data < 533
                  ? 4
                  : data < 534
                  ? "4+"
                  : data < 535
                  ? 5
                  : data < 537
                  ? 6
                  : data < 538
                  ? 7
                  : data < 601
                  ? 8
                  : data < 602
                  ? 9
                  : data < 604
                  ? 10
                  : data < 606
                  ? 11
                  : data < 608
                  ? 12
                  : "12");
            } else {
              layout && (layout[1] = "like Chrome");
              data =
                data[1] ||
                ((data = data[0]),
                data < 530
                  ? 1
                  : data < 532
                  ? 2
                  : data < 532.05
                  ? 3
                  : data < 533
                  ? 4
                  : data < 534.03
                  ? 5
                  : data < 534.07
                  ? 6
                  : data < 534.1
                  ? 7
                  : data < 534.13
                  ? 8
                  : data < 534.16
                  ? 9
                  : data < 534.24
                  ? 10
                  : data < 534.3
                  ? 11
                  : data < 535.01
                  ? 12
                  : data < 535.02
                  ? "13+"
                  : data < 535.07
                  ? 15
                  : data < 535.11
                  ? 16
                  : data < 535.19
                  ? 17
                  : data < 536.05
                  ? 18
                  : data < 536.1
                  ? 19
                  : data < 537.01
                  ? 20
                  : data < 537.11
                  ? "21+"
                  : data < 537.13
                  ? 23
                  : data < 537.18
                  ? 24
                  : data < 537.24
                  ? 25
                  : data < 537.36
                  ? 26
                  : layout != "Blink"
                  ? "27"
                  : "28");
            }
            // Add the postfix of ".x" or "+" for approximate versions.
            layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
            // Obscure version for some Safari 1-2 releases.
            if (name == "Safari" && (!version || parseInt(version) > 45)) {
              version = data;
            } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
              description.unshift("headless");
            }
          }
          // Detect Opera desktop modes.
          if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
            name += " ";
            description.unshift("desktop mode");
            if (data == "zvav") {
              name += "Mini";
              version = null;
            } else {
              name += "Mobile";
            }
            os = os.replace(RegExp(" *" + data + "$"), "");
          }
          // Detect Chrome desktop mode.
          else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
            description.unshift("desktop mode");
            name = "Chrome Mobile";
            version = null;

            if (/\bOS X\b/.test(os)) {
              manufacturer = "Apple";
              os = "iOS 4.3+";
            } else {
              os = null;
            }
          }
          // Newer versions of SRWare Iron uses the Chrome tag to indicate its version number.
          else if (/\bSRWare Iron\b/.test(name) && !version) {
            version = getVersion("Chrome");
          }
          // Strip incorrect OS versions.
          if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 && ua.indexOf("/" + data + "-") > -1) {
            os = trim(os.replace(data, ""));
          }
          // Ensure OS does not include the browser name.
          if (os && os.indexOf(name) != -1 && !RegExp(name + " OS").test(os)) {
            os = os.replace(RegExp(" *" + qualify(name) + " *"), "");
          }
          // Add layout engine.
          if (
            layout &&
            !/\b(?:Avant|Nook)\b/.test(name) &&
            (/Browser|Lunascape|Maxthon/.test(name) ||
              (name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1])) ||
              (/^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(
                name
              ) &&
                layout[1]))
          ) {
            // Don't add layout details to description if they are falsey.
            (data = layout[layout.length - 1]) && description.push(data);
          }
          // Combine contextual information.
          if (description.length) {
            description = ["(" + description.join("; ") + ")"];
          }
          // Append manufacturer to description.
          if (manufacturer && product && product.indexOf(manufacturer) < 0) {
            description.push("on " + manufacturer);
          }
          // Append product to description.
          if (product) {
            description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
          }
          // Parse the OS into an object.
          if (os) {
            data = / ([\d.+]+)$/.exec(os);
            isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
            os = {
              architecture: 32,
              family: data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
              version: data ? data[1] : null,
              toString: function () {
                var version = this.version;
                return (
                  this.family +
                  (version && !isSpecialCasedOS ? " " + version : "") +
                  (this.architecture == 64 ? " 64-bit" : "")
                );
              }
            };
          }
          // Add browser/OS architecture.
          if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
            if (os) {
              os.architecture = 64;
              os.family = os.family.replace(RegExp(" *" + data), "");
            }
            if (
              name &&
              (/\bWOW64\b/i.test(ua) ||
                (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
            ) {
              description.unshift("32-bit");
            }
          }
          // Chrome 39 and above on OS X is always 64-bit.
          else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version) >= 39) {
            os.architecture = 64;
          }

          ua || (ua = null);

          /*------------------------------------------------------------------------*/

          /**
           * The platform object.
           *
           * @name platform
           * @type Object
           */
          var platform = {};

          /**
           * The platform description.
           *
           * @memberOf platform
           * @type string|null
           */
          platform.description = ua;

          /**
           * The name of the browser's layout engine.
           *
           * The list of common layout engines include:
           * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
           *
           * @memberOf platform
           * @type string|null
           */
          platform.layout = layout && layout[0];

          /**
           * The name of the product's manufacturer.
           *
           * The list of manufacturers include:
           * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
           * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
           * "Nokia", "Samsung" and "Sony"
           *
           * @memberOf platform
           * @type string|null
           */
          platform.manufacturer = manufacturer;

          /**
           * The name of the browser/environment.
           *
           * The list of common browser names include:
           * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
           * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
           * "Opera Mini" and "Opera"
           *
           * Mobile versions of some browsers have "Mobile" appended to their name:
           * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
           *
           * @memberOf platform
           * @type string|null
           */
          platform.name = name;

          /**
           * The alpha/beta release indicator.
           *
           * @memberOf platform
           * @type string|null
           */
          platform.prerelease = prerelease;

          /**
           * The name of the product hosting the browser.
           *
           * The list of common products include:
           *
           * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
           * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
           *
           * @memberOf platform
           * @type string|null
           */
          platform.product = product;

          /**
           * The browser's user agent string.
           *
           * @memberOf platform
           * @type string|null
           */
          platform.ua = ua;

          /**
           * The browser/environment version.
           *
           * @memberOf platform
           * @type string|null
           */
          platform.version = name && version;

          /**
           * The name of the operating system.
           *
           * @memberOf platform
           * @type Object
           */
          platform.os = os || {
            /**
             * The CPU architecture the OS is built for.
             *
             * @memberOf platform.os
             * @type number|null
             */
            architecture: null,

            /**
             * The family of the OS.
             *
             * Common values include:
             * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
             * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
             * "SuSE", "Android", "iOS" and "Windows Phone"
             *
             * @memberOf platform.os
             * @type string|null
             */
            family: null,

            /**
             * The version of the OS.
             *
             * @memberOf platform.os
             * @type string|null
             */
            version: null,

            /**
             * Returns the OS string.
             *
             * @memberOf platform.os
             * @returns {string} The OS string.
             */
            toString: function () {
              return "null";
            }
          };

          platform.parse = parse;
          platform.toString = toStringPlatform;

          if (platform.version) {
            description.unshift(version);
          }
          if (platform.name) {
            description.unshift(name);
          }
          if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
            description.push(product ? "(" + os + ")" : "on " + os);
          }
          if (description.length) {
            platform.description = description.join(" ");
          }
          return platform;
        }

        /*--------------------------------------------------------------------------*/

        // Export platform.
        var platform = parse();

        // Some AMD build optimizers, like r.js, check for condition patterns like the following:
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          // Expose platform on the global object to prevent errors when platform is
          // loaded by a script tag in the presence of an AMD loader.
          // See http://requirejs.org/docs/errors.html#mismatch for more details.
          root.platform = platform;

          // Define as an anonymous module so platform can be aliased through path mapping.
          define(function () {
            return platform;
          });
        }
        // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
        else if (freeExports && freeModule) {
          // Export for CommonJS support.
          forOwn(platform, function (value, key) {
            freeExports[key] = value;
          });
        } else {
          // Export to the global object.
          root.platform = platform;
        }
      }).call(this);

      /***/
    },

    /***/ 8341: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var once = __nccwpck_require__(1223);
      var eos = __nccwpck_require__(1205);
      var fs = __nccwpck_require__(7147); // we only need fs to get the ReadStream and WriteStream prototypes

      var noop = function () {};
      var ancient = /^v?\.0/.test(process.version);

      var isFn = function (fn) {
        return typeof fn === "function";
      };

      var isFS = function (stream) {
        if (!ancient) return false; // newer node version do not need to care about fs is a special way
        if (!fs) return false; // browser
        return (
          (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) &&
          isFn(stream.close)
        );
      };

      var isRequest = function (stream) {
        return stream.setHeader && isFn(stream.abort);
      };

      var destroyer = function (stream, reading, writing, callback) {
        callback = once(callback);

        var closed = false;
        stream.on("close", function () {
          closed = true;
        });

        eos(stream, { readable: reading, writable: writing }, function (err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });

        var destroyed = false;
        return function (err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true;

          if (isFS(stream)) return stream.close(noop); // use close for fs streams to avoid fd leaks
          if (isRequest(stream)) return stream.abort(); // request.destroy just do .end - .abort is what we want

          if (isFn(stream.destroy)) return stream.destroy();

          callback(err || new Error("stream was destroyed"));
        };
      };

      var call = function (fn) {
        fn();
      };

      var pipe = function (from, to) {
        return from.pipe(to);
      };

      var pump = function () {
        var streams = Array.prototype.slice.call(arguments);
        var callback = (isFn(streams[streams.length - 1] || noop) && streams.pop()) || noop;

        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) throw new Error("pump requires two streams per minimum");

        var error;
        var destroys = streams.map(function (stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function (err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });

        return streams.reduce(pipe);
      };

      module.exports = pump;

      /***/
    },

    /***/ 4907: /***/ (module) => {
      "use strict";

      var replace = String.prototype.replace;
      var percentTwenties = /%20/g;

      var Format = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
      };

      module.exports = {
        default: Format.RFC3986,
        formatters: {
          RFC1738: function (value) {
            return replace.call(value, percentTwenties, "+");
          },
          RFC3986: function (value) {
            return String(value);
          }
        },
        RFC1738: Format.RFC1738,
        RFC3986: Format.RFC3986
      };

      /***/
    },

    /***/ 2760: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var stringify = __nccwpck_require__(9954);
      var parse = __nccwpck_require__(3912);
      var formats = __nccwpck_require__(4907);

      module.exports = {
        formats: formats,
        parse: parse,
        stringify: stringify
      };

      /***/
    },

    /***/ 3912: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var utils = __nccwpck_require__(2360);

      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;

      var defaults = {
        allowDots: false,
        allowPrototypes: false,
        allowSparse: false,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: false,
        comma: false,
        decoder: utils.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1000,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
      };

      var interpretNumericEntities = function (str) {
        return str.replace(/&#(\d+);/g, function ($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
        });
      };

      var parseArrayValue = function (val, options) {
        if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
          return val.split(",");
        }

        return val;
      };

      // This is what browsers will submit when the  character occurs in an
      // application/x-www-form-urlencoded body and the encoding of the page containing
      // the form is iso-8859-1, or when the submitted form has an accept-charset
      // attribute of iso-8859-1. Presumably also with other charsets that do not contain
      // the  character, such as us-ascii.
      var isoSentinel = "utf8=%26%2310003%3B"; // encodeURIComponent('&#10003;')

      // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
      var charsetSentinel = "utf8=%E2%9C%93"; // encodeURIComponent('')

      var parseValues = function parseQueryStringValues(str, options) {
        var obj = { __proto__: null };

        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
        var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1; // Keep track of where the utf8 sentinel was found
        var i;

        var charset = options.charset;
        if (options.charsetSentinel) {
          for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf("utf8=") === 0) {
              if (parts[i] === charsetSentinel) {
                charset = "utf-8";
              } else if (parts[i] === isoSentinel) {
                charset = "iso-8859-1";
              }
              skipIndex = i;
              i = parts.length; // The eslint settings do not allow break;
            }
          }
        }

        for (i = 0; i < parts.length; ++i) {
          if (i === skipIndex) {
            continue;
          }
          var part = parts[i];

          var bracketEqualsPos = part.indexOf("]=");
          var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;

          var key, val;
          if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
          } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            });
          }

          if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
            val = interpretNumericEntities(val);
          }

          if (part.indexOf("[]=") > -1) {
            val = isArray(val) ? [val] : val;
          }

          if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
          } else {
            obj[key] = val;
          }
        }

        return obj;
      };

      var parseObject = function (chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);

        for (var i = chain.length - 1; i >= 0; --i) {
          var obj;
          var root = chain[i];

          if (root === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
          } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
              obj = { 0: leaf };
            } else if (
              !isNaN(index) &&
              root !== cleanRoot &&
              String(index) === cleanRoot &&
              index >= 0 &&
              options.parseArrays &&
              index <= options.arrayLimit
            ) {
              obj = [];
              obj[index] = leaf;
            } else if (cleanRoot !== "__proto__") {
              obj[cleanRoot] = leaf;
            }
          }

          leaf = obj;
        }

        return leaf;
      };

      var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
          return;
        }

        // Transform dot notation to bracket notation
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;

        // The regex chunks

        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;

        // Get the parent

        var segment = options.depth > 0 && brackets.exec(key);
        var parent = segment ? key.slice(0, segment.index) : key;

        // Stash the parent if it exists

        var keys = [];
        if (parent) {
          // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
          if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
              return;
            }
          }

          keys.push(parent);
        }

        // Loop through children appending to the array until we hit depth

        var i = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
          i += 1;
          if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys.push(segment[1]);
        }

        // If there's a remainder, just add whatever is left

        if (segment) {
          keys.push("[" + key.slice(segment.index) + "]");
        }

        return parseObject(keys, val, options, valuesParsed);
      };

      var normalizeParseOptions = function normalizeParseOptions(opts) {
        if (!opts) {
          return defaults;
        }

        if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== "function") {
          throw new TypeError("Decoder has to be a function.");
        }

        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;

        return {
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
          allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
          arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
          charset: charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
          decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
          delimiter:
            typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
          // eslint-disable-next-line no-implicit-coercion, no-extra-parens
          depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities:
            typeof opts.interpretNumericEntities === "boolean"
              ? opts.interpretNumericEntities
              : defaults.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
          strictNullHandling:
            typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };

      module.exports = function (str, opts) {
        var options = normalizeParseOptions(opts);

        if (str === "" || str === null || typeof str === "undefined") {
          return options.plainObjects ? Object.create(null) : {};
        }

        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};

        // Iterate over the keys and setup the new object

        var keys = Object.keys(tempObj);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
          obj = utils.merge(obj, newObj, options);
        }

        if (options.allowSparse === true) {
          return obj;
        }

        return utils.compact(obj);
      };

      /***/
    },

    /***/ 9954: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var getSideChannel = __nccwpck_require__(4334);
      var utils = __nccwpck_require__(2360);
      var formats = __nccwpck_require__(4907);
      var has = Object.prototype.hasOwnProperty;

      var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
          return prefix + "[]";
        },
        comma: "comma",
        indices: function indices(prefix, key) {
          return prefix + "[" + key + "]";
        },
        repeat: function repeat(prefix) {
          return prefix;
        }
      };

      var isArray = Array.isArray;
      var push = Array.prototype.push;
      var pushToArray = function (arr, valueOrArray) {
        push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
      };

      var toISO = Date.prototype.toISOString;

      var defaultFormat = formats["default"];
      var defaults = {
        addQueryPrefix: false,
        allowDots: false,
        charset: "utf-8",
        charsetSentinel: false,
        delimiter: "&",
        encode: true,
        encoder: utils.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats.formatters[defaultFormat],
        // deprecated
        indices: false,
        serializeDate: function serializeDate(date) {
          return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
      };

      var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
        return (
          typeof v === "string" ||
          typeof v === "number" ||
          typeof v === "boolean" ||
          typeof v === "symbol" ||
          typeof v === "bigint"
        );
      };

      var sentinel = {};

      var stringify = function stringify(
        object,
        prefix,
        generateArrayPrefix,
        commaRoundTrip,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset,
        sideChannel
      ) {
        var obj = object;

        var tmpSc = sideChannel;
        var step = 0;
        var findFlag = false;
        while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
          // Where object last appeared in the ref tree
          var pos = tmpSc.get(object);
          step += 1;
          if (typeof pos !== "undefined") {
            if (pos === step) {
              throw new RangeError("Cyclic object value");
            } else {
              findFlag = true; // Break while
            }
          }
          if (typeof tmpSc.get(sentinel) === "undefined") {
            step = 0;
          }
        }

        if (typeof filter === "function") {
          obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
          obj = serializeDate(obj);
        } else if (generateArrayPrefix === "comma" && isArray(obj)) {
          obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
              return serializeDate(value);
            }
            return value;
          });
        }

        if (obj === null) {
          if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
          }

          obj = "";
        }

        if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
          if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
            return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
          }
          return [formatter(prefix) + "=" + formatter(String(obj))];
        }

        var values = [];

        if (typeof obj === "undefined") {
          return values;
        }

        var objKeys;
        if (generateArrayPrefix === "comma" && isArray(obj)) {
          // we need to join elements in
          if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
          }
          objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void undefined }];
        } else if (isArray(filter)) {
          objKeys = filter;
        } else {
          var keys = Object.keys(obj);
          objKeys = sort ? keys.sort(sort) : keys;
        }

        var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;

        for (var j = 0; j < objKeys.length; ++j) {
          var key = objKeys[j];
          var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];

          if (skipNulls && value === null) {
            continue;
          }

          var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === "function"
              ? generateArrayPrefix(adjustedPrefix, key)
              : adjustedPrefix
            : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");

          sideChannel.set(object, step);
          var valueSideChannel = getSideChannel();
          valueSideChannel.set(sentinel, sideChannel);
          pushToArray(
            values,
            stringify(
              value,
              keyPrefix,
              generateArrayPrefix,
              commaRoundTrip,
              strictNullHandling,
              skipNulls,
              generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
              filter,
              sort,
              allowDots,
              serializeDate,
              format,
              formatter,
              encodeValuesOnly,
              charset,
              valueSideChannel
            )
          );
        }

        return values;
      };

      var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
        if (!opts) {
          return defaults;
        }

        if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
          throw new TypeError("Encoder has to be a function.");
        }

        var charset = opts.charset || defaults.charset;
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }

        var format = formats["default"];
        if (typeof opts.format !== "undefined") {
          if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
          }
          format = opts.format;
        }
        var formatter = formats.formatters[format];

        var filter = defaults.filter;
        if (typeof opts.filter === "function" || isArray(opts.filter)) {
          filter = opts.filter;
        }

        return {
          addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
          allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
          charset: charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
          delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
          encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
          encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
          encodeValuesOnly:
            typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
          filter: filter,
          format: format,
          formatter: formatter,
          serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
          skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
          sort: typeof opts.sort === "function" ? opts.sort : null,
          strictNullHandling:
            typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
        };
      };

      module.exports = function (object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);

        var objKeys;
        var filter;

        if (typeof options.filter === "function") {
          filter = options.filter;
          obj = filter("", obj);
        } else if (isArray(options.filter)) {
          filter = options.filter;
          objKeys = filter;
        }

        var keys = [];

        if (typeof obj !== "object" || obj === null) {
          return "";
        }

        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
        } else if (opts && "indices" in opts) {
          arrayFormat = opts.indices ? "indices" : "repeat";
        } else {
          arrayFormat = "indices";
        }

        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
          throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        }
        var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;

        if (!objKeys) {
          objKeys = Object.keys(obj);
        }

        if (options.sort) {
          objKeys.sort(options.sort);
        }

        var sideChannel = getSideChannel();
        for (var i = 0; i < objKeys.length; ++i) {
          var key = objKeys[i];

          if (options.skipNulls && obj[key] === null) {
            continue;
          }
          pushToArray(
            keys,
            stringify(
              obj[key],
              key,
              generateArrayPrefix,
              commaRoundTrip,
              options.strictNullHandling,
              options.skipNulls,
              options.encode ? options.encoder : null,
              options.filter,
              options.sort,
              options.allowDots,
              options.serializeDate,
              options.format,
              options.formatter,
              options.encodeValuesOnly,
              options.charset,
              sideChannel
            )
          );
        }

        var joined = keys.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? "?" : "";

        if (options.charsetSentinel) {
          if (options.charset === "iso-8859-1") {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += "utf8=%26%2310003%3B&";
          } else {
            // encodeURIComponent('')
            prefix += "utf8=%E2%9C%93&";
          }
        }

        return joined.length > 0 ? prefix + joined : "";
      };

      /***/
    },

    /***/ 2360: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var formats = __nccwpck_require__(4907);

      var has = Object.prototype.hasOwnProperty;
      var isArray = Array.isArray;

      var hexTable = (function () {
        var array = [];
        for (var i = 0; i < 256; ++i) {
          array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
        }

        return array;
      })();

      var compactQueue = function compactQueue(queue) {
        while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];

          if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
              if (typeof obj[j] !== "undefined") {
                compacted.push(obj[j]);
              }
            }

            item.obj[item.prop] = compacted;
          }
        }
      };

      var arrayToObject = function arrayToObject(source, options) {
        var obj = options && options.plainObjects ? Object.create(null) : {};
        for (var i = 0; i < source.length; ++i) {
          if (typeof source[i] !== "undefined") {
            obj[i] = source[i];
          }
        }

        return obj;
      };

      var merge = function merge(target, source, options) {
        /* eslint no-param-reassign: 0 */
        if (!source) {
          return target;
        }

        if (typeof source !== "object") {
          if (isArray(target)) {
            target.push(source);
          } else if (target && typeof target === "object") {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
              target[source] = true;
            }
          } else {
            return [target, source];
          }

          return target;
        }

        if (!target || typeof target !== "object") {
          return [target].concat(source);
        }

        var mergeTarget = target;
        if (isArray(target) && !isArray(source)) {
          mergeTarget = arrayToObject(target, options);
        }

        if (isArray(target) && isArray(source)) {
          source.forEach(function (item, i) {
            if (has.call(target, i)) {
              var targetItem = target[i];
              if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                target[i] = merge(targetItem, item, options);
              } else {
                target.push(item);
              }
            } else {
              target[i] = item;
            }
          });
          return target;
        }

        return Object.keys(source).reduce(function (acc, key) {
          var value = source[key];

          if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
          } else {
            acc[key] = value;
          }
          return acc;
        }, mergeTarget);
      };

      var assign = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function (acc, key) {
          acc[key] = source[key];
          return acc;
        }, target);
      };

      var decode = function (str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, " ");
        if (charset === "iso-8859-1") {
          // unescape never throws, no try...catch needed:
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        // utf-8
        try {
          return decodeURIComponent(strWithoutPlus);
        } catch (e) {
          return strWithoutPlus;
        }
      };

      var encode = function encode(str, defaultEncoder, charset, kind, format) {
        // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
        // It has been adapted here for stricter adherence to RFC 3986
        if (str.length === 0) {
          return str;
        }

        var string = str;
        if (typeof str === "symbol") {
          string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== "string") {
          string = String(str);
        }

        if (charset === "iso-8859-1") {
          return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
          });
        }

        var out = "";
        for (var i = 0; i < string.length; ++i) {
          var c = string.charCodeAt(i);

          if (
            c === 0x2d || // -
            c === 0x2e || // .
            c === 0x5f || // _
            c === 0x7e || // ~
            (c >= 0x30 && c <= 0x39) || // 0-9
            (c >= 0x41 && c <= 0x5a) || // a-z
            (c >= 0x61 && c <= 0x7a) || // A-Z
            (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
          ) {
            out += string.charAt(i);
            continue;
          }

          if (c < 0x80) {
            out = out + hexTable[c];
            continue;
          }

          if (c < 0x800) {
            out = out + (hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)]);
            continue;
          }

          if (c < 0xd800 || c >= 0xe000) {
            out = out + (hexTable[0xe0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3f)] + hexTable[0x80 | (c & 0x3f)]);
            continue;
          }

          i += 1;
          c = 0x10000 + (((c & 0x3ff) << 10) | (string.charCodeAt(i) & 0x3ff));
          /* eslint operator-linebreak: [2, "before"] */
          out +=
            hexTable[0xf0 | (c >> 18)] +
            hexTable[0x80 | ((c >> 12) & 0x3f)] +
            hexTable[0x80 | ((c >> 6) & 0x3f)] +
            hexTable[0x80 | (c & 0x3f)];
        }

        return out;
      };

      var compact = function compact(value) {
        var queue = [{ obj: { o: value }, prop: "o" }];
        var refs = [];

        for (var i = 0; i < queue.length; ++i) {
          var item = queue[i];
          var obj = item.obj[item.prop];

          var keys = Object.keys(obj);
          for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
              queue.push({ obj: obj, prop: key });
              refs.push(val);
            }
          }
        }

        compactQueue(queue);

        return value;
      };

      var isRegExp = function isRegExp(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      };

      var isBuffer = function isBuffer(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }

        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
      };

      var combine = function combine(a, b) {
        return [].concat(a, b);
      };

      var maybeMap = function maybeMap(val, fn) {
        if (isArray(val)) {
          var mapped = [];
          for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
          }
          return mapped;
        }
        return fn(val);
      };

      module.exports = {
        arrayToObject: arrayToObject,
        assign: assign,
        combine: combine,
        compact: compact,
        decode: decode,
        encode: encode,
        isBuffer: isBuffer,
        isRegExp: isRegExp,
        maybeMap: maybeMap,
        merge: merge
      };

      /***/
    },

    /***/ 5118: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /* eslint-disable node/no-deprecated-api */

      var buffer = __nccwpck_require__(4300);
      var Buffer = buffer.Buffer;

      var safer = {};

      var key;

      for (key in buffer) {
        if (!buffer.hasOwnProperty(key)) continue;
        if (key === "SlowBuffer" || key === "Buffer") continue;
        safer[key] = buffer[key];
      }

      var Safer = (safer.Buffer = {});
      for (key in Buffer) {
        if (!Buffer.hasOwnProperty(key)) continue;
        if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
        Safer[key] = Buffer[key];
      }

      safer.Buffer.prototype = Buffer.prototype;

      if (!Safer.from || Safer.from === Uint8Array.from) {
        Safer.from = function (value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
          }
          if (value && typeof value.length === "undefined") {
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof value
            );
          }
          return Buffer(value, encodingOrOffset, length);
        };
      }

      if (!Safer.alloc) {
        Safer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
          }
          if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
          var buf = Buffer(size);
          if (!fill || fill.length === 0) {
            buf.fill(0);
          } else if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
          return buf;
        };
      }

      if (!safer.kStringMaxLength) {
        try {
          safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
        } catch (e) {
          // we can't determine kStringMaxLength in environments where process.binding
          // is unsupported, so let's not set it
        }
      }

      if (!safer.constants) {
        safer.constants = {
          MAX_LENGTH: safer.kMaxLength
        };
        if (safer.kStringMaxLength) {
          safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
      }

      module.exports = safer;

      /***/
    },

    /***/ 2043: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      (function (sax) {
        // wrapper for non-node envs
        sax.parser = function (strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;

        // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
        // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
        // since that's the earliest that a buffer overrun could occur.  This way, checks are
        // as rare as required, but as often as necessary to ensure never crossing this bound.
        // Furthermore, buffers are only tested at most once per write(), so passing a very
        // large string into write() might have undesirable effects, but this is manageable by
        // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
        // edge case, result in creating at most one complete copy of the string passed in.
        // Set to Infinity to have unlimited buffers.
        sax.MAX_BUFFER_LENGTH = 64 * 1024;

        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];

        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];

        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }

          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];

          // namespaces form a prototype chain.
          // it always points at the current tag,
          // which protos to its parent tag.
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }

          // mostly just for error reporting
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }

        if (!Object.create) {
          Object.create = function (o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
          };
        }

        if (!Object.keys) {
          Object.keys = function (o) {
            var a = [];
            for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
            return a;
          };
        }

        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
              // Text/cdata nodes can get big, and since they're buffered,
              // we can get here under normal conditions.
              // Avoid issues by emitting the text node now,
              // so at least it won't get any bigger.
              switch (buffers[i]) {
                case "textNode":
                  closeText(parser);
                  break;

                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;

                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;

                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          // schedule the next check for the earliest possible buffer overrun.
          var m = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m + parser.position;
        }

        function clearBuffers(parser) {
          for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = "";
          }
        }

        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }

        SAXParser.prototype = {
          end: function () {
            end(this);
          },
          write: write,
          resume: function () {
            this.error = null;
            return this;
          },
          close: function () {
            return this.write(null);
          },
          flush: function () {
            flushBuffers(this);
          }
        };

        var Stream;
        try {
          Stream = __nccwpck_require__(2781).Stream;
        } catch (ex) {
          Stream = function () {};
        }
        if (!Stream) Stream = function () {};

        var streamWraps = sax.EVENTS.filter(function (ev) {
          return ev !== "error" && ev !== "end";
        });

        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }

        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }

          Stream.apply(this);

          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;

          var me = this;

          this._parser.onend = function () {
            me.emit("end");
          };

          this._parser.onerror = function (er) {
            me.emit("error", er);

            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
          };

          this._decoder = null;

          streamWraps.forEach(function (ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function () {
                return me._parser["on" + ev];
              },
              set: function (h) {
                if (!h) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h;
                  return h;
                }
                me.on(ev, h);
              },
              enumerable: true,
              configurable: false
            });
          });
        }

        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });

        SAXStream.prototype.write = function (data) {
          if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
            if (!this._decoder) {
              var SD = __nccwpck_require__(1576).StringDecoder;
              this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
          }

          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };

        SAXStream.prototype.end = function (chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          this._parser.end();
          return true;
        };

        SAXStream.prototype.on = function (ev, handler) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function () {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }

          return Stream.prototype.on.call(me, ev, handler);
        };

        // this really needs to be replaced with character classes.
        // XML allows all manner of ridiculous numbers and digits.
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

        // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
        // This implementation works on strings, a single character at a time
        // as such, it cannot ever support astral-plane characters (10000-EFFFF)
        // without a significant breaking change to either this  parser, or the
        // JavaScript language.  Implementation of an emoji-capable xml parser
        // is left as an exercise for the reader.
        var nameStart =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

        var nameBody =
          /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

        var entityStart =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody =
          /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

        function isWhitespace(c) {
          return c === " " || c === "\n" || c === "\r" || c === "\t";
        }

        function isQuote(c) {
          return c === '"' || c === "'";
        }

        function isAttribEnd(c) {
          return c === ">" || isWhitespace(c);
        }

        function isMatch(regex, c) {
          return regex.test(c);
        }

        function notMatch(regex, c) {
          return !isMatch(regex, c);
        }

        var S = 0;
        sax.STATE = {
          BEGIN: S++, // leading byte order mark or whitespace
          BEGIN_WHITESPACE: S++, // leading whitespace
          TEXT: S++, // general stuff
          TEXT_ENTITY: S++, // &amp and such.
          OPEN_WAKA: S++, // <
          SGML_DECL: S++, // <!BLARG
          SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
          DOCTYPE: S++, // <!DOCTYPE
          DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
          DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
          DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
          COMMENT_STARTING: S++, // <!-
          COMMENT: S++, // <!--
          COMMENT_ENDING: S++, // <!-- blah -
          COMMENT_ENDED: S++, // <!-- blah --
          CDATA: S++, // <![CDATA[ something
          CDATA_ENDING: S++, // ]
          CDATA_ENDING_2: S++, // ]]
          PROC_INST: S++, // <?hi
          PROC_INST_BODY: S++, // <?hi there
          PROC_INST_ENDING: S++, // <?hi "there" ?
          OPEN_TAG: S++, // <strong
          OPEN_TAG_SLASH: S++, // <strong /
          ATTRIB: S++, // <a
          ATTRIB_NAME: S++, // <a foo
          ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
          ATTRIB_VALUE: S++, // <a foo=
          ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
          ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
          ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
          ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
          ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
          CLOSE_TAG: S++, // </a
          CLOSE_TAG_SAW_WHITE: S++, // </a   >
          SCRIPT: S++, // <script> ...
          SCRIPT_ENDING: S++ // <script> ... <
        };

        sax.XML_ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'"
        };

        sax.ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'",
          AElig: 198,
          Aacute: 193,
          Acirc: 194,
          Agrave: 192,
          Aring: 197,
          Atilde: 195,
          Auml: 196,
          Ccedil: 199,
          ETH: 208,
          Eacute: 201,
          Ecirc: 202,
          Egrave: 200,
          Euml: 203,
          Iacute: 205,
          Icirc: 206,
          Igrave: 204,
          Iuml: 207,
          Ntilde: 209,
          Oacute: 211,
          Ocirc: 212,
          Ograve: 210,
          Oslash: 216,
          Otilde: 213,
          Ouml: 214,
          THORN: 222,
          Uacute: 218,
          Ucirc: 219,
          Ugrave: 217,
          Uuml: 220,
          Yacute: 221,
          aacute: 225,
          acirc: 226,
          aelig: 230,
          agrave: 224,
          aring: 229,
          atilde: 227,
          auml: 228,
          ccedil: 231,
          eacute: 233,
          ecirc: 234,
          egrave: 232,
          eth: 240,
          euml: 235,
          iacute: 237,
          icirc: 238,
          igrave: 236,
          iuml: 239,
          ntilde: 241,
          oacute: 243,
          ocirc: 244,
          ograve: 242,
          oslash: 248,
          otilde: 245,
          ouml: 246,
          szlig: 223,
          thorn: 254,
          uacute: 250,
          ucirc: 251,
          ugrave: 249,
          uuml: 252,
          yacute: 253,
          yuml: 255,
          copy: 169,
          reg: 174,
          nbsp: 160,
          iexcl: 161,
          cent: 162,
          pound: 163,
          curren: 164,
          yen: 165,
          brvbar: 166,
          sect: 167,
          uml: 168,
          ordf: 170,
          laquo: 171,
          not: 172,
          shy: 173,
          macr: 175,
          deg: 176,
          plusmn: 177,
          sup1: 185,
          sup2: 178,
          sup3: 179,
          acute: 180,
          micro: 181,
          para: 182,
          middot: 183,
          cedil: 184,
          ordm: 186,
          raquo: 187,
          frac14: 188,
          frac12: 189,
          frac34: 190,
          iquest: 191,
          times: 215,
          divide: 247,
          OElig: 338,
          oelig: 339,
          Scaron: 352,
          scaron: 353,
          Yuml: 376,
          fnof: 402,
          circ: 710,
          tilde: 732,
          Alpha: 913,
          Beta: 914,
          Gamma: 915,
          Delta: 916,
          Epsilon: 917,
          Zeta: 918,
          Eta: 919,
          Theta: 920,
          Iota: 921,
          Kappa: 922,
          Lambda: 923,
          Mu: 924,
          Nu: 925,
          Xi: 926,
          Omicron: 927,
          Pi: 928,
          Rho: 929,
          Sigma: 931,
          Tau: 932,
          Upsilon: 933,
          Phi: 934,
          Chi: 935,
          Psi: 936,
          Omega: 937,
          alpha: 945,
          beta: 946,
          gamma: 947,
          delta: 948,
          epsilon: 949,
          zeta: 950,
          eta: 951,
          theta: 952,
          iota: 953,
          kappa: 954,
          lambda: 955,
          mu: 956,
          nu: 957,
          xi: 958,
          omicron: 959,
          pi: 960,
          rho: 961,
          sigmaf: 962,
          sigma: 963,
          tau: 964,
          upsilon: 965,
          phi: 966,
          chi: 967,
          psi: 968,
          omega: 969,
          thetasym: 977,
          upsih: 978,
          piv: 982,
          ensp: 8194,
          emsp: 8195,
          thinsp: 8201,
          zwnj: 8204,
          zwj: 8205,
          lrm: 8206,
          rlm: 8207,
          ndash: 8211,
          mdash: 8212,
          lsquo: 8216,
          rsquo: 8217,
          sbquo: 8218,
          ldquo: 8220,
          rdquo: 8221,
          bdquo: 8222,
          dagger: 8224,
          Dagger: 8225,
          bull: 8226,
          hellip: 8230,
          permil: 8240,
          prime: 8242,
          Prime: 8243,
          lsaquo: 8249,
          rsaquo: 8250,
          oline: 8254,
          frasl: 8260,
          euro: 8364,
          image: 8465,
          weierp: 8472,
          real: 8476,
          trade: 8482,
          alefsym: 8501,
          larr: 8592,
          uarr: 8593,
          rarr: 8594,
          darr: 8595,
          harr: 8596,
          crarr: 8629,
          lArr: 8656,
          uArr: 8657,
          rArr: 8658,
          dArr: 8659,
          hArr: 8660,
          forall: 8704,
          part: 8706,
          exist: 8707,
          empty: 8709,
          nabla: 8711,
          isin: 8712,
          notin: 8713,
          ni: 8715,
          prod: 8719,
          sum: 8721,
          minus: 8722,
          lowast: 8727,
          radic: 8730,
          prop: 8733,
          infin: 8734,
          ang: 8736,
          and: 8743,
          or: 8744,
          cap: 8745,
          cup: 8746,
          int: 8747,
          there4: 8756,
          sim: 8764,
          cong: 8773,
          asymp: 8776,
          ne: 8800,
          equiv: 8801,
          le: 8804,
          ge: 8805,
          sub: 8834,
          sup: 8835,
          nsub: 8836,
          sube: 8838,
          supe: 8839,
          oplus: 8853,
          otimes: 8855,
          perp: 8869,
          sdot: 8901,
          lceil: 8968,
          rceil: 8969,
          lfloor: 8970,
          rfloor: 8971,
          lang: 9001,
          rang: 9002,
          loz: 9674,
          spades: 9824,
          clubs: 9827,
          hearts: 9829,
          diams: 9830
        };

        Object.keys(sax.ENTITIES).forEach(function (key) {
          var e = sax.ENTITIES[key];
          var s = typeof e === "number" ? String.fromCharCode(e) : e;
          sax.ENTITIES[key] = s;
        });

        for (var s in sax.STATE) {
          sax.STATE[sax.STATE[s]] = s;
        }

        // shorthand
        S = sax.STATE;

        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }

        function emitNode(parser, nodeType, data) {
          if (parser.textNode) closeText(parser);
          emit(parser, nodeType, data);
        }

        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode) emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }

        function textopts(opt, text) {
          if (opt.trim) text = text.trim();
          if (opt.normalize) text = text.replace(/\s+/g, " ");
          return text;
        }

        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit(parser, "onerror", er);
          return parser;
        }

        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
          if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }

        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }

        function newTag(parser) {
          if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = (parser.tag = { name: parser.tagName, attributes: {} });

          // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }

        function qname(name, attribute) {
          var i = name.indexOf(":");
          var qualName = i < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];

          // <x "xmlns"="http://foo">
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }

          return { prefix: prefix, local: local };
        }

        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }

          if (
            parser.attribList.indexOf(parser.attribName) !== -1 ||
            parser.tag.attributes.hasOwnProperty(parser.attribName)
          ) {
            parser.attribName = parser.attribValue = "";
            return;
          }

          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;

            if (prefix === "xmlns") {
              // namespace binding attribute. push the binding into scope
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue
                );
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }

            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }

          parser.attribName = parser.attribValue = "";
        }

        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;

            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";

            if (tag.prefix && !tag.uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
              tag.uri = qn.prefix;
            }

            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function (p) {
                emitNode(parser, "onopennamespace", {
                  prefix: p,
                  uri: tag.ns[p]
                });
              });
            }

            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
              var nv = parser.attribList[i];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a = {
                name: name,
                value: value,
                prefix: prefix,
                local: local,
                uri: uri
              };

              // if there's any attributes with an undefined namespace,
              // then fail on them now.
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                a.uri = prefix;
              }
              parser.tag.attributes[name] = a;
              emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
          }

          parser.tag.isSelfClosing = !!selfClosing;

          // process the tag
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S.SCRIPT;
            } else {
              parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }

        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
          }

          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }

          // first make sure that the closing tag actually exists.
          // <a><b></c></b></a> will close everything, otherwise.
          var t = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
              // fail the first time in strict mode
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }

          // didn't find it.  we already failed for strict, so just abort.
          if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s = parser.tags.length;
          while (s-- > t) {
            var tag = (parser.tag = parser.tags.pop());
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);

            var x = {};
            for (var i in tag.ns) {
              x[i] = tag.ns[i];
            }

            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              // remove namespace bindings introduced by tag
              Object.keys(tag.ns).forEach(function (p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
              });
            }
          }
          if (t === 0) parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S.TEXT;
        }

        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";

          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }

          return String.fromCodePoint(num);
        }

        function beginWhiteSpace(parser, c) {
          if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
          }
        }

        function charAt(chunk, i) {
          var result = "";
          if (i < chunk.length) {
            result = chunk.charAt(i);
          }
          return result;
        }

        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(parser, "Cannot write after close. Assign an onready handler.");
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i = 0;
          var c = "";
          while (true) {
            c = charAt(chunk, i++);
            parser.c = c;

            if (!c) {
              break;
            }

            if (parser.trackPosition) {
              parser.position++;
              if (c === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }

            switch (parser.state) {
              case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c);
                continue;

              case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;

              case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i - 1;
                  while (c && c !== "<" && c !== "&") {
                    c = charAt(chunk, i++);
                    if (c && parser.trackPosition) {
                      parser.position++;
                      if (c === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i - 1);
                }
                if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c === "&") {
                    parser.state = S.TEXT_ENTITY;
                  } else {
                    parser.textNode += c;
                  }
                }
                continue;

              case S.SCRIPT:
                // only non-strict
                if (c === "<") {
                  parser.state = S.SCRIPT_ENDING;
                } else {
                  parser.script += c;
                }
                continue;

              case S.SCRIPT_ENDING:
                if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                } else {
                  parser.script += "<" + c;
                  parser.state = S.SCRIPT;
                }
                continue;

              case S.OPEN_WAKA:
                // either a /, ?, !, or text is coming next.
                if (c === "!") {
                  parser.state = S.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c)) {
                  // wait for it...
                } else if (isMatch(nameStart, c)) {
                  parser.state = S.OPEN_TAG;
                  parser.tagName = c;
                } else if (c === "/") {
                  parser.state = S.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c === "?") {
                  parser.state = S.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  // if there was some whitespace, then add that in.
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c = new Array(pad).join(" ") + c;
                  }
                  parser.textNode += "<" + c;
                  parser.state = S.TEXT;
                }
                continue;

              case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if (parser.sgmlDecl + c === "--") {
                  parser.state = S.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                  parser.state = S.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(parser, "Inappropriately located doctype declaration");
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S.TEXT;
                } else if (isQuote(c)) {
                  parser.state = S.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c;
                } else {
                  parser.sgmlDecl += c;
                }
                continue;

              case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                  parser.state = S.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c;
                continue;

              case S.DOCTYPE:
                if (c === ">") {
                  parser.state = S.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true; // just remember that we saw it.
                } else {
                  parser.doctype += c;
                  if (c === "[") {
                    parser.state = S.DOCTYPE_DTD;
                  } else if (isQuote(c)) {
                    parser.state = S.DOCTYPE_QUOTED;
                    parser.q = c;
                  }
                }
                continue;

              case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.q = "";
                  parser.state = S.DOCTYPE;
                }
                continue;

              case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === "]") {
                  parser.state = S.DOCTYPE;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_DTD_QUOTED;
                  parser.q = c;
                }
                continue;

              case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                  parser.state = S.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;

              case S.COMMENT:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDING;
                } else {
                  parser.comment += c;
                }
                continue;

              case S.COMMENT_ENDING:
                if (c === "-") {
                  parser.state = S.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c;
                  parser.state = S.COMMENT;
                }
                continue;

              case S.COMMENT_ENDED:
                if (c !== ">") {
                  strictFail(parser, "Malformed comment");
                  // allow <!-- blah -- bloo --> in non-strict mode,
                  // which is a comment of " blah -- bloo "
                  parser.comment += "--" + c;
                  parser.state = S.COMMENT;
                } else {
                  parser.state = S.TEXT;
                }
                continue;

              case S.CDATA:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING;
                } else {
                  parser.cdata += c;
                }
                continue;

              case S.CDATA_ENDING:
                if (c === "]") {
                  parser.state = S.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c;
                  parser.state = S.CDATA;
                }
                continue;

              case S.CDATA_ENDING_2:
                if (c === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S.TEXT;
                } else if (c === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c;
                  parser.state = S.CDATA;
                }
                continue;

              case S.PROC_INST:
                if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else if (isWhitespace(c)) {
                  parser.state = S.PROC_INST_BODY;
                } else {
                  parser.procInstName += c;
                }
                continue;

              case S.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c)) {
                  continue;
                } else if (c === "?") {
                  parser.state = S.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c;
                }
                continue;

              case S.PROC_INST_ENDING:
                if (c === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S.TEXT;
                } else {
                  parser.procInstBody += "?" + c;
                  parser.state = S.PROC_INST_BODY;
                }
                continue;

              case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else {
                  newTag(parser);
                  if (c === ">") {
                    openTag(parser);
                  } else if (c === "/") {
                    parser.state = S.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S.ATTRIB;
                  }
                }
                continue;

              case S.OPEN_TAG_SLASH:
                if (c === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(parser, "Forward-slash in opening tag not followed by >");
                  parser.state = S.ATTRIB;
                }
                continue;

              case S.ATTRIB:
                // haven't read the attribute name yet.
                if (isWhitespace(c)) {
                  continue;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;

              case S.ATTRIB_NAME:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (c === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c)) {
                  parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                  parser.attribName += c;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;

              case S.ATTRIB_NAME_SAW_WHITE:
                if (c === "=") {
                  parser.state = S.ATTRIB_VALUE;
                } else if (isWhitespace(c)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.state = S.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S.ATTRIB;
                  }
                }
                continue;

              case S.ATTRIB_VALUE:
                if (isWhitespace(c)) {
                  continue;
                } else if (isQuote(c)) {
                  parser.q = c;
                  parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                  strictFail(parser, "Unquoted attribute value");
                  parser.state = S.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c;
                }
                continue;

              case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;

              case S.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c)) {
                  parser.state = S.ATTRIB;
                } else if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c;
                  parser.attribValue = "";
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;

              case S.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c)) {
                  if (c === "&") {
                    parser.state = S.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c;
                  }
                  continue;
                }
                attrib(parser);
                if (c === ">") {
                  openTag(parser);
                } else {
                  parser.state = S.ATTRIB;
                }
                continue;

              case S.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c)) {
                    continue;
                  } else if (notMatch(nameStart, c)) {
                    if (parser.script) {
                      parser.script += "</" + c;
                      parser.state = S.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c;
                  }
                } else if (c === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                  parser.tagName += c;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName;
                  parser.tagName = "";
                  parser.state = S.SCRIPT;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;

              case S.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c)) {
                  continue;
                }
                if (c === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;

              case S.TEXT_ENTITY:
              case S.ATTRIB_VALUE_ENTITY_Q:
              case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = "textNode";
                    break;

                  case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;

                  case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }

                if (c === ";") {
                  if (parser.opt.unparsedEntities) {
                    var parsedEntity = parseEntity(parser);
                    parser.entity = "";
                    parser.state = returnState;
                    parser.write(parsedEntity);
                  } else {
                    parser[buffer] += parseEntity(parser);
                    parser.entity = "";
                    parser.state = returnState;
                  }
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                  parser.entity += c;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c;
                  parser.entity = "";
                  parser.state = returnState;
                }

                continue;

              default: /* istanbul ignore next */ {
                throw new Error(parser, "Unknown state: " + parser.state);
              }
            }
          } // while

          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }

        /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
        /* istanbul ignore next */
        if (!String.fromCodePoint) {
          (function () {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function () {
              var MAX_SIZE = 0x4000;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (
                  !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 0x10ffff || // not a valid Unicode code point
                  floor(codePoint) !== codePoint // not an integer
                ) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 0xffff) {
                  // BMP code point
                  codeUnits.push(codePoint);
                } else {
                  // Astral code point; split in surrogate halves
                  // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                  codePoint -= 0x10000;
                  highSurrogate = (codePoint >> 10) + 0xd800;
                  lowSurrogate = (codePoint % 0x400) + 0xdc00;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            /* istanbul ignore next */
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(false ? 0 : exports);

      /***/
    },

    /***/ 9100: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /**
       * Copyright(c) dead_horse and other contributors.
       * MIT Licensed
       *
       * Authors:
       * 	 dead_horse <dead_horse@qq.com>
       *   fengmk2 <fengmk2@gmail.com> (http://fengmk2.com)
       */

      /**
       * Module dependencies.
       */

      var ready = __nccwpck_require__(5284);
      var EventEmitter = __nccwpck_require__(2361).EventEmitter;
      var util = __nccwpck_require__(3837);

      module.exports = Base;

      function Base() {
        EventEmitter.call(this);
        this.on("error", this.defaultErrorHandler.bind(this));
      }

      /**
       * inherits from EventEmitter
       */

      util.inherits(Base, EventEmitter);

      ready.mixin(Base.prototype);

      Base.prototype.defaultErrorHandler = function (err) {
        if (this.listeners("error").length > 1) {
          // ignore defaultErrorHandler
          return;
        }
        console.error(
          "\n[%s][pid: %s][%s][%s] %s: %s \nError Stack:\n  %s",
          Date(),
          process.pid,
          this.constructor.name,
          __filename,
          err.name,
          err.message,
          err.stack
        );

        // try to show addition property on the error object
        // e.g.: `err.data = {url: '/foo'};`
        var additions = [];
        for (var key in err) {
          if (key === "name" || key === "message") {
            continue;
          }

          additions.push(util.format("  %s: %j", key, err[key]));
        }
        if (additions.length) {
          console.error("Error Additions:\n%s", additions.join("\n"));
        }
        console.error();
      };

      /***/
    },

    /***/ 4334: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var GetIntrinsic = __nccwpck_require__(4538);
      var callBound = __nccwpck_require__(8803);
      var inspect = __nccwpck_require__(504);

      var $TypeError = GetIntrinsic("%TypeError%");
      var $WeakMap = GetIntrinsic("%WeakMap%", true);
      var $Map = GetIntrinsic("%Map%", true);

      var $weakMapGet = callBound("WeakMap.prototype.get", true);
      var $weakMapSet = callBound("WeakMap.prototype.set", true);
      var $weakMapHas = callBound("WeakMap.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSet = callBound("Map.prototype.set", true);
      var $mapHas = callBound("Map.prototype.has", true);

      /*
       * This function traverses the list returning the node corresponding to the
       * given key.
       *
       * That node is also moved to the head of the list, so that if it's accessed
       * again we don't need to traverse the whole list. By doing so, all the recently
       * used nodes can be accessed relatively quickly.
       */
      var listGetNode = function (list, key) {
        // eslint-disable-line consistent-return
        for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
          if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr; // eslint-disable-line no-param-reassign
            return curr;
          }
        }
      };

      var listGet = function (objects, key) {
        var node = listGetNode(objects, key);
        return node && node.value;
      };
      var listSet = function (objects, key, value) {
        var node = listGetNode(objects, key);
        if (node) {
          node.value = value;
        } else {
          // Prepend the new node to the beginning of the list
          objects.next = {
            // eslint-disable-line no-param-reassign
            key: key,
            next: objects.next,
            value: value
          };
        }
      };
      var listHas = function (objects, key) {
        return !!listGetNode(objects, key);
      };

      module.exports = function getSideChannel() {
        var $wm;
        var $m;
        var $o;
        var channel = {
          assert: function (key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          get: function (key) {
            // eslint-disable-line consistent-return
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapGet($m, key);
              }
            } else {
              if ($o) {
                // eslint-disable-line no-lonely-if
                return listGet($o, key);
              }
            }
          },
          has: function (key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapHas($m, key);
              }
            } else {
              if ($o) {
                // eslint-disable-line no-lonely-if
                return listHas($o, key);
              }
            }
            return false;
          },
          set: function (key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if ($Map) {
              if (!$m) {
                $m = new $Map();
              }
              $mapSet($m, key, value);
            } else {
              if (!$o) {
                /*
                 * Initialize the linked list as an empty node, so that we don't have
                 * to special-case handling of the first node: we can always refer to
                 * it as (previous node).next, instead of something like (list).head
                 */
                $o = { key: {}, next: null };
              }
              listSet($o, key, value);
            }
          }
        };
        return channel;
      };

      /***/
    },

    /***/ 7415: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /*!
       * statuses
       * Copyright(c) 2014 Jonathan Ong
       * Copyright(c) 2016 Douglas Christopher Wilson
       * MIT Licensed
       */

      /**
       * Module dependencies.
       * @private
       */

      var codes = __nccwpck_require__(855);

      /**
       * Module exports.
       * @public
       */

      module.exports = status;

      // status code to message map
      status.STATUS_CODES = codes;

      // array of status codes
      status.codes = populateStatusesMap(status, codes);

      // status codes for redirects
      status.redirect = {
        300: true,
        301: true,
        302: true,
        303: true,
        305: true,
        307: true,
        308: true
      };

      // status codes for empty bodies
      status.empty = {
        204: true,
        205: true,
        304: true
      };

      // status codes for when you should retry the request
      status.retry = {
        502: true,
        503: true,
        504: true
      };

      /**
       * Populate the statuses map for given codes.
       * @private
       */

      function populateStatusesMap(statuses, codes) {
        var arr = [];

        Object.keys(codes).forEach(function forEachCode(code) {
          var message = codes[code];
          var status = Number(code);

          // Populate properties
          statuses[status] = message;
          statuses[message] = status;
          statuses[message.toLowerCase()] = status;

          // Add to array
          arr.push(status);
        });

        return arr;
      }

      /**
       * Get the status code.
       *
       * Given a number, this will throw if it is not a known status
       * code, otherwise the code will be returned. Given a string,
       * the string will be parsed for a number and return the code
       * if valid, otherwise will lookup the code assuming this is
       * the status message.
       *
       * @param {string|number} code
       * @returns {number}
       * @public
       */

      function status(code) {
        if (typeof code === "number") {
          if (!status[code]) throw new Error("invalid status code: " + code);
          return code;
        }

        if (typeof code !== "string") {
          throw new TypeError("code must be a number or string");
        }

        // '403'
        var n = parseInt(code, 10);
        if (!isNaN(n)) {
          if (!status[n]) throw new Error("invalid status code: " + n);
          return n;
        }

        n = status[code.toLowerCase()];
        if (!n) throw new Error('invalid status message: "' + code + '"');
        return n;
      }

      /***/
    },

    /***/ 8751: /***/ (module) => {
      "use strict";

      module.exports = (stream, throwError) => {
        return new Promise((resolve, reject) => {
          if (typeof stream.resume !== "function") {
            return resolve();
          }

          // unpipe it
          stream.unpipe && stream.unpipe();
          // enable resume first
          stream.resume();

          if (stream._readableState && stream._readableState.ended) {
            return resolve();
          }
          if (!stream.readable || stream.destroyed) {
            return resolve();
          }

          function cleanup() {
            stream.removeListener("end", onEnd);
            stream.removeListener("close", onEnd);
            stream.removeListener("error", onError);
          }

          function onEnd() {
            cleanup();
            resolve();
          }

          function onError(err) {
            cleanup();
            // don't throw error by default
            if (throwError) {
              reject(err);
            } else {
              resolve();
            }
          }

          stream.on("end", onEnd);
          stream.on("close", onEnd);
          stream.on("error", onError);
        });
      };

      /***/
    },

    /***/ 9318: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      const os = __nccwpck_require__(2037);
      const tty = __nccwpck_require__(6224);
      const hasFlag = __nccwpck_require__(1621);

      const { env } = process;

      let forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }

      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }

      function translateLevel(level) {
        if (level === 0) {
          return false;
        }

        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }

      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }

        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }

        if (hasFlag("color=256")) {
          return 2;
        }

        if (haveStream && !streamIsTTY && forceColor === undefined) {
          return 0;
        }

        const min = forceColor || 0;

        if (env.TERM === "dumb") {
          return min;
        }

        if (process.platform === "win32") {
          // Windows 10 build 10586 is the first Windows release that supports 256 colors.
          // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
          const osRelease = os.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }

          return 1;
        }

        if ("CI" in env) {
          if (
            ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some(
              (sign) => sign in env
            ) ||
            env.CI_NAME === "codeship"
          ) {
            return 1;
          }

          return min;
        }

        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }

        if (env.COLORTERM === "truecolor") {
          return 3;
        }

        if ("TERM_PROGRAM" in env) {
          const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);

          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
            // No default
          }
        }

        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }

        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }

        if ("COLORTERM" in env) {
          return 1;
        }

        return min;
      }

      function getSupportLevel(stream) {
        const level = supportsColor(stream, stream && stream.isTTY);
        return translateLevel(level);
      }

      module.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };

      /***/
    },

    /***/ 8690: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var thenify = __nccwpck_require__(4115);

      module.exports = thenifyAll;
      thenifyAll.withCallback = withCallback;
      thenifyAll.thenify = thenify;

      /**
       * Promisifies all the selected functions in an object.
       *
       * @param {Object} source the source object for the async functions
       * @param {Object} [destination] the destination to set all the promisified methods
       * @param {Array} [methods] an array of method names of `source`
       * @return {Object}
       * @api public
       */

      function thenifyAll(source, destination, methods) {
        return promisifyAll(source, destination, methods, thenify);
      }

      /**
       * Promisifies all the selected functions in an object and backward compatible with callback.
       *
       * @param {Object} source the source object for the async functions
       * @param {Object} [destination] the destination to set all the promisified methods
       * @param {Array} [methods] an array of method names of `source`
       * @return {Object}
       * @api public
       */

      function withCallback(source, destination, methods) {
        return promisifyAll(source, destination, methods, thenify.withCallback);
      }

      function promisifyAll(source, destination, methods, promisify) {
        if (!destination) {
          destination = {};
          methods = Object.keys(source);
        }

        if (Array.isArray(destination)) {
          methods = destination;
          destination = {};
        }

        if (!methods) {
          methods = Object.keys(source);
        }

        if (typeof source === "function") destination = promisify(source);

        methods.forEach(function (name) {
          // promisify only if it's a function
          if (typeof source[name] === "function") destination[name] = promisify(source[name]);
        });

        // proxy the rest
        Object.keys(source).forEach(function (name) {
          if (deprecated(source, name)) return;
          if (destination[name]) return;
          destination[name] = source[name];
        });

        return destination;
      }

      function deprecated(source, name) {
        var desc = Object.getOwnPropertyDescriptor(source, name);
        if (!desc || !desc.get) return false;
        if (desc.get.name === "deprecated") return true;
        return false;
      }

      /***/
    },

    /***/ 4115: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      var Promise = __nccwpck_require__(5768);
      var assert = __nccwpck_require__(9491);

      module.exports = thenify;

      /**
       * Turn async functions into promises
       *
       * @param {Function} fn
       * @return {Function}
       * @api public
       */

      function thenify(fn, options) {
        assert(typeof fn === "function");
        return createWrapper(fn, options);
      }

      /**
       * Turn async functions into promises and backward compatible with callback
       *
       * @param {Function} fn
       * @return {Function}
       * @api public
       */

      thenify.withCallback = function (fn, options) {
        assert(typeof fn === "function");
        options = options || {};
        options.withCallback = true;
        return createWrapper(fn, options);
      };

      function createCallback(resolve, reject, multiArgs) {
        // default to true
        if (multiArgs === undefined) multiArgs = true;
        return function (err, value) {
          if (err) return reject(err);
          var length = arguments.length;

          if (length <= 2 || !multiArgs) return resolve(value);

          if (Array.isArray(multiArgs)) {
            var values = {};
            for (var i = 1; i < length; i++) values[multiArgs[i - 1]] = arguments[i];
            return resolve(values);
          }

          var values = new Array(length - 1);
          for (var i = 1; i < length; ++i) values[i - 1] = arguments[i];
          resolve(values);
        };
      }

      function createWrapper(fn, options) {
        options = options || {};
        var name = fn.name;
        name = (name || "").replace(/\s|bound(?!$)/g, "");
        var newFn = function () {
          var self = this;
          var len = arguments.length;
          if (options.withCallback) {
            var lastType = typeof arguments[len - 1];
            if (lastType === "function") return fn.apply(self, arguments);
          }
          var args = new Array(len + 1);
          for (var i = 0; i < len; ++i) args[i] = arguments[i];
          var lastIndex = i;
          return new Promise(function (resolve, reject) {
            args[lastIndex] = createCallback(resolve, reject, options.multiArgs);
            fn.apply(self, args);
          });
        };
        Object.defineProperty(newFn, "name", { value: name });
        return newFn;
      }

      /***/
    },

    /***/ 421: /***/ (module, exports, __nccwpck_require__) => {
      var Stream = __nccwpck_require__(2781);

      // through
      //
      // a stream that does nothing but re-emit the input.
      // useful for aggregating a series of changing but not ending streams into one stream)

      exports = module.exports = through;
      through.through = through;

      //create a readable writable stream.

      function through(write, end, opts) {
        write =
          write ||
          function (data) {
            this.queue(data);
          };
        end =
          end ||
          function () {
            this.queue(null);
          };

        var ended = false,
          destroyed = false,
          buffer = [],
          _ended = false;
        var stream = new Stream();
        stream.readable = stream.writable = true;
        stream.paused = false;

        //  stream.autoPause   = !(opts && opts.autoPause   === false)
        stream.autoDestroy = !(opts && opts.autoDestroy === false);

        stream.write = function (data) {
          write.call(this, data);
          return !stream.paused;
        };

        function drain() {
          while (buffer.length && !stream.paused) {
            var data = buffer.shift();
            if (null === data) return stream.emit("end");
            else stream.emit("data", data);
          }
        }

        stream.queue = stream.push = function (data) {
          //    console.error(ended)
          if (_ended) return stream;
          if (data === null) _ended = true;
          buffer.push(data);
          drain();
          return stream;
        };

        //this will be registered as the first 'end' listener
        //must call destroy next tick, to make sure we're after any
        //stream piped from here.
        //this is only a problem if end is not emitted synchronously.
        //a nicer way to do this is to make sure this is the last listener for 'end'

        stream.on("end", function () {
          stream.readable = false;
          if (!stream.writable && stream.autoDestroy)
            process.nextTick(function () {
              stream.destroy();
            });
        });

        function _end() {
          stream.writable = false;
          end.call(stream);
          if (!stream.readable && stream.autoDestroy) stream.destroy();
        }

        stream.end = function (data) {
          if (ended) return;
          ended = true;
          if (arguments.length) stream.write(data);
          _end(); // will emit or queue
          return stream;
        };

        stream.destroy = function () {
          if (destroyed) return;
          destroyed = true;
          ended = true;
          buffer.length = 0;
          stream.writable = stream.readable = false;
          stream.emit("close");
          return stream;
        };

        stream.pause = function () {
          if (stream.paused) return;
          stream.paused = true;
          return stream;
        };

        stream.resume = function () {
          if (stream.paused) {
            stream.paused = false;
            stream.emit("resume");
          }
          drain();
          //may have become paused again,
          //as drain emits 'data'.
          if (!stream.paused) stream.emit("drain");
          return stream;
        };
        return stream;
      }

      /***/
    },

    /***/ 4294: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(4219);

      /***/
    },

    /***/ 4219: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var net = __nccwpck_require__(1808);
      var tls = __nccwpck_require__(4404);
      var http = __nccwpck_require__(3685);
      var https = __nccwpck_require__(5687);
      var events = __nccwpck_require__(2361);
      var assert = __nccwpck_require__(9491);
      var util = __nccwpck_require__(3837);

      exports.httpOverHttp = httpOverHttp;
      exports.httpsOverHttp = httpsOverHttp;
      exports.httpOverHttps = httpOverHttps;
      exports.httpsOverHttps = httpsOverHttps;

      function httpOverHttp(options) {
        var agent = new TunnelingAgent(options);
        agent.request = http.request;
        return agent;
      }

      function httpsOverHttp(options) {
        var agent = new TunnelingAgent(options);
        agent.request = http.request;
        agent.createSocket = createSecureSocket;
        agent.defaultPort = 443;
        return agent;
      }

      function httpOverHttps(options) {
        var agent = new TunnelingAgent(options);
        agent.request = https.request;
        return agent;
      }

      function httpsOverHttps(options) {
        var agent = new TunnelingAgent(options);
        agent.request = https.request;
        agent.createSocket = createSecureSocket;
        agent.defaultPort = 443;
        return agent;
      }

      function TunnelingAgent(options) {
        var self = this;
        self.options = options || {};
        self.proxyOptions = self.options.proxy || {};
        self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
        self.requests = [];
        self.sockets = [];

        self.on("free", function onFree(socket, host, port, localAddress) {
          var options = toOptions(host, port, localAddress);
          for (var i = 0, len = self.requests.length; i < len; ++i) {
            var pending = self.requests[i];
            if (pending.host === options.host && pending.port === options.port) {
              // Detect the request to connect same origin server,
              // reuse the connection.
              self.requests.splice(i, 1);
              pending.request.onSocket(socket);
              return;
            }
          }
          socket.destroy();
          self.removeSocket(socket);
        });
      }
      util.inherits(TunnelingAgent, events.EventEmitter);

      TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
        var self = this;
        var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));

        if (self.sockets.length >= this.maxSockets) {
          // We are over limit so we'll add it to the queue.
          self.requests.push(options);
          return;
        }

        // If we are under maxSockets create a new one.
        self.createSocket(options, function (socket) {
          socket.on("free", onFree);
          socket.on("close", onCloseOrRemove);
          socket.on("agentRemove", onCloseOrRemove);
          req.onSocket(socket);

          function onFree() {
            self.emit("free", socket, options);
          }

          function onCloseOrRemove(err) {
            self.removeSocket(socket);
            socket.removeListener("free", onFree);
            socket.removeListener("close", onCloseOrRemove);
            socket.removeListener("agentRemove", onCloseOrRemove);
          }
        });
      };

      TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
        var self = this;
        var placeholder = {};
        self.sockets.push(placeholder);

        var connectOptions = mergeOptions({}, self.proxyOptions, {
          method: "CONNECT",
          path: options.host + ":" + options.port,
          agent: false,
          headers: {
            host: options.host + ":" + options.port
          }
        });
        if (options.localAddress) {
          connectOptions.localAddress = options.localAddress;
        }
        if (connectOptions.proxyAuth) {
          connectOptions.headers = connectOptions.headers || {};
          connectOptions.headers["Proxy-Authorization"] =
            "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
        }

        debug("making CONNECT request");
        var connectReq = self.request(connectOptions);
        connectReq.useChunkedEncodingByDefault = false; // for v0.6
        connectReq.once("response", onResponse); // for v0.6
        connectReq.once("upgrade", onUpgrade); // for v0.6
        connectReq.once("connect", onConnect); // for v0.7 or later
        connectReq.once("error", onError);
        connectReq.end();

        function onResponse(res) {
          // Very hacky. This is necessary to avoid http-parser leaks.
          res.upgrade = true;
        }

        function onUpgrade(res, socket, head) {
          // Hacky.
          process.nextTick(function () {
            onConnect(res, socket, head);
          });
        }

        function onConnect(res, socket, head) {
          connectReq.removeAllListeners();
          socket.removeAllListeners();

          if (res.statusCode !== 200) {
            debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
            socket.destroy();
            var error = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
            error.code = "ECONNRESET";
            options.request.emit("error", error);
            self.removeSocket(placeholder);
            return;
          }
          if (head.length > 0) {
            debug("got illegal response body from proxy");
            socket.destroy();
            var error = new Error("got illegal response body from proxy");
            error.code = "ECONNRESET";
            options.request.emit("error", error);
            self.removeSocket(placeholder);
            return;
          }
          debug("tunneling connection has established");
          self.sockets[self.sockets.indexOf(placeholder)] = socket;
          return cb(socket);
        }

        function onError(cause) {
          connectReq.removeAllListeners();

          debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
          var error = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self.removeSocket(placeholder);
        }
      };

      TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
        var pos = this.sockets.indexOf(socket);
        if (pos === -1) {
          return;
        }
        this.sockets.splice(pos, 1);

        var pending = this.requests.shift();
        if (pending) {
          // If we have pending requests and a socket gets closed a new one
          // needs to be created to take over in the pool for the one that closed.
          this.createSocket(pending, function (socket) {
            pending.request.onSocket(socket);
          });
        }
      };

      function createSecureSocket(options, cb) {
        var self = this;
        TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {
          var hostHeader = options.request.getHeader("host");
          var tlsOptions = mergeOptions({}, self.options, {
            socket: socket,
            servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
          });

          // 0 is dummy port for v0.6
          var secureSocket = tls.connect(0, tlsOptions);
          self.sockets[self.sockets.indexOf(socket)] = secureSocket;
          cb(secureSocket);
        });
      }

      function toOptions(host, port, localAddress) {
        if (typeof host === "string") {
          // since v0.10
          return {
            host: host,
            port: port,
            localAddress: localAddress
          };
        }
        return host; // for v0.11 or later
      }

      function mergeOptions(target) {
        for (var i = 1, len = arguments.length; i < len; ++i) {
          var overrides = arguments[i];
          if (typeof overrides === "object") {
            var keys = Object.keys(overrides);
            for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
              var k = keys[j];
              if (overrides[k] !== undefined) {
                target[k] = overrides[k];
              }
            }
          }
        }
        return target;
      }

      var debug;
      if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
        debug = function () {
          var args = Array.prototype.slice.call(arguments);
          if (typeof args[0] === "string") {
            args[0] = "TUNNEL: " + args[0];
          } else {
            args.unshift("TUNNEL:");
          }
          console.error.apply(console, args);
        };
      } else {
        debug = function () {};
      }
      exports.debug = debug; // for test

      /***/
    },

    /***/ 1441: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var extend = __nccwpck_require__(7512);
      var regexCache = {};
      var all;

      var charSets = {
        default: {
          "&quot;": '"',
          "&#34;": '"',

          "&apos;": "'",
          "&#39;": "'",

          "&amp;": "&",
          "&#38;": "&",

          "&gt;": ">",
          "&#62;": ">",

          "&lt;": "<",
          "&#60;": "<"
        },
        extras: {
          "&cent;": "",
          "&#162;": "",

          "&copy;": "",
          "&#169;": "",

          "&euro;": "",
          "&#8364;": "",

          "&pound;": "",
          "&#163;": "",

          "&reg;": "",
          "&#174;": "",

          "&yen;": "",
          "&#165;": ""
        }
      };

      // don't merge char sets unless "all" is explicitly called
      Object.defineProperty(charSets, "all", {
        get: function () {
          return all || (all = extend({}, charSets.default, charSets.extras));
        }
      });

      /**
       * Convert HTML entities to HTML characters.
       *
       * @param  {String} `str` String with HTML entities to un-escape.
       * @return {String}
       */

      function unescape(str, type) {
        if (!isString(str)) return "";
        var chars = charSets[type || "default"];
        var regex = toRegex(type, chars);
        return str.replace(regex, function (m) {
          return chars[m];
        });
      }

      function toRegex(type, chars) {
        if (regexCache[type]) {
          return regexCache[type];
        }
        var keys = Object.keys(chars).join("|");
        var regex = new RegExp("(?=(" + keys + "))\\1", "g");
        regexCache[type] = regex;
        return regex;
      }

      /**
       * Returns true if str is a non-empty string
       */

      function isString(str) {
        return str && typeof str === "string";
      }

      /**
       * Expose charSets
       */

      unescape.chars = charSets.default;
      unescape.extras = charSets.extras;
      // don't trip the "charSets" getter unless it's explicitly called
      Object.defineProperty(unescape, "all", {
        get: function () {
          return charSets.all;
        }
      });

      /**
       * Expose `unescape`
       */

      module.exports = unescape;

      /***/
    },

    /***/ 8593: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var debug = __nccwpck_require__(1607)("urllib:detect_proxy_agent");
      var getProxyFromURI = __nccwpck_require__(6183);

      var proxyAgents = {};

      function detectProxyAgent(uri, args) {
        if (!args.enableProxy && !process.env.URLLIB_ENABLE_PROXY) {
          return null;
        }
        var proxy = args.proxy || process.env.URLLIB_PROXY;
        if (!proxy) {
          proxy = getProxyFromURI(uri);
          if (!proxy) {
            return null;
          }
        }

        var proxyAgent = proxyAgents[proxy];
        if (!proxyAgent) {
          debug("create new proxy %s", proxy);
          // lazy require, only support node >= 4
          proxyAgent = proxyAgents[proxy] = new (__nccwpck_require__(9352))(proxy);
        }
        debug("get proxy: %s", proxy);
        return proxyAgent;
      }

      module.exports = detectProxyAgent;
      module.exports.proxyAgents = proxyAgents;

      /***/
    },

    /***/ 6183: /***/ (module) => {
      "use strict";
      // copy from https://github.com/request/request/blob/90cf8c743bb9fd6a4cb683a56fb7844c6b316866/lib/getProxyFromURI.js

      function formatHostname(hostname) {
        // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
        return hostname.replace(/^\.*/, ".").toLowerCase();
      }

      function parseNoProxyZone(zone) {
        zone = zone.trim().toLowerCase();

        var zoneParts = zone.split(":", 2),
          zoneHost = formatHostname(zoneParts[0]),
          zonePort = zoneParts[1],
          hasPort = zone.indexOf(":") > -1;

        return { hostname: zoneHost, port: zonePort, hasPort: hasPort };
      }

      function uriInNoProxy(uri, noProxy) {
        var port = uri.port || (uri.protocol === "https:" ? "443" : "80"),
          hostname = formatHostname(uri.hostname),
          noProxyList = noProxy.split(",");

        // iterate through the noProxyList until it finds a match.
        return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {
          var isMatchedAt = hostname.indexOf(noProxyZone.hostname),
            hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;

          if (noProxyZone.hasPort) {
            return port === noProxyZone.port && hostnameMatched;
          }

          return hostnameMatched;
        });
      }

      function getProxyFromURI(uri) {
        // Decide the proper request proxy to use based on the request URI object and the
        // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
        // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)

        var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";

        // if the noProxy is a wildcard then return null

        if (noProxy === "*") {
          return null;
        }

        // if the noProxy is not empty and the uri is found return null

        if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
          return null;
        }

        // Check for HTTP or HTTPS Proxy in environment Else default to null

        if (uri.protocol === "http:") {
          return process.env.HTTP_PROXY || process.env.http_proxy || null;
        }

        if (uri.protocol === "https:") {
          return (
            process.env.HTTPS_PROXY ||
            process.env.https_proxy ||
            process.env.HTTP_PROXY ||
            process.env.http_proxy ||
            null
          );
        }

        // if none of that works, return null
        // (What uri protocol are you using then?)

        return null;
      }

      module.exports = getProxyFromURI;

      /***/
    },

    /***/ 6509: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var EventEmitter = __nccwpck_require__(2361).EventEmitter;
      var util = __nccwpck_require__(3837);
      var utility = __nccwpck_require__(3877);
      var urllib = __nccwpck_require__(516);

      module.exports = HttpClient;

      function HttpClient(options) {
        EventEmitter.call(this);
        options = options || {};

        if (options.agent !== undefined) {
          this.agent = options.agent;
          this.hasCustomAgent = true;
        } else {
          this.agent = urllib.agent;
          this.hasCustomAgent = false;
        }

        if (options.httpsAgent !== undefined) {
          this.httpsAgent = options.httpsAgent;
          this.hasCustomHttpsAgent = true;
        } else {
          this.httpsAgent = urllib.httpsAgent;
          this.hasCustomHttpsAgent = false;
        }
        this.defaultArgs = options.defaultArgs;
      }
      util.inherits(HttpClient, EventEmitter);

      HttpClient.prototype.request = HttpClient.prototype.curl = function (url, args, callback) {
        if (typeof args === "function") {
          callback = args;
          args = null;
        }
        args = args || {};
        if (this.defaultArgs) {
          args = utility.assign({}, [this.defaultArgs, args]);
        }
        args.emitter = this;
        args.agent = getAgent(args.agent, this.agent);
        args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);
        return urllib.request(url, args, callback);
      };

      HttpClient.prototype.requestThunk = function (url, args) {
        args = args || {};
        if (this.defaultArgs) {
          args = utility.assign({}, [this.defaultArgs, args]);
        }
        args.emitter = this;
        args.agent = getAgent(args.agent, this.agent);
        args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);
        return urllib.requestThunk(url, args);
      };

      function getAgent(agent, defaultAgent) {
        return agent === undefined ? defaultAgent : agent;
      }

      /***/
    },

    /***/ 7399: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var util = __nccwpck_require__(3837);
      var debug = __nccwpck_require__(1607)("urllib");
      var ms = __nccwpck_require__(845);
      var HttpClient = __nccwpck_require__(6509);

      var _Promise;

      module.exports = HttpClient2;

      function HttpClient2(options) {
        HttpClient.call(this, options);
      }

      util.inherits(HttpClient2, HttpClient);

      HttpClient2.prototype.request = HttpClient2.prototype.curl = function request(url, args) {
        var self = this;
        args = args || {};
        args.retry = args.retry || 0;
        if (args.retryDelay) {
          args.retryDelay = ms(args.retryDelay);
        }
        args.isRetry =
          args.isRetry ||
          function (res) {
            return res.status >= 500;
          };
        return HttpClient.prototype.request
          .call(self, url, args)
          .then(function (res) {
            if (args.retry > 0 && typeof args.isRetry === "function" && args.isRetry(res)) {
              args.retry--;
              debug("retry request %s, remain %s", url, args.retry);
              if (args.retryDelay) {
                debug("retry after %sms", args.retryDelay);
                return sleep(args.retryDelay).then(function () {
                  return self.request(url, args);
                });
              }
              return self.request(url, args);
            }
            return res;
          })
          .catch(function (err) {
            if (args.retry > 0) {
              args.retry--;
              debug("retry request %s, remain %s, err %s", url, args.retry, err);
              if (args.retryDelay) {
                debug("retry after %sms", args.retryDelay);
                return sleep(args.retryDelay).then(function () {
                  return self.request(url, args);
                });
              }
              return self.request(url, args);
            }
            throw err;
          });
      };

      HttpClient2.prototype.requestThunk = function requestThunk(url, args) {
        var self = this;
        return function (callback) {
          self
            .request(url, args)
            .then(function (res) {
              var cb = callback;
              // make sure cb(null, res) throw error won't emit catch callback below
              callback = null;
              cb(null, res);
            })
            .catch(function (err) {
              if (!callback) {
                // TODO: how to handle this error?
                return;
              }
              callback(err);
            });
        };
      };

      function sleep(ms) {
        if (!_Promise) {
          _Promise = __nccwpck_require__(5768);
        }

        return new _Promise(function (resolve) {
          setTimeout(resolve, ms);
        });
      }

      /***/
    },

    /***/ 4783: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var urllib = __nccwpck_require__(516);

      exports.USER_AGENT = urllib.USER_AGENT;
      exports.TIMEOUT = urllib.TIMEOUT;
      exports.TIMEOUTS = urllib.TIMEOUTS;
      exports.agent = urllib.agent;
      exports.httpsAgent = urllib.httpsAgent;

      exports.curl = urllib.curl;
      exports.request = urllib.request;
      exports.requestWithCallback = urllib.requestWithCallback;
      exports.requestThunk = urllib.requestThunk;

      exports.HttpClient = __nccwpck_require__(6509);
      exports.HttpClient2 = __nccwpck_require__(7399);

      exports.create = function (options) {
        return new exports.HttpClient(options);
      };

      /***/
    },

    /***/ 516: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var debug = __nccwpck_require__(1607)("urllib");
      var path = __nccwpck_require__(1017);
      var dns = __nccwpck_require__(9523);
      var http = __nccwpck_require__(3685);
      var https = __nccwpck_require__(5687);
      var urlutil = __nccwpck_require__(7310);
      var URL = urlutil.URL;
      var util = __nccwpck_require__(3837);
      var qs = __nccwpck_require__(2760);
      var ip = __nccwpck_require__(7547);
      var querystring = __nccwpck_require__(3477);
      var zlib = __nccwpck_require__(9796);
      var ua = __nccwpck_require__(6834);
      var digestAuthHeader = __nccwpck_require__(7774);
      var ms = __nccwpck_require__(845);
      var statuses = __nccwpck_require__(7415);
      var contentTypeParser = __nccwpck_require__(9915);
      var first = __nccwpck_require__(4401);
      var pump = __nccwpck_require__(8341);
      var utility = __nccwpck_require__(3877);
      var FormStream = __nccwpck_require__(5454);
      var detectProxyAgent = __nccwpck_require__(8593);

      var _Promise;
      var _iconv;

      var pkg = __nccwpck_require__(7164);

      var USER_AGENT = (exports.USER_AGENT = ua("node-urllib", pkg.version));
      var NODE_MAJOR_VERSION = parseInt(process.versions.node.split(".")[0]);

      // change Agent.maxSockets to 1000
      exports.agent = new http.Agent();
      exports.agent.maxSockets = 1000;

      exports.httpsAgent = new https.Agent();
      exports.httpsAgent.maxSockets = 1000;

      var LONG_STACK_DELIMITER = "\n    --------------------\n";

      /**
       * The default request timeout(in milliseconds).
       * @type {Number}
       * @const
       */

      exports.TIMEOUT = ms("5s");
      exports.TIMEOUTS = [ms("5s"), ms("5s")];

      var REQUEST_ID = 0;
      var MAX_VALUE = Math.pow(2, 31) - 10;
      var isNode010 = /^v0\.10\.\d+$/.test(process.version);
      var isNode012 = /^v0\.12\.\d+$/.test(process.version);

      /**
       * support data types
       * will auto decode response body
       * @type {Array}
       */
      var TEXT_DATA_TYPES = ["json", "text"];

      var PROTO_RE = /^https?:\/\//i;

      // Keep-Alive: timeout=5, max=100
      var KEEP_ALIVE_RE = /^timeout=(\d+)/i;

      var SOCKET_REQUEST_COUNT = "_URLLIB_SOCKET_REQUEST_COUNT";
      var SOCKET_RESPONSE_COUNT = "_URLLIB_SOCKET_RESPONSE_COUNT";

      /**
       * Handle all http request, both http and https support well.
       *
       * @example
       *
       * ```js
       * // GET https://nodejs.org
       * urllib.request('https://nodejs.org', function(err, data, res) {});
       * // POST https://nodejs.org
       * var args = { type: 'post', data: { foo: 'bar' } };
       * urllib.request('https://nodejs.org', args, function(err, data, res) {});
       * ```
       *
       * @param {String|Object} url: the request full URL.
       * @param {Object} [args]: optional
       *   - {Object} [data]: request data, will auto be query stringify.
       *   - {Boolean} [dataAsQueryString]: force convert `data` to query string.
       *   - {String|Buffer} [content]: optional, if set content, `data` will ignore.
       *   - {ReadStream} [stream]: read stream to sent.
       *   - {WriteStream} [writeStream]: writable stream to save response data.
       *       If you use this, callback's data should be null.
       *       We will just `pipe(ws, {end: true})`.
       *   - {consumeWriteStream} [true]: consume the writeStream, invoke the callback after writeStream close.
       *   - {Array<ReadStream|Buffer|String>|Object|ReadStream|Buffer|String} [files]: optional,
       *       The files will send with `multipart/form-data` format, base on `formstream`.
       *       If `method` not set, will use `POST` method by default.
       *   - {String} [method]: optional, could be GET | POST | DELETE | PUT, default is GET
       *   - {String} [contentType]: optional, request data type, could be `json`, default is undefined
       *   - {String} [dataType]: optional, response data type, could be `text` or `json`, default is buffer
       *   - {Boolean|Function} [fixJSONCtlChars]: optional, fix the control characters (U+0000 through U+001F)
       *       before JSON parse response. Default is `false`.
       *       `fixJSONCtlChars` can be a function, will pass data to the first argument. e.g.: `data = fixJSONCtlChars(data)`
       *   - {Object} [headers]: optional, request headers
       *   - {Boolean} [keepHeaderCase]: optional, by default will convert header keys to lowercase
       *   - {Number|Array} [timeout]: request timeout(in milliseconds), default is `exports.TIMEOUTS containing connect timeout and response timeout`
       *   - {Agent} [agent]: optional, http agent. Set `false` if you does not use agent.
       *   - {Agent} [httpsAgent]: optional, https agent. Set `false` if you does not use agent.
       *   - {String} [auth]: Basic authentication i.e. 'user:password' to compute an Authorization header.
       *   - {String} [digestAuth]: Digest authentication i.e. 'user:password' to compute an Authorization header.
       *   - {String|Buffer|Array} [ca]: An array of strings or Buffers of trusted certificates.
       *       If this is omitted several well known "root" CAs will be used, like VeriSign.
       *       These are used to authorize connections.
       *       Notes: This is necessary only if the server uses the self-signed certificate
       *   - {Boolean} [rejectUnauthorized]: If true, the server certificate is verified against the list of supplied CAs.
       *       An 'error' event is emitted if verification fails. Default: true.
       *   - {String|Buffer} [pfx]: A string or Buffer containing the private key,
       *       certificate and CA certs of the server in PFX or PKCS12 format.
       *   - {String|Buffer} [key]: A string or Buffer containing the private key of the client in PEM format.
       *       Notes: This is necessary only if using the client certificate authentication
       *   - {String|Buffer} [cert]: A string or Buffer containing the certificate key of the client in PEM format.
       *       Notes: This is necessary only if using the client certificate authentication
       *   - {String} [passphrase]: A string of passphrase for the private key or pfx.
       *   - {String} [ciphers]: A string describing the ciphers to use or exclude.
       *   - {String} [secureProtocol]: The SSL method to use, e.g. SSLv3_method to force SSL version 3.
       *       The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.
       *   - {Boolean} [followRedirect]: Follow HTTP 3xx responses as redirects. defaults to false.
       *   - {Number} [maxRedirects]: The maximum number of redirects to follow, defaults to 10.
       *   - {Function(from, to)} [formatRedirectUrl]: Format the redirect url by your self. Default is `url.resolve(from, to)`
       *   - {Function(options)} [beforeRequest]: Before request hook, you can change every thing here.
       *   - {Boolean} [streaming]: let you get the res object when request connected, default is `false`. alias `customResponse`
       *   - {Boolean} [gzip]: Accept gzip response content and auto decode it, default is `false`.
       *   - {Boolean} [timing]: Enable timing or not, default is `false`.
       *   - {Function} [lookup]: Custom DNS lookup function, default is `dns.lookup`.
       *       Require node >= 4.0.0 and only work on `http` protocol.
       *   - {Boolean} [enableProxy]: optional, enable proxy request. Default is `false`.
       *   - {String|Object} [proxy]: optional proxy agent uri or options. Default is `null`.
       *   - {String} [socketPath]: optional, unix domain socket file path.
       *   - {Function} checkAddress: optional, check request address to protect from SSRF and similar attacks.
       * @param {Function} [callback]: callback(error, data, res). If missing callback, will return a promise object.
       * @return {HttpRequest} req object.
       * @api public
       */
      exports.request = function request(url, args, callback) {
        // request(url, callback)
        if (arguments.length === 2 && typeof args === "function") {
          callback = args;
          args = null;
        }
        if (typeof callback === "function") {
          return exports.requestWithCallback(url, args, callback);
        }

        // Promise
        if (!_Promise) {
          _Promise = __nccwpck_require__(5768);
        }
        return new _Promise(function (resolve, reject) {
          exports.requestWithCallback(url, args, makeCallback(resolve, reject));
        });
      };

      // alias to curl
      exports.curl = exports.request;

      function makeCallback(resolve, reject) {
        return function (err, data, res) {
          if (err) {
            return reject(err);
          }
          resolve({
            data: data,
            status: res.statusCode,
            headers: res.headers,
            res: res
          });
        };
      }

      // yield urllib.requestThunk(url, args)
      exports.requestThunk = function requestThunk(url, args) {
        return function (callback) {
          exports.requestWithCallback(url, args, function (err, data, res) {
            if (err) {
              return callback(err);
            }
            callback(null, {
              data: data,
              status: res.statusCode,
              headers: res.headers,
              res: res
            });
          });
        };
      };

      function requestWithCallback(url, args, callback) {
        var req;
        // requestWithCallback(url, callback)
        if (!url || (typeof url !== "string" && typeof url !== "object")) {
          var msg = util.format("expect request url to be a string or a http request options, but got %j", url);
          throw new Error(msg);
        }

        if (arguments.length === 2 && typeof args === "function") {
          callback = args;
          args = null;
        }

        args = args || {};
        if (REQUEST_ID >= MAX_VALUE) {
          REQUEST_ID = 0;
        }
        var reqId = ++REQUEST_ID;

        args.requestUrls = args.requestUrls || [];

        args.timeout = args.timeout || exports.TIMEOUTS;
        args.maxRedirects = args.maxRedirects || 10;
        args.streaming = args.streaming || args.customResponse;
        var requestStartTime = Date.now();
        var parsedUrl;

        if (typeof url === "string") {
          if (!PROTO_RE.test(url)) {
            // Support `request('www.server.com')`
            url = "http://" + url;
          }
          if (URL) {
            parsedUrl = urlutil.parse(new URL(url).href);
          } else {
            parsedUrl = urlutil.parse(url);
          }
        } else {
          parsedUrl = url;
        }

        var reqMeta = {
          requestId: reqId,
          url: parsedUrl.href,
          args: args,
          ctx: args.ctx
        };
        if (args.emitter) {
          args.emitter.emit("request", reqMeta);
        }

        var method = (args.type || args.method || parsedUrl.method || "GET").toUpperCase();
        var port = parsedUrl.port || 80;
        var httplib = http;
        var agent = getAgent(args.agent, exports.agent);
        var fixJSONCtlChars = args.fixJSONCtlChars;

        if (parsedUrl.protocol === "https:") {
          httplib = https;
          agent = getAgent(args.httpsAgent, exports.httpsAgent);

          if (!parsedUrl.port) {
            port = 443;
          }
        }

        // request through proxy tunnel
        var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);
        if (proxyTunnelAgent) {
          agent = proxyTunnelAgent;
        }

        var lookup = args.lookup;
        // check address to protect from SSRF and similar attacks
        if (args.checkAddress) {
          var _lookup = lookup || dns.lookup;
          lookup = function (host, dnsopts, callback) {
            _lookup(host, dnsopts, function emitLookup(err, ip, family) {
              // add check address logic in custom dns lookup
              if (!err && !args.checkAddress(ip, family)) {
                err = new Error("illegal address");
                err.name = "IllegalAddressError";
                err.hostname = host;
                err.ip = ip;
                err.family = family;
              }
              callback(err, ip, family);
            });
          };
        }

        var requestSize = 0;
        var options = {
          host: parsedUrl.hostname || parsedUrl.host || "localhost",
          path: parsedUrl.path || "/",
          method: method,
          port: port,
          agent: agent,
          headers: {},
          // default is dns.lookup
          // https://github.com/nodejs/node/blob/master/lib/net.js#L986
          // custom dnslookup require node >= 4.0.0 (for http), node >=8 (for https)
          // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
          lookup: lookup
        };

        var originHeaderKeys = {};
        if (args.headers) {
          // only allow enumerable and ownProperty value of args.headers
          var names = utility.getOwnEnumerables(args.headers, true);
          for (var i = 0; i < names.length; i++) {
            var name = names[i];
            var key = name.toLowerCase();
            if (key !== name) {
              originHeaderKeys[key] = name;
            }
            options.headers[key] = args.headers[name];
          }
        }
        if (args.socketPath) {
          options.socketPath = args.socketPath;
        }

        var sslNames = [
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "rejectUnauthorized",
          "secureProtocol",
          "secureOptions"
        ];
        for (var i = 0; i < sslNames.length; i++) {
          var name = sslNames[i];
          if (args.hasOwnProperty(name)) {
            options[name] = args[name];
          }
        }

        // fix rejectUnauthorized when major version < 12
        if (NODE_MAJOR_VERSION < 12) {
          if (options.rejectUnauthorized === false && !options.hasOwnProperty("secureOptions")) {
            options.secureOptions = __nccwpck_require__(2057).SSL_OP_NO_TLSv1_2;
          }
        }

        var auth = args.auth || parsedUrl.auth;
        if (auth) {
          options.auth = auth;
        }

        var body = null;
        var dataAsQueryString = false;

        if (args.files) {
          if (!options.method || options.method === "GET" || options.method === "HEAD") {
            options.method = "POST";
          }
          var files = args.files;
          var uploadFiles = [];
          if (Array.isArray(files)) {
            for (var i = 0; i < files.length; i++) {
              var field = "file" + (i === 0 ? "" : i);
              uploadFiles.push([field, files[i]]);
            }
          } else {
            if (Buffer.isBuffer(files) || typeof files.pipe === "function" || typeof files === "string") {
              uploadFiles.push(["file", files]);
            } else if (typeof files === "object") {
              for (var field in files) {
                uploadFiles.push([field, files[field]]);
              }
            }
          }
          var form = new FormStream();
          // set normal fields first
          if (args.data) {
            for (var fieldName in args.data) {
              form.field(fieldName, args.data[fieldName]);
            }
          }

          for (var i = 0; i < uploadFiles.length; i++) {
            var item = uploadFiles[i];
            if (Buffer.isBuffer(item[1])) {
              form.buffer(item[0], item[1], "bufferfile" + i);
            } else if (typeof item[1].pipe === "function") {
              var filename = item[1].path || "streamfile" + i;
              filename = path.basename(filename);
              form.stream(item[0], item[1], filename);
            } else {
              form.file(item[0], item[1]);
            }
          }

          var formHeaders = form.headers();
          var formHeaderNames = utility.getOwnEnumerables(formHeaders, true);
          for (var i = 0; i < formHeaderNames.length; i++) {
            var name = formHeaderNames[i];
            options.headers[name.toLowerCase()] = formHeaders[name];
          }
          debug("set multipart headers: %j, method: %s", formHeaders, options.method);
          args.stream = form;
        } else {
          body = args.content || args.data;
          dataAsQueryString = method === "GET" || method === "HEAD" || args.dataAsQueryString;
          if (!args.content) {
            if (body && !(typeof body === "string" || Buffer.isBuffer(body))) {
              if (dataAsQueryString) {
                // read: GET, HEAD, use query string
                body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
              } else {
                var contentType = options.headers["content-type"];
                // auto add application/x-www-form-urlencoded when using urlencode form request
                if (!contentType) {
                  if (args.contentType === "json") {
                    contentType = "application/json";
                  } else {
                    contentType = "application/x-www-form-urlencoded";
                  }
                  options.headers["content-type"] = contentType;
                }

                if (parseContentType(contentType).type === "application/json") {
                  body = JSON.stringify(body);
                } else {
                  // 'application/x-www-form-urlencoded'
                  body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);
                }
              }
            }
          }
        }

        if (body) {
          // if it's a GET or HEAD request, data should be sent as query string
          if (dataAsQueryString) {
            options.path += (parsedUrl.query ? "&" : "?") + body;
            body = null;
          }

          if (body) {
            var length = body.length;
            if (!Buffer.isBuffer(body)) {
              length = Buffer.byteLength(body);
            }
            requestSize = length;

            options.headers["content-length"] = length.toString();
          }
        }

        if (args.dataType === "json") {
          if (!options.headers.accept) {
            options.headers.accept = "application/json";
          }
        }

        if (typeof args.beforeRequest === "function") {
          // you can use this hook to change every thing.
          args.beforeRequest(options);
        }

        var connectTimer = null;
        var responseTimer = null;
        var __err = null;
        var connected = false; // socket connected or not
        var keepAliveSocket = false; // request with keepalive socket
        var socketHandledRequests = 0; // socket already handled request count
        var socketHandledResponses = 0; // socket already handled response count
        var responseSize = 0;
        var statusCode = -1;
        var statusMessage = null;
        var responseAborted = false;
        var remoteAddress = "";
        var remotePort = "";
        var timing = null;
        if (args.timing) {
          timing = {
            // socket assigned
            queuing: 0,
            // dns lookup time
            dnslookup: 0,
            // socket connected
            connected: 0,
            // request sent
            requestSent: 0,
            // Time to first byte (TTFB)
            waiting: 0,
            contentDownload: 0
          };
        }

        function cancelConnectTimer() {
          if (connectTimer) {
            clearTimeout(connectTimer);
            connectTimer = null;
            debug("Request#%d connect timer canceled", reqId);
          }
        }
        function cancelResponseTimer() {
          if (responseTimer) {
            clearTimeout(responseTimer);
            responseTimer = null;
            debug("Request#%d response timer canceled", reqId);
          }
        }

        function done(err, data, res) {
          cancelConnectTimer();
          cancelResponseTimer();
          if (!callback) {
            console.warn(
              "[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!",
              Date(),
              reqId,
              process.pid,
              options.method,
              url
            );
            // https://github.com/node-modules/urllib/pull/30
            if (err) {
              console.warn(
                "[urllib:warn] [%s] [%s] [worker:%s] %s: %s\nstack: %s",
                Date(),
                reqId,
                process.pid,
                err.name,
                err.message,
                err.stack
              );
            }
            return;
          }

          var cb = callback;
          callback = null;
          var headers = {};
          if (res) {
            statusCode = res.statusCode;
            statusMessage = res.statusMessage;
            headers = res.headers;
          }

          if (handleDigestAuth(res, cb)) {
            return;
          }

          var response = createCallbackResponse(data, res);

          debug(
            "[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j, socketHandledRequests: %s, socketHandledResponses: %s",
            response.requestUseTime,
            responseSize,
            statusCode,
            options.method,
            options.host,
            options.path,
            keepAliveSocket,
            timing,
            socketHandledRequests,
            socketHandledResponses
          );

          if (err) {
            var agentStatus = "";
            if (agent && typeof agent.getCurrentStatus === "function") {
              // add current agent status to error message for logging and debug
              agentStatus = ", agent status: " + JSON.stringify(agent.getCurrentStatus());
            }
            err.message +=
              ", " +
              options.method +
              " " +
              url +
              " " +
              statusCode +
              " (connected: " +
              connected +
              ", keepalive socket: " +
              keepAliveSocket +
              agentStatus +
              ", socketHandledRequests: " +
              socketHandledRequests +
              ", socketHandledResponses: " +
              socketHandledResponses +
              ")" +
              "\nheaders: " +
              JSON.stringify(headers);
            err.data = data;
            err.path = options.path;
            err.status = statusCode;
            err.headers = headers;
            err.res = response;
            addLongStackTrace(err, req);
          }

          // only support agentkeepalive module for now
          // agentkeepalive@4: agent.options.freeSocketTimeout
          // agentkeepalive@3: agent.freeSocketKeepAliveTimeout
          var freeSocketTimeout =
            agent && ((agent.options && agent.options.freeSocketTimeout) || agent.freeSocketKeepAliveTimeout);
          if (
            agent &&
            agent.keepAlive &&
            freeSocketTimeout > 0 &&
            statusCode >= 200 &&
            headers.connection === "keep-alive" &&
            headers["keep-alive"]
          ) {
            // adjust freeSocketTimeout on the socket
            var m = KEEP_ALIVE_RE.exec(headers["keep-alive"]);
            if (m) {
              var seconds = parseInt(m[1]);
              if (seconds > 0) {
                // network delay 500ms
                var serverSocketTimeout = seconds * 1000 - 500;
                if (serverSocketTimeout < freeSocketTimeout) {
                  // https://github.com/node-modules/agentkeepalive/blob/master/lib/agent.js#L127
                  // agentkeepalive@4
                  var socket = res.socket || (req && req.socket);
                  if (agent.options && agent.options.freeSocketTimeout) {
                    socket.freeSocketTimeout = serverSocketTimeout;
                  } else {
                    socket.freeSocketKeepAliveTimeout = serverSocketTimeout;
                  }
                }
              }
            }
          }

          cb(err, data, args.streaming ? res : response);

          emitResponseEvent(err, response);
        }

        function createAndEmitResponseEvent(data, res) {
          var response = createCallbackResponse(data, res);
          emitResponseEvent(null, response);
        }

        function createCallbackResponse(data, res) {
          var requestUseTime = Date.now() - requestStartTime;
          if (timing) {
            timing.contentDownload = requestUseTime;
          }

          var headers = (res && res.headers) || {};
          var resStatusCode = (res && res.statusCode) || statusCode;
          var resStatusMessage = (res && res.statusMessage) || statusMessage;

          return {
            status: resStatusCode,
            statusCode: resStatusCode,
            statusMessage: resStatusMessage,
            headers: headers,
            size: responseSize,
            aborted: responseAborted,
            rt: requestUseTime,
            keepAliveSocket: keepAliveSocket,
            data: data,
            requestUrls: args.requestUrls,
            timing: timing,
            remoteAddress: remoteAddress,
            remotePort: remotePort,
            socketHandledRequests: socketHandledRequests,
            socketHandledResponses: socketHandledResponses
          };
        }

        function emitResponseEvent(err, response) {
          if (args.emitter) {
            // keep to use the same reqMeta object on request event before
            reqMeta.url = parsedUrl.href;
            reqMeta.socket = req && req.connection;
            reqMeta.options = options;
            reqMeta.size = requestSize;

            args.emitter.emit("response", {
              requestId: reqId,
              error: err,
              ctx: args.ctx,
              req: reqMeta,
              res: response
            });
          }
        }

        function handleDigestAuth(res, cb) {
          var headers = {};
          if (res && res.headers) {
            headers = res.headers;
          }
          // handle digest auth
          if (statusCode === 401 && headers["www-authenticate"] && !options.headers.authorization && args.digestAuth) {
            var authenticate = headers["www-authenticate"];
            if (authenticate.indexOf("Digest ") >= 0) {
              debug("Request#%d %s: got digest auth header WWW-Authenticate: %s", reqId, url, authenticate);
              options.headers.authorization = digestAuthHeader(
                options.method,
                options.path,
                authenticate,
                args.digestAuth
              );
              debug("Request#%d %s: auth with digest header: %s", reqId, url, options.headers.authorization);
              if (res.headers["set-cookie"]) {
                options.headers.cookie = res.headers["set-cookie"].join(";");
              }
              args.headers = options.headers;
              exports.requestWithCallback(url, args, cb);
              return true;
            }
          }
          return false;
        }

        function handleRedirect(res) {
          var err = null;
          if (args.followRedirect && statuses.redirect[res.statusCode]) {
            // handle redirect
            args._followRedirectCount = (args._followRedirectCount || 0) + 1;
            var location = res.headers.location;
            if (!location) {
              err = new Error("Got statusCode " + res.statusCode + " but cannot resolve next location from headers");
              err.name = "FollowRedirectError";
            } else if (args._followRedirectCount > args.maxRedirects) {
              err = new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + url);
              err.name = "MaxRedirectError";
            } else {
              var newUrl = args.formatRedirectUrl
                ? args.formatRedirectUrl(url, location)
                : urlutil.resolve(url, location);
              debug("Request#%d %s: `redirected` from %s to %s", reqId, options.path, url, newUrl);
              // make sure timer stop
              cancelResponseTimer();
              // should clean up headers.host on `location: http://other-domain/url`
              if (options.headers.host && PROTO_RE.test(location)) {
                options.headers.host = null;
                args.headers = options.headers;
              }
              // avoid done will be execute in the future change.
              var cb = callback;
              callback = null;
              exports.requestWithCallback(newUrl, args, cb);
              return {
                redirect: true,
                error: null
              };
            }
          }
          return {
            redirect: false,
            error: err
          };
        }

        // don't set user-agent
        if (args.headers && (args.headers["User-Agent"] === null || args.headers["user-agent"] === null)) {
          if (options.headers["user-agent"]) {
            delete options.headers["user-agent"];
          }
        } else {
          // need to set user-agent
          var hasAgentHeader = options.headers["user-agent"];
          if (!hasAgentHeader) {
            options.headers["user-agent"] = USER_AGENT;
          }
        }

        if (args.gzip) {
          var isAcceptEncodingNull =
            args.headers && (args.headers["Accept-Encoding"] === null || args.headers["accept-encoding"] === null);
          if (!isAcceptEncodingNull) {
            var hasAcceptEncodingHeader = options.headers["accept-encoding"];
            if (!hasAcceptEncodingHeader) {
              options.headers["accept-encoding"] = "gzip, deflate";
            }
          }
        }

        function decodeContent(res, body, cb) {
          if (responseAborted) {
            // err = new Error('Remote socket was terminated before `response.end()` was called');
            // err.name = 'RemoteSocketClosedError';
            debug("Request#%d %s: Remote socket was terminated before `response.end()` was called", reqId, url);
            var err = responseError || new Error("Remote socket was terminated before `response.end()` was called");
            return cb(err);
          }
          var encoding = res.headers["content-encoding"];
          if (body.length === 0 || !encoding) {
            return cb(null, body, encoding);
          }

          encoding = encoding.toLowerCase();
          switch (encoding) {
            case "gzip":
            case "deflate":
              debug("unzip %d length body", body.length);
              zlib.unzip(body, function (err, data) {
                if (err && err.name === "Error") {
                  err.name = "UnzipError";
                }
                cb(err, data);
              });
              break;
            default:
              cb(null, body, encoding);
          }
        }

        var writeStream = args.writeStream;
        var isWriteStreamClose = false;

        debug("Request#%d %s %s with headers %j, options.path: %s", reqId, method, url, options.headers, options.path);

        args.requestUrls.push(parsedUrl.href);

        var hasResponse = false;
        var responseError;
        function onResponse(res) {
          hasResponse = true;
          socketHandledResponses = res.socket[SOCKET_RESPONSE_COUNT] = (res.socket[SOCKET_RESPONSE_COUNT] || 0) + 1;
          if (timing) {
            timing.waiting = Date.now() - requestStartTime;
          }
          debug(
            "Request#%d %s `req response` event emit: status %d, headers: %j",
            reqId,
            url,
            res.statusCode,
            res.headers
          );

          if (args.streaming) {
            var result = handleRedirect(res);
            if (result.redirect) {
              res.resume();
              createAndEmitResponseEvent(null, res);
              return;
            }
            if (result.error) {
              res.resume();
              return done(result.error, null, res);
            }

            return done(null, null, res);
          }

          res.on("error", function (err) {
            responseError = err;
            debug(
              "Request#%d %s: `res error` event emit, total size %d, socket handled %s requests and %s responses",
              reqId,
              url,
              responseSize,
              socketHandledRequests,
              socketHandledResponses
            );
          });

          res.on("aborted", function () {
            responseAborted = true;
            debug("Request#%d %s: `res aborted` event emit, total size %d", reqId, url, responseSize);
          });

          if (writeStream) {
            // If there's a writable stream to recieve the response data, just pipe the
            // response stream to that writable stream and call the callback when it has
            // finished writing.
            //
            // NOTE that when the response stream `res` emits an 'end' event it just
            // means that it has finished piping data to another stream. In the
            // meanwhile that writable stream may still writing data to the disk until
            // it emits a 'close' event.
            //
            // That means that we should not apply callback until the 'close' of the
            // writable stream is emited.
            //
            // See also:
            // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb
            // - http://nodejs.org/api/stream.html#stream_event_end
            // - http://nodejs.org/api/stream.html#stream_event_close_1
            var result = handleRedirect(res);
            if (result.redirect) {
              res.resume();
              createAndEmitResponseEvent(null, res);
              return;
            }
            if (result.error) {
              res.resume();
              // end ths stream first
              writeStream.end();
              done(result.error, null, res);
              return;
            }

            // you can set consumeWriteStream false that only wait response end
            if (args.consumeWriteStream === false) {
              res.on("end", done.bind(null, null, null, res));
              pump(res, writeStream, function (err) {
                if (isWriteStreamClose) {
                  return;
                }
                isWriteStreamClose = true;
                debug("Request#%d %s: writeStream close, error: %s", reqId, url, err);
              });
              return;
            }

            // node 0.10, 0.12: only emit res aborted, writeStream close not fired
            if (isNode010 || isNode012) {
              first(
                [
                  [writeStream, "close"],
                  [res, "aborted"]
                ],
                function (_, stream, event) {
                  debug("Request#%d %s: writeStream or res %s event emitted", reqId, url, event);
                  done(__err || null, null, res);
                }
              );
              res.pipe(writeStream);
              return;
            }

            debug("Request#%d %s: pump res to writeStream", reqId, url);
            pump(res, writeStream, function (err) {
              debug(
                "Request#%d %s: writeStream close event emitted, error: %s, isWriteStreamClose: %s",
                reqId,
                url,
                err,
                isWriteStreamClose
              );
              if (isWriteStreamClose) {
                return;
              }
              isWriteStreamClose = true;
              done(__err || err, null, res);
            });
            return;
          }

          // Otherwise, just concat those buffers.
          //
          // NOTE that the `chunk` is not a String but a Buffer. It means that if
          // you simply concat two chunk with `+` you're actually converting both
          // Buffers into Strings before concating them. It'll cause problems when
          // dealing with multi-byte characters.
          //
          // The solution is to store each chunk in an array and concat them with
          // 'buffer-concat' when all chunks is recieved.
          //
          // See also:
          // http://cnodejs.org/topic/4faf65852e8fb5bc65113403

          var chunks = [];

          res.on("data", function (chunk) {
            debug("Request#%d %s: `res data` event emit, size %d", reqId, url, chunk.length);
            responseSize += chunk.length;
            chunks.push(chunk);
          });

          var isEmitted = false;
          function handleResponseCloseAndEnd(event) {
            debug(
              "Request#%d %s: `res %s` event emit, total size %d, socket handled %s requests and %s responses",
              reqId,
              url,
              event,
              responseSize,
              socketHandledRequests,
              socketHandledResponses
            );
            if (isEmitted) {
              return;
            }
            isEmitted = true;

            var body = Buffer.concat(chunks, responseSize);
            debug("Request#%d %s: _dumped: %s", reqId, url, res._dumped);

            if (__err) {
              // req.abort() after `res data` event emit.
              return done(__err, body, res);
            }

            var result = handleRedirect(res);
            if (result.error) {
              return done(result.error, body, res);
            }
            if (result.redirect) {
              createAndEmitResponseEvent(null, res);
              return;
            }

            decodeContent(res, body, function (err, data, encoding) {
              if (err) {
                return done(err, body, res);
              }
              // if body not decode, dont touch it
              if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
                // try to decode charset
                try {
                  data = decodeBodyByCharset(data, res);
                } catch (e) {
                  debug("decodeBodyByCharset error: %s", e);
                  // if error, dont touch it
                  return done(null, data, res);
                }

                if (args.dataType === "json") {
                  if (responseSize === 0) {
                    data = null;
                  } else {
                    var r = parseJSON(data, fixJSONCtlChars);
                    if (r.error) {
                      err = r.error;
                    } else {
                      data = r.data;
                    }
                  }
                }
              }

              done(err, data, res);
            });
          }

          // node >= 14 only emit close if req abort
          res.on("close", function () {
            handleResponseCloseAndEnd("close");
          });
          res.on("end", function () {
            handleResponseCloseAndEnd("end");
          });
        }

        var connectTimeout, responseTimeout;
        if (Array.isArray(args.timeout)) {
          connectTimeout = ms(args.timeout[0]);
          responseTimeout = ms(args.timeout[1]);
        } else {
          // set both timeout equal
          connectTimeout = responseTimeout = ms(args.timeout);
        }
        debug("ConnectTimeout: %d, ResponseTimeout: %d", connectTimeout, responseTimeout);

        function startConnectTimer() {
          debug("Connect timer ticking, timeout: %d", connectTimeout);
          connectTimer = setTimeout(function () {
            connectTimer = null;
            if (statusCode === -1) {
              statusCode = -2;
            }
            var msg = "Connect timeout for " + connectTimeout + "ms";
            var errorName = "ConnectionTimeoutError";
            if (!req.socket) {
              errorName = "SocketAssignTimeoutError";
              msg += ", working sockets is full";
            }
            __err = new Error(msg);
            __err.name = errorName;
            __err.requestId = reqId;
            debug("ConnectTimeout: Request#%d %s %s: %s, connected: %s", reqId, url, __err.name, msg, connected);
            abortRequest();
          }, connectTimeout);
        }

        function startResposneTimer() {
          debug("Response timer ticking, timeout: %d", responseTimeout);
          responseTimer = setTimeout(function () {
            responseTimer = null;
            var msg = "Response timeout for " + responseTimeout + "ms";
            var errorName = "ResponseTimeoutError";
            __err = new Error(msg);
            __err.name = errorName;
            __err.requestId = reqId;
            debug("ResponseTimeout: Request#%d %s %s: %s, connected: %s", reqId, url, __err.name, msg, connected);
            abortRequest();
          }, responseTimeout);
        }

        if (args.checkAddress) {
          var hostname = parsedUrl.hostname;
          // if request hostname is ip, custom lookup wont excute
          var family = null;
          if (ip.isV4Format(hostname)) {
            family = 4;
          } else if (ip.isV6Format(hostname)) {
            family = 6;
          }
          if (family) {
            if (!args.checkAddress(hostname, family)) {
              var err = new Error("illegal address");
              err.name = "IllegalAddressError";
              err.hostname = hostname;
              err.ip = hostname;
              err.family = family;
              return done(err);
            }
          }
        }

        // request headers checker will throw error
        try {
          var finalOptions = options;

          // restore origin header key
          if (args.keepHeaderCase) {
            var originKeys = Object.keys(originHeaderKeys);
            if (originKeys.length) {
              var finalHeaders = {};
              var names = utility.getOwnEnumerables(options.headers, true);
              for (var i = 0; i < names.length; i++) {
                var name = names[i];
                finalHeaders[originHeaderKeys[name] || name] = options.headers[name];
              }

              finalOptions = Object.assign({}, options);
              finalOptions.headers = finalHeaders;
            }
          }

          req = httplib.request(finalOptions, onResponse);
          if (args.trace) {
            req._callSite = {};
            Error.captureStackTrace(req._callSite, requestWithCallback);
          }
        } catch (err) {
          return done(err);
        }

        // environment detection: browser or nodejs
        if (typeof window === "undefined") {
          // start connect timer just after `request` return, and just in nodejs environment
          startConnectTimer();
        }

        var isRequestAborted = false;
        function abortRequest() {
          if (isRequestAborted) {
            return;
          }
          isRequestAborted = true;

          debug("Request#%d %s abort, connected: %s", reqId, url, connected);
          // it wont case error event when req haven't been assigned a socket yet.
          if (!req.socket) {
            __err.noSocket = true;
            done(__err);
          }
          req.abort();
        }

        if (timing) {
          // request sent
          req.on("finish", function () {
            timing.requestSent = Date.now() - requestStartTime;
          });
        }

        req.once("socket", function (socket) {
          if (timing) {
            // socket queuing time
            timing.queuing = Date.now() - requestStartTime;
          }

          // https://github.com/nodejs/node/blob/master/lib/net.js#L377
          // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352
          // should use socket.socket on 0.10.x
          if (isNode010 && socket.socket) {
            socket = socket.socket;
          }

          var orginalSocketTimeout = getSocketTimeout(socket);
          if (orginalSocketTimeout && orginalSocketTimeout < responseTimeout) {
            // make sure socket live longer than the response timer
            var socketTimeout = responseTimeout + 500;
            debug(
              "Request#%d socket.timeout(%s) < responseTimeout(%s), reset socket timeout to %s",
              reqId,
              orginalSocketTimeout,
              responseTimeout,
              socketTimeout
            );
            socket.setTimeout(socketTimeout);
          }

          socketHandledRequests = socket[SOCKET_REQUEST_COUNT] = (socket[SOCKET_REQUEST_COUNT] || 0) + 1;
          if (socket[SOCKET_RESPONSE_COUNT]) {
            socketHandledResponses = socket[SOCKET_RESPONSE_COUNT];
          }

          var readyState = socket.readyState;
          if (readyState === "opening") {
            socket.once("lookup", function (err, ip, addressType) {
              debug("Request#%d %s lookup: %s, %s, %s", reqId, url, err, ip, addressType);
              if (timing) {
                timing.dnslookup = Date.now() - requestStartTime;
              }
              if (ip) {
                remoteAddress = ip;
              }
            });
            socket.once("connect", function () {
              if (timing) {
                // socket connected
                timing.connected = Date.now() - requestStartTime;
              }

              // cancel socket timer at first and start tick for TTFB
              cancelConnectTimer();
              startResposneTimer();

              debug("Request#%d %s new socket connected", reqId, url);
              connected = true;
              if (!remoteAddress) {
                remoteAddress = socket.remoteAddress;
              }
              remotePort = socket.remotePort;
            });
            return;
          }

          debug("Request#%d %s reuse socket connected, readyState: %s", reqId, url, readyState);
          connected = true;
          keepAliveSocket = true;
          if (!remoteAddress) {
            remoteAddress = socket.remoteAddress;
          }
          remotePort = socket.remotePort;

          // reuse socket, timer should be canceled.
          cancelConnectTimer();
          startResposneTimer();
        });

        if (writeStream) {
          writeStream.once("error", function (err) {
            err.message += ' (writeStream "error")';
            __err = err;
            debug("Request#%d %s `writeStream error` event emit, %s: %s", reqId, url, err.name, err.message);
            abortRequest();
          });
        }

        var isRequestDone = false;
        function handleRequestError(err) {
          if (!err) {
            return;
          }
          // only ignore request error if response has been received
          // if response has not received, socket error will emit on req
          if (isRequestDone && hasResponse) {
            return;
          }
          isRequestDone = true;

          if (err.name === "Error") {
            err.name = connected ? "ResponseError" : "RequestError";
          }
          debug("Request#%d %s `req error` event emit, %s: %s", reqId, url, err.name, err.message);
          done(__err || err);
        }
        if (args.stream) {
          debug("Request#%d pump args.stream to req", reqId);
          pump(args.stream, req, handleRequestError);
        } else {
          req.end(body, function () {
            isRequestDone = true;
          });
        }
        // when stream already consumed, req's `finish` event is emitted and pump will ignore error after pipe finished
        // but if server response timeout later, we will abort the request and emit an error in req
        // so we must always manually listen to req's `error` event here to ensure this error is handled
        req.on("error", handleRequestError);
        req.requestId = reqId;
        return req;
      }

      exports.requestWithCallback = requestWithCallback;

      var JSONCtlCharsMap = {
        '"': '\\"', // \u0022
        "\\": "\\\\", // \u005c
        "\b": "\\b", // \u0008
        "\f": "\\f", // \u000c
        "\n": "\\n", // \u000a
        "\r": "\\r", // \u000d
        "\t": "\\t" // \u0009
      };
      var JSONCtlCharsRE = /[\u0000-\u001F\u005C]/g;

      function _replaceOneChar(c) {
        return JSONCtlCharsMap[c] || "\\u" + (c.charCodeAt(0) + 0x10000).toString(16).substr(1);
      }

      function replaceJSONCtlChars(str) {
        return str.replace(JSONCtlCharsRE, _replaceOneChar);
      }

      function parseJSON(data, fixJSONCtlChars) {
        var result = {
          error: null,
          data: null
        };
        if (fixJSONCtlChars) {
          if (typeof fixJSONCtlChars === "function") {
            data = fixJSONCtlChars(data);
          } else {
            // https://github.com/node-modules/urllib/pull/77
            // remote the control characters (U+0000 through U+001F)
            data = replaceJSONCtlChars(data);
          }
        }
        try {
          result.data = JSON.parse(data);
        } catch (err) {
          if (err.name === "SyntaxError") {
            err.name = "JSONResponseFormatError";
          }
          if (data.length > 1024) {
            // show 0~512 ... -512~end data
            err.message +=
              " (data json format: " +
              JSON.stringify(data.slice(0, 512)) +
              " ...skip... " +
              JSON.stringify(data.slice(data.length - 512)) +
              ")";
          } else {
            err.message += " (data json format: " + JSON.stringify(data) + ")";
          }
          result.error = err;
        }
        return result;
      }

      /**
       * decode response body by parse `content-type`'s charset
       * @param {Buffer} data
       * @param {Http(s)Response} res
       * @return {String}
       */
      function decodeBodyByCharset(data, res) {
        var type = res.headers["content-type"];
        if (!type) {
          return data.toString();
        }

        var type = parseContentType(type);
        var charset = type.parameters.charset || "utf-8";

        if (!Buffer.isEncoding(charset)) {
          if (!_iconv) {
            _iconv = __nccwpck_require__(9032);
          }
          return _iconv.decode(data, charset);
        }

        return data.toString(charset);
      }

      function getAgent(agent, defaultAgent) {
        return agent === undefined ? defaultAgent : agent;
      }

      function parseContentType(str) {
        try {
          return contentTypeParser.parse(str);
        } catch (err) {
          // ignore content-type error, tread as default
          return { parameters: {} };
        }
      }

      function addLongStackTrace(err, req) {
        if (!req) {
          return;
        }
        var callSiteStack = req._callSite && req._callSite.stack;
        if (!callSiteStack || typeof callSiteStack !== "string") {
          return;
        }
        if (err._longStack) {
          return;
        }
        var index = callSiteStack.indexOf("\n");
        if (index !== -1) {
          err._longStack = true;
          err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);
        }
      }

      // node 8 don't has timeout attribute on socket
      // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408
      function getSocketTimeout(socket) {
        return socket.timeout || socket._idleTimeout;
      }

      /***/
    },

    /***/ 3509: /***/ (module, exports, __nccwpck_require__) => {
      /**
       * This is the web browser implementation of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = __nccwpck_require__(5914);
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage =
        "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();

      /**
       * Colors.
       */

      exports.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];

      /**
       * Currently only WebKit-based Web Inspectors, Firefox >= v31,
       * and the Firebug extension (any Firefox version) are known
       * to support "%c" CSS customizations.
       *
       * TODO: add a `localStorage` variable to explicitly enable/disable colors
       */

      function useColors() {
        // NB: In an Electron preload script, document will be defined but not fully
        // initialized. Since we know we're in Chrome, we'll just detect this case
        // explicitly
        if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
          return true;
        }

        // is webkit? http://stackoverflow.com/a/16459606/376773
        // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
        return (
          (typeof document !== "undefined" &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          // is firebug? http://stackoverflow.com/a/398120/376773
          (typeof window !== "undefined" &&
            window.console &&
            (window.console.firebug || (window.console.exception && window.console.table))) ||
          // is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          // double check webkit in userAgent just in case we are in a worker
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        );
      }

      /**
       * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
       */

      exports.formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };

      /**
       * Colorize log arguments if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        var useColors = this.useColors;

        args[0] =
          (useColors ? "%c" : "") +
          this.namespace +
          (useColors ? " %c" : " ") +
          args[0] +
          (useColors ? "%c " : " ") +
          "+" +
          exports.humanize(this.diff);

        if (!useColors) return;

        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");

        // the final "%c" is somewhat tricky, because there could be other
        // arguments passed either before or after the %c, so we need to
        // figure out the correct index to insert the CSS into
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function (match) {
          if ("%%" === match) return;
          index++;
          if ("%c" === match) {
            // we only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
          }
        });

        args.splice(lastC, 0, c);
      }

      /**
       * Invokes `console.log()` when available.
       * No-op when `console.log` is not a "function".
       *
       * @api public
       */

      function log() {
        // this hackery is required for IE8/9, where
        // the `console.log` function doesn't have 'apply'
        return (
          "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments)
        );
      }

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */

      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem("debug");
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */

      function load() {
        var r;
        try {
          r = exports.storage.debug;
        } catch (e) {}

        // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }

        return r;
      }

      /**
       * Enable namespaces listed in `localStorage.debug` initially.
       */

      exports.enable(load());

      /**
       * Localstorage attempts to return the localstorage.
       *
       * This is necessary because safari throws
       * when a user disables cookies/localstorage
       * and you attempt to access it.
       *
       * @return {LocalStorage}
       * @api private
       */

      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }

      /***/
    },

    /***/ 5914: /***/ (module, exports, __nccwpck_require__) => {
      /**
       * This is the common logic for both the Node.js and web browser
       * implementations of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
      exports.coerce = coerce;
      exports.disable = disable;
      exports.enable = enable;
      exports.enabled = enabled;
      exports.humanize = __nccwpck_require__(5172);

      /**
       * The currently active debug mode names, and names to skip.
       */

      exports.names = [];
      exports.skips = [];

      /**
       * Map of special "%n" handling functions, for the debug "format" argument.
       *
       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
       */

      exports.formatters = {};

      /**
       * Previous log timestamp.
       */

      var prevTime;

      /**
       * Select a color.
       * @param {String} namespace
       * @return {Number}
       * @api private
       */

      function selectColor(namespace) {
        var hash = 0,
          i;

        for (i in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return exports.colors[Math.abs(hash) % exports.colors.length];
      }

      /**
       * Create a debugger with the given `namespace`.
       *
       * @param {String} namespace
       * @return {Function}
       * @api public
       */

      function createDebug(namespace) {
        function debug() {
          // disabled?
          if (!debug.enabled) return;

          var self = debug;

          // set `diff` timestamp
          var curr = +new Date();
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;

          // turn the `arguments` into a proper Array
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }

          args[0] = exports.coerce(args[0]);

          if ("string" !== typeof args[0]) {
            // anything else let's inspect with %O
            args.unshift("%O");
          }

          // apply any `formatters` transformations
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            // if we encounter an escaped % then don't increase the array index
            if (match === "%%") return match;
            index++;
            var formatter = exports.formatters[format];
            if ("function" === typeof formatter) {
              var val = args[index];
              match = formatter.call(self, val);

              // now we need to remove `args[index]` since it's inlined in the `format`
              args.splice(index, 1);
              index--;
            }
            return match;
          });

          // apply env-specific formatting (colors, etc.)
          exports.formatArgs.call(self, args);

          var logFn = debug.log || exports.log || console.log.bind(console);
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = exports.enabled(namespace);
        debug.useColors = exports.useColors();
        debug.color = selectColor(namespace);

        // env-specific initialization logic for debug instances
        if ("function" === typeof exports.init) {
          exports.init(debug);
        }

        return debug;
      }

      /**
       * Enables a debug mode by namespaces. This can include modes
       * separated by a colon and wildcards.
       *
       * @param {String} namespaces
       * @api public
       */

      function enable(namespaces) {
        exports.save(namespaces);

        exports.names = [];
        exports.skips = [];

        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;

        for (var i = 0; i < len; i++) {
          if (!split[i]) continue; // ignore empty strings
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }

      /**
       * Disable debug output.
       *
       * @api public
       */

      function disable() {
        exports.enable("");
      }

      /**
       * Returns true if the given mode name is enabled, false otherwise.
       *
       * @param {String} name
       * @return {Boolean}
       * @api public
       */

      function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Coerce `val`.
       *
       * @param {Mixed} val
       * @return {Mixed}
       * @api private
       */

      function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      }

      /***/
    },

    /***/ 1607: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      /**
       * Detect Electron renderer process, which is node, but we should
       * treat as a browser.
       */

      if (typeof process !== "undefined" && process.type === "renderer") {
        module.exports = __nccwpck_require__(3509);
      } else {
        module.exports = __nccwpck_require__(5505);
      }

      /***/
    },

    /***/ 5505: /***/ (module, exports, __nccwpck_require__) => {
      /**
       * Module dependencies.
       */

      var tty = __nccwpck_require__(6224);
      var util = __nccwpck_require__(3837);

      /**
       * This is the Node.js implementation of `debug()`.
       *
       * Expose `debug()` as the module.
       */

      exports = module.exports = __nccwpck_require__(5914);
      exports.init = init;
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;

      /**
       * Colors.
       */

      exports.colors = [6, 2, 3, 4, 5, 1];

      /**
       * Build up the default `inspectOpts` object from the environment variables.
       *
       *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
       */

      exports.inspectOpts = Object.keys(process.env)
        .filter(function (key) {
          return /^debug_/i.test(key);
        })
        .reduce(function (obj, key) {
          // camel-case
          var prop = key
            .substring(6)
            .toLowerCase()
            .replace(/_([a-z])/g, function (_, k) {
              return k.toUpperCase();
            });

          // coerce string value into JS value
          var val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
          else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
          else if (val === "null") val = null;
          else val = Number(val);

          obj[prop] = val;
          return obj;
        }, {});

      /**
       * The file descriptor to write the `debug()` calls to.
       * Set the `DEBUG_FD` env variable to override with another value. i.e.:
       *
       *   $ DEBUG_FD=3 node script.js 3>debug.log
       */

      var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

      if (1 !== fd && 2 !== fd) {
        util.deprecate(
          function () {},
          "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)"
        )();
      }

      var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

      /**
       * Is stdout a TTY? Colored output is enabled when `true`.
       */

      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
      }

      /**
       * Map %o to `util.inspect()`, all on a single line.
       */

      exports.formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util
          .inspect(v, this.inspectOpts)
          .split("\n")
          .map(function (str) {
            return str.trim();
          })
          .join(" ");
      };

      /**
       * Map %o to `util.inspect()`, allowing multiple lines if needed.
       */

      exports.formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };

      /**
       * Adds ANSI color escape codes if enabled.
       *
       * @api public
       */

      function formatArgs(args) {
        var name = this.namespace;
        var useColors = this.useColors;

        if (useColors) {
          var c = this.color;
          var prefix = "  \u001b[3" + c + ";1m" + name + " " + "\u001b[0m";

          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push("\u001b[3" + c + "m+" + exports.humanize(this.diff) + "\u001b[0m");
        } else {
          args[0] = new Date().toUTCString() + " " + name + " " + args[0];
        }
      }

      /**
       * Invokes `util.format()` with the specified arguments and writes to `stream`.
       */

      function log() {
        return stream.write(util.format.apply(util, arguments) + "\n");
      }

      /**
       * Save `namespaces`.
       *
       * @param {String} namespaces
       * @api private
       */

      function save(namespaces) {
        if (null == namespaces) {
          // If you set a process.env field to null or undefined, it gets cast to the
          // string 'null' or 'undefined'. Just delete instead.
          delete process.env.DEBUG;
        } else {
          process.env.DEBUG = namespaces;
        }
      }

      /**
       * Load `namespaces`.
       *
       * @return {String} returns the previously persisted debug modes
       * @api private
       */

      function load() {
        return process.env.DEBUG;
      }

      /**
       * Copied from `node/src/node.js`.
       *
       * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
       * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
       */

      function createWritableStdioStream(fd) {
        var stream;
        var tty_wrap = process.binding("tty_wrap");

        // Note stream._type is used for test-module-load-list.js

        switch (tty_wrap.guessHandleType(fd)) {
          case "TTY":
            stream = new tty.WriteStream(fd);
            stream._type = "tty";

            // Hack to have stream not keep the event loop alive.
            // See https://github.com/joyent/node/issues/1726
            if (stream._handle && stream._handle.unref) {
              stream._handle.unref();
            }
            break;

          case "FILE":
            var fs = __nccwpck_require__(7147);
            stream = new fs.SyncWriteStream(fd, { autoClose: false });
            stream._type = "fs";
            break;

          case "PIPE":
          case "TCP":
            var net = __nccwpck_require__(1808);
            stream = new net.Socket({
              fd: fd,
              readable: false,
              writable: true
            });

            // FIXME Should probably have an option in net.Socket to create a
            // stream from an existing fd which is writable only. But for now
            // we'll just add this hack and set the `readable` member to false.
            // Test: ./node test/fixtures/echo.js < /etc/passwd
            stream.readable = false;
            stream.read = null;
            stream._type = "pipe";

            // FIXME Hack to have stream not keep the event loop alive.
            // See https://github.com/joyent/node/issues/1726
            if (stream._handle && stream._handle.unref) {
              stream._handle.unref();
            }
            break;

          default:
            // Probably an error on in uv_guess_handle()
            throw new Error("Implement me. Unknown stream file type!");
        }

        // For supporting legacy API we put the FD here.
        stream.fd = fd;

        stream._isStdio = true;

        return stream;
      }

      /**
       * Init logic for `debug` instances.
       *
       * Create a new `inspectOpts` object in case `useColors` is set
       * differently for a particular `debug` instance.
       */

      function init(debug) {
        debug.inspectOpts = {};

        var keys = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }

      /**
       * Enable namespaces listed in `process.env.DEBUG` initially.
       */

      exports.enable(load());

      /***/
    },

    /***/ 5172: /***/ (module) => {
      /**
       * Helpers.
       */

      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var y = d * 365.25;

      /**
       * Parse or format the given `val`.
       *
       * Options:
       *
       *  - `long` verbose formatting [false]
       *
       * @param {String|Number} val
       * @param {Object} [options]
       * @throws {Error} throw an error if val is not a non-empty string or a number
       * @return {String|Number}
       * @api public
       */

      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isNaN(val) === false) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };

      /**
       * Parse the given `str` and return milliseconds.
       *
       * @param {String} str
       * @return {Number}
       * @api private
       */

      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match =
          /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
            str
          );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return undefined;
        }
      }

      /**
       * Short format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtShort(ms) {
        if (ms >= d) {
          return Math.round(ms / d) + "d";
        }
        if (ms >= h) {
          return Math.round(ms / h) + "h";
        }
        if (ms >= m) {
          return Math.round(ms / m) + "m";
        }
        if (ms >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }

      /**
       * Long format for `ms`.
       *
       * @param {Number} ms
       * @return {String}
       * @api private
       */

      function fmtLong(ms) {
        return (
          plural(ms, d, "day") ||
          plural(ms, h, "hour") ||
          plural(ms, m, "minute") ||
          plural(ms, s, "second") ||
          ms + " ms"
        );
      }

      /**
       * Pluralization helper.
       */

      function plural(ms, n, name) {
        if (ms < n) {
          return;
        }
        if (ms < n * 1.5) {
          return Math.floor(ms / n) + " " + name;
        }
        return Math.ceil(ms / n) + " " + name + "s";
      }

      /***/
    },

    /***/ 5566: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * Array random slice with items count.
       * @param {Array} arr
       * @param {Number} num, number of sub items.
       * @return {Array}
       */
      exports.randomSlice = function randomSlice(arr, num) {
        if (!num || num >= arr.length) {
          return arr.slice();
        }
        var index = Math.floor(Math.random() * arr.length);
        var a = [];
        for (var i = 0, j = index; i < num; i++) {
          a.push(arr[j++]);
          if (j === arr.length) {
            j = 0;
          }
        }
        return a;
      };

      /**
       * Remove one exists element from an array
       * @param {Array} arr
       * @param  {Number} index - remove element index
       * @return {Array} the array instance
       */
      exports.spliceOne = function spliceOne(arr, index) {
        if (index < 0) {
          index = arr.length + index;
          // still negative, not found element
          if (index < 0) {
            return arr;
          }
        }

        // don't touch
        if (index >= arr.length) {
          return arr;
        }

        for (var i = index, k = i + 1, n = arr.length; k < n; i += 1, k += 1) {
          arr[i] = arr[k];
        }
        arr.pop();
        return arr;
      };

      /***/
    },

    /***/ 1023: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var crypto = __nccwpck_require__(6113);

      /**
       * hash
       *
       * @param {String} method hash method, e.g.: 'md5', 'sha1'
       * @param {String|Buffer|Object} s
       * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
       * @return {String} md5 hash string
       * @public
       */
      exports.hash = function hash(method, s, format) {
        var sum = crypto.createHash(method);
        var isBuffer = Buffer.isBuffer(s);
        if (!isBuffer && typeof s === "object") {
          s = JSON.stringify(sortObject(s));
        }
        sum.update(s, isBuffer ? "binary" : "utf8");
        return sum.digest(format || "hex");
      };

      /**
       * md5 hash
       *
       * @param {String|Buffer|Object} s
       * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
       * @return {String} md5 hash string
       * @public
       */
      exports.md5 = function md5(s, format) {
        return exports.hash("md5", s, format);
      };

      /**
       * sha1 hash
       *
       * @param {String|Buffer|Object} s
       * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
       * @return {String} sha1 hash string
       * @public
       */
      exports.sha1 = function sha1(s, format) {
        return exports.hash("sha1", s, format);
      };

      /**
       * sha256 hash
       *
       * @param {String|Buffer|Object} s
       * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.
       * @return {String} sha256 hash string
       * @public
       */
      exports.sha256 = function sha256(s, format) {
        return exports.hash("sha256", s, format);
      };

      /**
       * HMAC algorithm.
       *
       * Equal bash:
       *
       * ```bash
       * $ echo -n "$data" | openssl dgst -binary -$algorithm -hmac "$key" | openssl $encoding
       * ```
       *
       * @param {String} algorithm, dependent on the available algorithms supported by the version of OpenSSL on the platform.
       *   Examples are 'sha1', 'md5', 'sha256', 'sha512', etc.
       *   On recent releases, `openssl list-message-digest-algorithms` will display the available digest algorithms.
       * @param {String} key, the hmac key to be used.
       * @param {String|Buffer} data, content string.
       * @param {String} [encoding='base64']
       * @return {String} digest string.
       */
      exports.hmac = function hmac(algorithm, key, data, encoding) {
        encoding = encoding || "base64";
        var hmac = crypto.createHmac(algorithm, key);
        hmac.update(data, Buffer.isBuffer(data) ? "binary" : "utf8");
        return hmac.digest(encoding);
      };

      /**
       * Base64 encode string.
       *
       * @param {String|Buffer} s
       * @param {Boolean} [urlsafe=false] Encode string s using a URL-safe alphabet,
       *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.
       * @return {String} base64 encode format string.
       */
      exports.base64encode = function base64encode(s, urlsafe) {
        if (!Buffer.isBuffer(s)) {
          s = typeof Buffer.from === "function" ? Buffer.from(s) : new Buffer(s);
        }
        var encode = s.toString("base64");
        if (urlsafe) {
          encode = encode.replace(/\+/g, "-").replace(/\//g, "_");
        }
        return encode;
      };

      /**
       * Base64 string decode.
       *
       * @param {String} encode, base64 encoding string.
       * @param {Boolean} [urlsafe=false] Decode string s using a URL-safe alphabet,
       *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.
       * @param {encoding} [encoding=utf8] if encoding = buffer, will return Buffer instance
       * @return {String|Buffer} plain text.
       */
      exports.base64decode = function base64decode(encodeStr, urlsafe, encoding) {
        if (urlsafe) {
          encodeStr = encodeStr.replace(/\-/g, "+").replace(/_/g, "/");
        }
        var buf =
          typeof Buffer.from === "function" ? Buffer.from(encodeStr, "base64") : new Buffer(encodeStr, "base64");
        if (encoding === "buffer") {
          return buf;
        }
        return buf.toString(encoding || "utf8");
      };

      function sortObject(o) {
        if (!o || Array.isArray(o) || typeof o !== "object") {
          return o;
        }
        var keys = Object.keys(o);
        keys.sort();
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          values.push([k, sortObject(o[k])]);
        }
        return values;
      }

      /***/
    },

    /***/ 265: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

      // only set once.
      var TIMEZONE = " ";
      var _hourOffset = parseInt(-new Date().getTimezoneOffset() / 60, 10);
      if (_hourOffset >= 0) {
        TIMEZONE += "+";
      } else {
        TIMEZONE += "-";
      }
      _hourOffset = Math.abs(_hourOffset);
      if (_hourOffset < 10) {
        _hourOffset = "0" + _hourOffset;
      }
      TIMEZONE += _hourOffset + "00";

      /**
       * Access log format date. format: `moment().format('DD/MMM/YYYY:HH:mm:ss ZZ')`
       *
       * @return {String}
       */
      exports.accessLogDate = function (d) {
        // 16/Apr/2013:16:40:09 +0800
        d = d || new Date();
        var date = d.getDate();
        if (date < 10) {
          date = "0" + date;
        }
        var hours = d.getHours();
        if (hours < 10) {
          hours = "0" + hours;
        }
        var mintues = d.getMinutes();
        if (mintues < 10) {
          mintues = "0" + mintues;
        }
        var seconds = d.getSeconds();
        if (seconds < 10) {
          seconds = "0" + seconds;
        }
        return (
          date +
          "/" +
          MONTHS[d.getMonth()] +
          "/" +
          d.getFullYear() +
          ":" +
          hours +
          ":" +
          mintues +
          ":" +
          seconds +
          TIMEZONE
        );
      };

      /**
       * Normal log format date. format: `moment().format('YYYY-MM-DD HH:mm:ss.SSS')`
       *
       * @return {String}
       */
      exports.logDate = exports.YYYYMMDDHHmmssSSS = function (d, msSep) {
        if (typeof d === "string") {
          // logDate(msSep)
          msSep = d;
          d = new Date();
        } else {
          // logDate(d, msSep)
          d = d || new Date();
        }
        var date = d.getDate();
        if (date < 10) {
          date = "0" + date;
        }
        var month = d.getMonth() + 1;
        if (month < 10) {
          month = "0" + month;
        }
        var hours = d.getHours();
        if (hours < 10) {
          hours = "0" + hours;
        }
        var mintues = d.getMinutes();
        if (mintues < 10) {
          mintues = "0" + mintues;
        }
        var seconds = d.getSeconds();
        if (seconds < 10) {
          seconds = "0" + seconds;
        }
        var milliseconds = d.getMilliseconds();
        if (milliseconds < 10) {
          milliseconds = "00" + milliseconds;
        } else if (milliseconds < 100) {
          milliseconds = "0" + milliseconds;
        }
        return (
          d.getFullYear() +
          "-" +
          month +
          "-" +
          date +
          " " +
          hours +
          ":" +
          mintues +
          ":" +
          seconds +
          (msSep || ".") +
          milliseconds
        );
      };

      /**
       * `moment().format('YYYY-MM-DD HH:mm:ss')` format date string.
       *
       * @return {String}
       */
      exports.YYYYMMDDHHmmss = function (d, options) {
        d = d || new Date();
        if (!(d instanceof Date)) {
          d = new Date(d);
        }

        var dateSep = "-";
        var timeSep = ":";
        if (options) {
          if (options.dateSep) {
            dateSep = options.dateSep;
          }
          if (options.timeSep) {
            timeSep = options.timeSep;
          }
        }
        var date = d.getDate();
        if (date < 10) {
          date = "0" + date;
        }
        var month = d.getMonth() + 1;
        if (month < 10) {
          month = "0" + month;
        }
        var hours = d.getHours();
        if (hours < 10) {
          hours = "0" + hours;
        }
        var mintues = d.getMinutes();
        if (mintues < 10) {
          mintues = "0" + mintues;
        }
        var seconds = d.getSeconds();
        if (seconds < 10) {
          seconds = "0" + seconds;
        }
        return d.getFullYear() + dateSep + month + dateSep + date + " " + hours + timeSep + mintues + timeSep + seconds;
      };

      /**
       * `moment().format('YYYY-MM-DD')` format date string.
       *
       * @return {String}
       */
      exports.YYYYMMDD = function YYYYMMDD(d, sep) {
        if (typeof d === "string") {
          // YYYYMMDD(sep)
          sep = d;
          d = new Date();
        } else {
          // YYYYMMDD(d, sep)
          d = d || new Date();
          if (typeof sep !== "string") {
            sep = "-";
          }
        }
        var date = d.getDate();
        if (date < 10) {
          date = "0" + date;
        }
        var month = d.getMonth() + 1;
        if (month < 10) {
          month = "0" + month;
        }
        return d.getFullYear() + sep + month + sep + date;
      };

      /**
       * return datetime struct.
       *
       * @return {Object} date
       *  - {Number} YYYYMMDD, 20130401
       *  - {Number} H, 0, 1, 9, 12, 23
       */
      exports.datestruct = function (now) {
        now = now || new Date();
        return {
          YYYYMMDD: now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate(),
          H: now.getHours()
        };
      };

      /**
       * Get Unix's timestamp in seconds.
       * @return {Number}
       */
      exports.timestamp = function timestamp(t) {
        if (t) {
          var v = t;
          if (typeof v === "string") {
            v = Number(v);
          }
          if (String(t).length === 10) {
            v *= 1000;
          }
          return new Date(v);
        }
        return Math.round(Date.now() / 1000);
      };

      /***/
    },

    /***/ 4249: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var assert = __nccwpck_require__(9491);

      /**
       * A empty function.
       *
       * @return {Function}
       * @public
       */
      exports.noop = function noop() {};

      /**
       * Get a function parameter's names.
       *
       * @param {Function} func
       * @param {Boolean} [useCache], default is true
       * @return {Array} names
       */
      exports.getParamNames = function getParamNames(func, cache) {
        var type = typeof func;
        assert(type === "function", 'The "func" must be a function. Received type "' + type + '"');

        cache = cache !== false;
        if (cache && func.__cache_names) {
          return func.__cache_names;
        }
        var str = func.toString();
        var names = str.slice(str.indexOf("(") + 1, str.indexOf(")")).match(/([^\s,]+)/g) || [];
        func.__cache_names = names;
        return names;
      };

      /***/
    },

    /***/ 610: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      var path = __nccwpck_require__(1017);

      var _mkdirp;
      function getMkdirp() {
        if (!_mkdirp) {
          _mkdirp = __nccwpck_require__(6186);
        }
        return _mkdirp;
      }
      var _fs;
      function getFS() {
        if (!_fs) {
          _fs = __nccwpck_require__(5573);
        }
        return _fs;
      }

      exports.strictJSONParse = function (str) {
        var obj = JSON.parse(str);
        if (!obj || typeof obj !== "object") {
          throw new Error("JSON string is not object");
        }
        return obj;
      };

      exports.readJSONSync = function (filepath) {
        if (!getFS().existsSync(filepath)) {
          throw new Error(filepath + " is not found");
        }
        return JSON.parse(getFS().readFileSync(filepath));
      };

      exports.writeJSONSync = function (filepath, str, options) {
        options = options || {};
        if (!("space" in options)) {
          options.space = 2;
        }

        getMkdirp().sync(path.dirname(filepath));
        if (typeof str === "object") {
          str = JSON.stringify(str, options.replacer, options.space) + "\n";
        }

        getFS().writeFileSync(filepath, str);
      };

      exports.readJSON = function (filepath) {
        return getFS()
          .exists(filepath)
          .then(function (exists) {
            if (!exists) {
              throw new Error(filepath + " is not found");
            }
            return getFS().readFile(filepath);
          })
          .then(function (buf) {
            return JSON.parse(buf);
          });
      };

      exports.writeJSON = function (filepath, str, options) {
        options = options || {};
        if (!("space" in options)) {
          options.space = 2;
        }

        if (typeof str === "object") {
          str = JSON.stringify(str, options.replacer, options.space) + "\n";
        }

        return mkdir(path.dirname(filepath)).then(function () {
          return getFS().writeFile(filepath, str);
        });
      };

      function mkdir(dir) {
        return new Promise(function (resolve, reject) {
          getMkdirp()(dir, function (err) {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        });
      }

      /***/
    },

    /***/ 1981: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      // http://www.2ality.com/2013/10/safe-integers.html
      // http://es6.ruanyifeng.com/#docs/number
      exports.MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
      exports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;
      var MAX_SAFE_INTEGER_STR = (exports.MAX_SAFE_INTEGER_STR = String(exports.MAX_SAFE_INTEGER));
      var MAX_SAFE_INTEGER_STR_LENGTH = MAX_SAFE_INTEGER_STR.length;

      /**
       * Detect a number string can safe convert to Javascript Number.
       *
       * @param {String} s number format string, like `"123"`, `"-1000123123123123123123"`
       * @return {Boolean}
       */
      exports.isSafeNumberString = function isSafeNumberString(s) {
        if (s[0] === "-") {
          s = s.substring(1);
        }
        if (
          s.length < MAX_SAFE_INTEGER_STR_LENGTH ||
          (s.length === MAX_SAFE_INTEGER_STR_LENGTH && s <= MAX_SAFE_INTEGER_STR)
        ) {
          return true;
        }
        return false;
      };

      /**
       * Convert string to Number if string in safe Number scope.
       *
       * @param {String} s number format string.
       * @return {Number|String} success will return Number, otherise return the original string.
       */
      exports.toSafeNumber = function toSafeNumber(s) {
        if (typeof s === "number") {
          return s;
        }

        return exports.isSafeNumberString(s) ? Number(s) : s;
      };

      /**
       * Produces a random integer between the inclusive `lower` and `upper` bounds.
       *
       * @param {Number} lower The lower bound.
       * @param {Number} upper The upper bound.
       * @return {Number} Returns the random number.
       */
      exports.random = function random(lower, upper) {
        if (lower === undefined && upper === undefined) {
          return 0;
        }
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        }
        var temp;
        if (lower > upper) {
          temp = lower;
          lower = upper;
          upper = temp;
        }
        return Math.floor(lower + Math.random() * (upper - lower));
      };

      /***/
    },

    /***/ 6394: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * High performance assign before node6
       * @param {Object} target - target object
       * @param {Object | Array} objects - object assign from
       * @return {Object} - return target object
       */
      exports.assign = function (target, objects) {
        if (!Array.isArray(objects)) {
          objects = [objects];
        }

        for (var i = 0; i < objects.length; i++) {
          var obj = objects[i];
          if (obj) {
            var keys = Object.keys(obj);
            for (var j = 0; j < keys.length; j++) {
              var key = keys[j];
              target[key] = obj[key];
            }
          }
        }
        return target;
      };

      exports.has = function has(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };

      /**
       * Get all enumerable and ownership of property names
       * @param {Object} obj - detect object
       * @param {Boolean} [ignoreNull] - ignore null, undefined or NaN property
       * @return {Array<String>} property names
       */
      exports.getOwnEnumerables = function getOwnEnumerables(obj, ignoreNull) {
        if (!obj || typeof obj !== "object" || Array.isArray(obj)) {
          return [];
        }
        return Object.keys(obj).filter(function (key) {
          if (ignoreNull) {
            var value = obj[key];
            if (value === null || value === undefined || Number.isNaN(value)) {
              return false;
            }
          }
          return exports.has(obj, key);
        });
      };

      /**
       * generate a real map object(clean object), no constructor, no __proto__
       * @param {Object} [obj] - init object, optional
       * @return {Object}
       */
      exports.map = function map(obj) {
        var map = new EmptyObject();
        if (!obj) {
          return map;
        }

        for (var key in obj) {
          map[key] = obj[key];
        }
        return map;
      };

      // faster way like `Object.create(null)` to get a 'clean' empty object
      // https://github.com/nodejs/node/blob/master/lib/events.js#L5
      // https://cnodejs.org/topic/571e0c445a26c4a841ecbcf1
      function EmptyObject() {}
      EmptyObject.prototype = Object.create(null);

      /***/
    },

    /***/ 4501: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      /**
       * optimize try catch
       * @param {Function} fn
       * @return {Object}
       *   - {Error} error
       *   - {Mix} value
       */
      exports["try"] = function (fn) {
        var res = {
          error: undefined,
          value: undefined
        };

        try {
          res.value = fn();
        } catch (err) {
          res.error = err instanceof Error ? err : new Error(err);
        }

        return res;
      };

      /**
       * @description Deal with typescript
       */
      exports.UNSTABLE_METHOD = {
        try: exports.try
      };

      /**
       * avoid if (a && a.b && a.b.c)
       * @param {Object} obj
       * @param {...String} keys
       * @return {Object}
       */
      exports.dig = function (obj) {
        if (!obj) {
          return;
        }
        if (arguments.length <= 1) {
          return obj;
        }

        var value = obj[arguments[1]];
        for (var i = 2; i < arguments.length; i++) {
          if (!value) {
            break;
          }
          value = value[arguments[i]];
        }

        return value;
      };

      /**
       * optimize arguments to array
       * @param {Arguments} args
       * @return {Array}
       */
      exports.argumentsToArray = function (args) {
        var res = new Array(args.length);
        for (var i = 0; i < args.length; i++) {
          res[i] = args[i];
        }
        return res;
      };

      /***/
    },

    /***/ 6692: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      exports.setImmediate =
        typeof setImmediate === "function"
          ? setImmediate
          : function (fn) {
              process.nextTick(fn.bind.apply(fn, arguments));
            };

      /***/
    },

    /***/ 825: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      exports.randomString = function randomString(length, charSet) {
        var result = [];
        length = length || 16;
        charSet = charSet || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

        while (length--) {
          result.push(charSet[Math.floor(Math.random() * charSet.length)]);
        }
        return result.join("");
      };

      /**
       * split string to array
       * @param  {String} str
       * @param  {String} [sep] default is ','
       * @return {Array}
       */
      exports.split = function split(str, sep) {
        str = str || "";
        sep = sep || ",";
        var items = str.split(sep);
        var needs = [];
        for (var i = 0; i < items.length; i++) {
          var s = items[i].trim();
          if (s.length > 0) {
            needs.push(s);
          }
        }
        return needs;
      };
      // always optimized
      exports.splitAlwaysOptimized = function splitAlwaysOptimized() {
        var str = "";
        var sep = ",";
        if (arguments.length === 1) {
          str = arguments[0] || "";
        } else if (arguments.length === 2) {
          str = arguments[0] || "";
          sep = arguments[1] || ",";
        }
        var items = str.split(sep);
        var needs = [];
        for (var i = 0; i < items.length; i++) {
          var s = items[i].trim();
          if (s.length > 0) {
            needs.push(s);
          }
        }
        return needs;
      };

      /**
       * Replace string
       *
       * @param  {String} str
       * @param  {String|RegExp} substr
       * @param  {String|Function} newSubstr
       * @return {String}
       */
      exports.replace = function replace(str, substr, newSubstr) {
        var replaceFunction = newSubstr;
        if (typeof replaceFunction !== "function") {
          replaceFunction = function () {
            return newSubstr;
          };
        }
        return str.replace(substr, replaceFunction);
      };

      // original source https://github.com/nodejs/node/blob/v7.5.0/lib/_http_common.js#L300
      /**
       * True if val contains an invalid field-vchar
       *  field-value    = *( field-content / obs-fold )
       *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
       *  field-vchar    = VCHAR / obs-text
       *
       * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
       * so take care when making changes to the implementation so that the source
       * code size does not exceed v8's default max_inlined_source_size setting.
       **/
      var validHdrChars = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0, // 0 - 15
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0, // 16 - 31
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 32 - 47
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 48 - 63
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 64 - 79
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 80 - 95
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 96 - 111
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0, // 112 - 127
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1, // 128 ...
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1 // ... 255
      ];

      /**
       * Replace invalid http header characters with replacement
       *
       * @param  {String} val
       * @param  {String|Function} replacement - can be `function(char)`
       * @return {Object}
       */
      exports.replaceInvalidHttpHeaderChar = function replaceInvalidHttpHeaderChar(val, replacement) {
        replacement = replacement || " ";
        var invalid = false;

        if (!val || typeof val !== "string") {
          return {
            val: val,
            invalid: invalid
          };
        }

        var replacementType = typeof replacement;
        var chars;
        for (var i = 0; i < val.length; ++i) {
          if (!validHdrChars[val.charCodeAt(i)]) {
            // delay create chars
            chars = chars || val.split("");
            if (replacementType === "function") {
              chars[i] = replacement(chars[i]);
            } else {
              chars[i] = replacement;
            }
          }
        }

        if (chars) {
          val = chars.join("");
          invalid = true;
        }

        return {
          val: val,
          invalid: invalid
        };
      };

      /**
       * Detect invalid http header characters in a string
       *
       * @param {String} val
       * @return {Boolean}
       */
      exports.includesInvalidHttpHeaderChar = function includesInvalidHttpHeaderChar(val) {
        if (!val || typeof val !== "string") {
          return false;
        }

        for (var i = 0; i < val.length; ++i) {
          if (!validHdrChars[val.charCodeAt(i)]) {
            return true;
          }
        }

        return false;
      };

      /***/
    },

    /***/ 3877: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var copy = __nccwpck_require__(952);

      copy(__nccwpck_require__(4249))
        .and(__nccwpck_require__(6692))
        .and(__nccwpck_require__(4501))
        .and(__nccwpck_require__(1023))
        .and(__nccwpck_require__(1981))
        .and(__nccwpck_require__(825))
        .and(__nccwpck_require__(5566))
        .and(__nccwpck_require__(610))
        .and(__nccwpck_require__(265))
        .and(__nccwpck_require__(6394))
        .and(__nccwpck_require__(6097))
        .to(module.exports);

      /***/
    },

    /***/ 6097: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      /**
       * Escape the given string of `html`.
       *
       * @param {String} html
       * @return {String}
       * @public
       */
      exports.escape = __nccwpck_require__(4070);

      /**
       * Unescape the given string from html
       * @param {String} html
       * @param {String} type
       * @return {String}
       * @public
       */
      exports.unescape = __nccwpck_require__(1441);

      /**
       * Safe encodeURIComponent, won't throw any error.
       * If `encodeURIComponent` error happen, just return the original value.
       *
       * @param {String} text
       * @return {String} URL encode string.
       */
      exports.encodeURIComponent = function encodeURIComponent_(text) {
        try {
          return encodeURIComponent(text);
        } catch (e) {
          return text;
        }
      };

      /**
       * Safe decodeURIComponent, won't throw any error.
       * If `decodeURIComponent` error happen, just return the original value.
       *
       * @param {String} encodeText
       * @return {String} URL decode original string.
       */
      exports.decodeURIComponent = function decodeURIComponent_(encodeText) {
        try {
          return decodeURIComponent(encodeText);
        } catch (e) {
          return encodeText;
        }
      };

      /***/
    },

    /***/ 5840: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "v1", {
        enumerable: true,
        get: function () {
          return _v.default;
        }
      });
      Object.defineProperty(exports, "v3", {
        enumerable: true,
        get: function () {
          return _v2.default;
        }
      });
      Object.defineProperty(exports, "v4", {
        enumerable: true,
        get: function () {
          return _v3.default;
        }
      });
      Object.defineProperty(exports, "v5", {
        enumerable: true,
        get: function () {
          return _v4.default;
        }
      });
      Object.defineProperty(exports, "NIL", {
        enumerable: true,
        get: function () {
          return _nil.default;
        }
      });
      Object.defineProperty(exports, "version", {
        enumerable: true,
        get: function () {
          return _version.default;
        }
      });
      Object.defineProperty(exports, "validate", {
        enumerable: true,
        get: function () {
          return _validate.default;
        }
      });
      Object.defineProperty(exports, "stringify", {
        enumerable: true,
        get: function () {
          return _stringify.default;
        }
      });
      Object.defineProperty(exports, "parse", {
        enumerable: true,
        get: function () {
          return _parse.default;
        }
      });

      var _v = _interopRequireDefault(__nccwpck_require__(8628));

      var _v2 = _interopRequireDefault(__nccwpck_require__(6409));

      var _v3 = _interopRequireDefault(__nccwpck_require__(5122));

      var _v4 = _interopRequireDefault(__nccwpck_require__(9120));

      var _nil = _interopRequireDefault(__nccwpck_require__(5332));

      var _version = _interopRequireDefault(__nccwpck_require__(1595));

      var _validate = _interopRequireDefault(__nccwpck_require__(6900));

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

      var _parse = _interopRequireDefault(__nccwpck_require__(2746));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /***/
    },

    /***/ 4569: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function md5(bytes) {
        if (Array.isArray(bytes)) {
          bytes = Buffer.from(bytes);
        } else if (typeof bytes === "string") {
          bytes = Buffer.from(bytes, "utf8");
        }

        return _crypto.default.createHash("md5").update(bytes).digest();
      }

      var _default = md5;
      exports["default"] = _default;

      /***/
    },

    /***/ 5332: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;
      var _default = "00000000-0000-0000-0000-000000000000";
      exports["default"] = _default;

      /***/
    },

    /***/ 2746: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _validate = _interopRequireDefault(__nccwpck_require__(6900));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function parse(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }

        let v;
        const arr = new Uint8Array(16); // Parse ########-....-....-....-............

        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
        arr[1] = (v >>> 16) & 0xff;
        arr[2] = (v >>> 8) & 0xff;
        arr[3] = v & 0xff; // Parse ........-####-....-....-............

        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
        arr[5] = v & 0xff; // Parse ........-....-####-....-............

        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
        arr[7] = v & 0xff; // Parse ........-....-....-####-............

        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
        arr[9] = v & 0xff; // Parse ........-....-....-....-############
        // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

        arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff;
        arr[11] = (v / 0x100000000) & 0xff;
        arr[12] = (v >>> 24) & 0xff;
        arr[13] = (v >>> 16) & 0xff;
        arr[14] = (v >>> 8) & 0xff;
        arr[15] = v & 0xff;
        return arr;
      }

      var _default = parse;
      exports["default"] = _default;

      /***/
    },

    /***/ 814: /***/ (__unused_webpack_module, exports) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;
      var _default =
        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      exports["default"] = _default;

      /***/
    },

    /***/ 807: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = rng;

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

      let poolPtr = rnds8Pool.length;

      function rng() {
        if (poolPtr > rnds8Pool.length - 16) {
          _crypto.default.randomFillSync(rnds8Pool);

          poolPtr = 0;
        }

        return rnds8Pool.slice(poolPtr, (poolPtr += 16));
      }

      /***/
    },

    /***/ 5274: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function sha1(bytes) {
        if (Array.isArray(bytes)) {
          bytes = Buffer.from(bytes);
        } else if (typeof bytes === "string") {
          bytes = Buffer.from(bytes, "utf8");
        }

        return _crypto.default.createHash("sha1").update(bytes).digest();
      }

      var _default = sha1;
      exports["default"] = _default;

      /***/
    },

    /***/ 8950: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _validate = _interopRequireDefault(__nccwpck_require__(6900));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      /**
       * Convert array of 16 byte values to UUID string format of the form:
       * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
       */
      const byteToHex = [];

      for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 0x100).toString(16).substr(1));
      }

      function stringify(arr, offset = 0) {
        // Note: Be careful editing this code!  It's been tuned for performance
        // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
        const uuid = (
          byteToHex[arr[offset + 0]] +
          byteToHex[arr[offset + 1]] +
          byteToHex[arr[offset + 2]] +
          byteToHex[arr[offset + 3]] +
          "-" +
          byteToHex[arr[offset + 4]] +
          byteToHex[arr[offset + 5]] +
          "-" +
          byteToHex[arr[offset + 6]] +
          byteToHex[arr[offset + 7]] +
          "-" +
          byteToHex[arr[offset + 8]] +
          byteToHex[arr[offset + 9]] +
          "-" +
          byteToHex[arr[offset + 10]] +
          byteToHex[arr[offset + 11]] +
          byteToHex[arr[offset + 12]] +
          byteToHex[arr[offset + 13]] +
          byteToHex[arr[offset + 14]] +
          byteToHex[arr[offset + 15]]
        ).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
        // of the following:
        // - One or more input array values don't map to a hex octet (leading to
        // "undefined" in the uuid)
        // - Invalid input values for the RFC `version` or `variant` fields

        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Stringified UUID is invalid");
        }

        return uuid;
      }

      var _default = stringify;
      exports["default"] = _default;

      /***/
    },

    /***/ 8628: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _rng = _interopRequireDefault(__nccwpck_require__(807));

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      // **`v1()` - Generate time-based UUID**
      //
      // Inspired by https://github.com/LiosK/UUID.js
      // and http://docs.python.org/library/uuid.html
      let _nodeId;

      let _clockseq; // Previous uuid creation time

      let _lastMSecs = 0;
      let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

      function v1(options, buf, offset) {
        let i = (buf && offset) || 0;
        const b = buf || new Array(16);
        options = options || {};
        let node = options.node || _nodeId;
        let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
        // specified.  We do this lazily to minimize issues related to insufficient
        // system entropy.  See #189

        if (node == null || clockseq == null) {
          const seedBytes = options.random || (options.rng || _rng.default)();

          if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
              seedBytes[0] | 0x01,
              seedBytes[1],
              seedBytes[2],
              seedBytes[3],
              seedBytes[4],
              seedBytes[5]
            ];
          }

          if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 0x3fff;
          }
        } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
        // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
        // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
        // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

        let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
        // cycle to simulate higher resolution clock

        let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

        const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

        if (dt < 0 && options.clockseq === undefined) {
          clockseq = (clockseq + 1) & 0x3fff;
        } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
        // time interval

        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
          nsecs = 0;
        } // Per 4.2.1.2 Throw error if too many uuids are requested

        if (nsecs >= 10000) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }

        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

        msecs += 12219292800000; // `time_low`

        const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = (tl >>> 24) & 0xff;
        b[i++] = (tl >>> 16) & 0xff;
        b[i++] = (tl >>> 8) & 0xff;
        b[i++] = tl & 0xff; // `time_mid`

        const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
        b[i++] = (tmh >>> 8) & 0xff;
        b[i++] = tmh & 0xff; // `time_high_and_version`

        b[i++] = ((tmh >>> 24) & 0xf) | 0x10; // include version

        b[i++] = (tmh >>> 16) & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

        b[i++] = (clockseq >>> 8) | 0x80; // `clock_seq_low`

        b[i++] = clockseq & 0xff; // `node`

        for (let n = 0; n < 6; ++n) {
          b[i + n] = node[n];
        }

        return buf || (0, _stringify.default)(b);
      }

      var _default = v1;
      exports["default"] = _default;

      /***/
    },

    /***/ 6409: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _v = _interopRequireDefault(__nccwpck_require__(5998));

      var _md = _interopRequireDefault(__nccwpck_require__(4569));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      const v3 = (0, _v.default)("v3", 0x30, _md.default);
      var _default = v3;
      exports["default"] = _default;

      /***/
    },

    /***/ 5998: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = _default;
      exports.URL = exports.DNS = void 0;

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

      var _parse = _interopRequireDefault(__nccwpck_require__(2746));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str)); // UTF8 escape

        const bytes = [];

        for (let i = 0; i < str.length; ++i) {
          bytes.push(str.charCodeAt(i));
        }

        return bytes;
      }

      const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports.DNS = DNS;
      const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports.URL = URL;

      function _default(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          if (typeof value === "string") {
            value = stringToBytes(value);
          }

          if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
          }

          if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          } // Compute hash of namespace and value, Per 4.3
          // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
          // hashfunc([...namespace, ... value])`

          let bytes = new Uint8Array(16 + value.length);
          bytes.set(namespace);
          bytes.set(value, namespace.length);
          bytes = hashfunc(bytes);
          bytes[6] = (bytes[6] & 0x0f) | version;
          bytes[8] = (bytes[8] & 0x3f) | 0x80;

          if (buf) {
            offset = offset || 0;

            for (let i = 0; i < 16; ++i) {
              buf[offset + i] = bytes[i];
            }

            return buf;
          }

          return (0, _stringify.default)(bytes);
        } // Function#name is not settable on some platforms (#270)

        try {
          generateUUID.name = name; // eslint-disable-next-line no-empty
        } catch (err) {} // For CommonJS default export support

        generateUUID.DNS = DNS;
        generateUUID.URL = URL;
        return generateUUID;
      }

      /***/
    },

    /***/ 5122: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _rng = _interopRequireDefault(__nccwpck_require__(807));

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function v4(options, buf, offset) {
        options = options || {};

        const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

        rnds[6] = (rnds[6] & 0x0f) | 0x40;
        rnds[8] = (rnds[8] & 0x3f) | 0x80; // Copy bytes to buffer, if provided

        if (buf) {
          offset = offset || 0;

          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
          }

          return buf;
        }

        return (0, _stringify.default)(rnds);
      }

      var _default = v4;
      exports["default"] = _default;

      /***/
    },

    /***/ 9120: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _v = _interopRequireDefault(__nccwpck_require__(5998));

      var _sha = _interopRequireDefault(__nccwpck_require__(5274));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      const v5 = (0, _v.default)("v5", 0x50, _sha.default);
      var _default = v5;
      exports["default"] = _default;

      /***/
    },

    /***/ 6900: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _regex = _interopRequireDefault(__nccwpck_require__(814));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function validate(uuid) {
        return typeof uuid === "string" && _regex.default.test(uuid);
      }

      var _default = validate;
      exports["default"] = _default;

      /***/
    },

    /***/ 1595: /***/ (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;

      var _validate = _interopRequireDefault(__nccwpck_require__(6900));

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      function version(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }

        return parseInt(uuid.substr(14, 1), 16);
      }

      var _default = version;
      exports["default"] = _default;

      /***/
    },

    /***/ 9513: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";

      var os = __nccwpck_require__(2037);
      var semver = __nccwpck_require__(2675);

      var nameMap = {
        "10.0": "10",
        6.3: "8.1",
        6.2: "8",
        6.1: "7",
        "6.0": "Vista",
        5.1: "XP",
        "5.0": "2000",
        4.9: "ME",
        4.1: "98",
        "4.0": "95"
      };

      module.exports = function (release) {
        var verRe = /\d+\.\d+/;
        var version = verRe.exec(release || os.release());

        // workaround for Windows 10 on node < 3.1.0
        if (!release && process.platform === "win32" && semver.satisfies(process.version, ">=0.12.0 <3.1.0")) {
          try {
            version = verRe.exec(String(__nccwpck_require__(2081).execSync("ver.exe", { timeout: 2000 })));
          } catch (err) {}
        }

        if (release && !version) {
          throw new Error("`release` argument doesn't match `n.n`");
        }

        return nameMap[(version || [])[0]];
      };

      /***/
    },

    /***/ 2675: /***/ (module, exports) => {
      exports = module.exports = SemVer;

      var debug;
      /* istanbul ignore next */
      if (
        typeof process === "object" &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ) {
        debug = function () {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift("SEMVER");
          console.log.apply(console, args);
        };
      } else {
        debug = function () {};
      }

      // Note: this is the semver.org version of the spec that it implements
      // Not necessarily the package version of this code.
      exports.SEMVER_SPEC_VERSION = "2.0.0";

      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;

      // Max safe segment length for coercion.
      var MAX_SAFE_COMPONENT_LENGTH = 16;

      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

      // The actual regexps go on exports.re
      var re = (exports.re = []);
      var safeRe = (exports.safeRe = []);
      var src = (exports.src = []);
      var R = 0;

      var LETTERDASHNUMBER = "[a-zA-Z0-9-]";

      // Replace some greedy regex tokens to prevent regex dos issues. These regex are
      // used internally via the safeRe object since all inputs in this library get
      // normalized first to trim and collapse all extra whitespace. The original
      // regexes are exported for userland consumption and lower level usage. A
      // future breaking change could export the safer regex only with a note that
      // all input should have extra whitespace removed.
      var safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
      ];

      function makeSafeRe(value) {
        for (var i = 0; i < safeRegexReplacements.length; i++) {
          var token = safeRegexReplacements[i][0];
          var max = safeRegexReplacements[i][1];
          value = value
            .split(token + "*")
            .join(token + "{0," + max + "}")
            .split(token + "+")
            .join(token + "{1," + max + "}");
        }
        return value;
      }

      // The following Regular Expressions can be used for tokenizing,
      // validating, and parsing SemVer version strings.

      // ## Numeric Identifier
      // A single `0`, or a non-zero digit followed by zero or more digits.

      var NUMERICIDENTIFIER = R++;
      src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
      var NUMERICIDENTIFIERLOOSE = R++;
      src[NUMERICIDENTIFIERLOOSE] = "\\d+";

      // ## Non-numeric Identifier
      // Zero or more digits, followed by a letter or hyphen, and then zero or
      // more letters, digits, or hyphens.

      var NONNUMERICIDENTIFIER = R++;
      src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";

      // ## Main Version
      // Three dot-separated numeric identifiers.

      var MAINVERSION = R++;
      src[MAINVERSION] =
        "(" +
        src[NUMERICIDENTIFIER] +
        ")\\." +
        "(" +
        src[NUMERICIDENTIFIER] +
        ")\\." +
        "(" +
        src[NUMERICIDENTIFIER] +
        ")";

      var MAINVERSIONLOOSE = R++;
      src[MAINVERSIONLOOSE] =
        "(" +
        src[NUMERICIDENTIFIERLOOSE] +
        ")\\." +
        "(" +
        src[NUMERICIDENTIFIERLOOSE] +
        ")\\." +
        "(" +
        src[NUMERICIDENTIFIERLOOSE] +
        ")";

      // ## Pre-release Version Identifier
      // A numeric identifier, or a non-numeric identifier.

      var PRERELEASEIDENTIFIER = R++;
      src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";

      var PRERELEASEIDENTIFIERLOOSE = R++;
      src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";

      // ## Pre-release Version
      // Hyphen, followed by one or more dot-separated pre-release version
      // identifiers.

      var PRERELEASE = R++;
      src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";

      var PRERELEASELOOSE = R++;
      src[PRERELEASELOOSE] =
        "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";

      // ## Build Metadata Identifier
      // Any combination of digits, letters, or hyphens.

      var BUILDIDENTIFIER = R++;
      src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";

      // ## Build Metadata
      // Plus sign, followed by one or more period-separated build metadata
      // identifiers.

      var BUILD = R++;
      src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";

      // ## Full Version String
      // A main version, followed optionally by a pre-release version and
      // build metadata.

      // Note that the only major, minor, patch, and pre-release sections of
      // the version string are capturing groups.  The build metadata is not a
      // capturing group, because it should not ever be used in version
      // comparison.

      var FULL = R++;
      var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";

      src[FULL] = "^" + FULLPLAIN + "$";

      // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
      // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
      // common in the npm registry.
      var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";

      var LOOSE = R++;
      src[LOOSE] = "^" + LOOSEPLAIN + "$";

      var GTLT = R++;
      src[GTLT] = "((?:<|>)?=?)";

      // Something like "2.*" or "1.2.x".
      // Note that "x.x" is a valid xRange identifer, meaning "any version"
      // Only the first item is strictly required.
      var XRANGEIDENTIFIERLOOSE = R++;
      src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
      var XRANGEIDENTIFIER = R++;
      src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";

      var XRANGEPLAIN = R++;
      src[XRANGEPLAIN] =
        "[v=\\s]*(" +
        src[XRANGEIDENTIFIER] +
        ")" +
        "(?:\\.(" +
        src[XRANGEIDENTIFIER] +
        ")" +
        "(?:\\.(" +
        src[XRANGEIDENTIFIER] +
        ")" +
        "(?:" +
        src[PRERELEASE] +
        ")?" +
        src[BUILD] +
        "?" +
        ")?)?";

      var XRANGEPLAINLOOSE = R++;
      src[XRANGEPLAINLOOSE] =
        "[v=\\s]*(" +
        src[XRANGEIDENTIFIERLOOSE] +
        ")" +
        "(?:\\.(" +
        src[XRANGEIDENTIFIERLOOSE] +
        ")" +
        "(?:\\.(" +
        src[XRANGEIDENTIFIERLOOSE] +
        ")" +
        "(?:" +
        src[PRERELEASELOOSE] +
        ")?" +
        src[BUILD] +
        "?" +
        ")?)?";

      var XRANGE = R++;
      src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
      var XRANGELOOSE = R++;
      src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";

      // Coercion.
      // Extract anything that could conceivably be a part of a valid semver
      var COERCE = R++;
      src[COERCE] =
        "(?:^|[^\\d])" +
        "(\\d{1," +
        MAX_SAFE_COMPONENT_LENGTH +
        "})" +
        "(?:\\.(\\d{1," +
        MAX_SAFE_COMPONENT_LENGTH +
        "}))?" +
        "(?:\\.(\\d{1," +
        MAX_SAFE_COMPONENT_LENGTH +
        "}))?" +
        "(?:$|[^\\d])";

      // Tilde ranges.
      // Meaning is "reasonably at or greater than"
      var LONETILDE = R++;
      src[LONETILDE] = "(?:~>?)";

      var TILDETRIM = R++;
      src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
      re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
      safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
      var tildeTrimReplace = "$1~";

      var TILDE = R++;
      src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
      var TILDELOOSE = R++;
      src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";

      // Caret ranges.
      // Meaning is "at least and backwards compatible with"
      var LONECARET = R++;
      src[LONECARET] = "(?:\\^)";

      var CARETTRIM = R++;
      src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
      re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
      safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
      var caretTrimReplace = "$1^";

      var CARET = R++;
      src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
      var CARETLOOSE = R++;
      src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";

      // A simple gt/lt/eq thing, or just "" to indicate "any version"
      var COMPARATORLOOSE = R++;
      src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
      var COMPARATOR = R++;
      src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";

      // An expression to strip any whitespace between the gtlt and the thing
      // it modifies, so that `> 1.2.3` ==> `>1.2.3`
      var COMPARATORTRIM = R++;
      src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";

      // this one has to use the /g flag
      re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
      safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
      var comparatorTrimReplace = "$1$2$3";

      // Something like `1.2.3 - 1.2.4`
      // Note that these all use the loose form, because they'll be
      // checked against either the strict or loose comparator form
      // later.
      var HYPHENRANGE = R++;
      src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[XRANGEPLAIN] + ")" + "\\s*$";

      var HYPHENRANGELOOSE = R++;
      src[HYPHENRANGELOOSE] =
        "^\\s*(" + src[XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[XRANGEPLAINLOOSE] + ")" + "\\s*$";

      // Star ranges basically just allow anything at all.
      var STAR = R++;
      src[STAR] = "(<|>)?=?\\s*\\*";

      // Compile to actual regexp objects.
      // All are flag-free, unless they were created above with a flag.
      for (var i = 0; i < R; i++) {
        debug(i, src[i]);
        if (!re[i]) {
          re[i] = new RegExp(src[i]);

          // Replace all greedy whitespace to prevent regex dos issues. These regex are
          // used internally via the safeRe object since all inputs in this library get
          // normalized first to trim and collapse all extra whitespace. The original
          // regexes are exported for userland consumption and lower level usage. A
          // future breaking change could export the safer regex only with a note that
          // all input should have extra whitespace removed.
          safeRe[i] = new RegExp(makeSafeRe(src[i]));
        }
      }

      exports.parse = parse;
      function parse(version, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (version instanceof SemVer) {
          return version;
        }

        if (typeof version !== "string") {
          return null;
        }

        if (version.length > MAX_LENGTH) {
          return null;
        }

        var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
        if (!r.test(version)) {
          return null;
        }

        try {
          return new SemVer(version, options);
        } catch (er) {
          return null;
        }
      }

      exports.valid = valid;
      function valid(version, options) {
        var v = parse(version, options);
        return v ? v.version : null;
      }

      exports.clean = clean;
      function clean(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      }

      exports.SemVer = SemVer;

      function SemVer(version, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (version instanceof SemVer) {
          if (version.loose === options.loose) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError("Invalid Version: " + version);
        }

        if (version.length > MAX_LENGTH) {
          throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
        }

        if (!(this instanceof SemVer)) {
          return new SemVer(version, options);
        }

        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;

        var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);

        if (!m) {
          throw new TypeError("Invalid Version: " + version);
        }

        this.raw = version;

        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];

        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }

        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }

        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }

        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }

      SemVer.prototype.format = function () {
        this.version = this.major + "." + this.minor + "." + this.patch;
        if (this.prerelease.length) {
          this.version += "-" + this.prerelease.join(".");
        }
        return this.version;
      };

      SemVer.prototype.toString = function () {
        return this.version;
      };

      SemVer.prototype.compare = function (other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        return this.compareMain(other) || this.comparePre(other);
      };

      SemVer.prototype.compareMain = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        );
      };

      SemVer.prototype.comparePre = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }

        var i = 0;
        do {
          var a = this.prerelease[i];
          var b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === undefined && b === undefined) {
            return 0;
          } else if (b === undefined) {
            return 1;
          } else if (a === undefined) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      };

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      SemVer.prototype.inc = function (release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;

          case "major":
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              var i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                // didn't increment anything
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;

          default:
            throw new Error("invalid increment argument: " + release);
        }
        this.format();
        this.raw = this.version;
        return this;
      };

      exports.inc = inc;
      function inc(version, release, loose, identifier) {
        if (typeof loose === "string") {
          identifier = loose;
          loose = undefined;
        }

        try {
          return new SemVer(version, loose).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      }

      exports.diff = diff;
      function diff(version1, version2) {
        if (eq(version1, version2)) {
          return null;
        } else {
          var v1 = parse(version1);
          var v2 = parse(version2);
          var prefix = "";
          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = "pre";
            var defaultResult = "prerelease";
          }
          for (var key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return prefix + key;
              }
            }
          }
          return defaultResult; // may be undefined
        }
      }

      exports.compareIdentifiers = compareIdentifiers;

      var numeric = /^[0-9]+$/;
      function compareIdentifiers(a, b) {
        var anum = numeric.test(a);
        var bnum = numeric.test(b);

        if (anum && bnum) {
          a = +a;
          b = +b;
        }

        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      }

      exports.rcompareIdentifiers = rcompareIdentifiers;
      function rcompareIdentifiers(a, b) {
        return compareIdentifiers(b, a);
      }

      exports.major = major;
      function major(a, loose) {
        return new SemVer(a, loose).major;
      }

      exports.minor = minor;
      function minor(a, loose) {
        return new SemVer(a, loose).minor;
      }

      exports.patch = patch;
      function patch(a, loose) {
        return new SemVer(a, loose).patch;
      }

      exports.compare = compare;
      function compare(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose));
      }

      exports.compareLoose = compareLoose;
      function compareLoose(a, b) {
        return compare(a, b, true);
      }

      exports.rcompare = rcompare;
      function rcompare(a, b, loose) {
        return compare(b, a, loose);
      }

      exports.sort = sort;
      function sort(list, loose) {
        return list.sort(function (a, b) {
          return exports.compare(a, b, loose);
        });
      }

      exports.rsort = rsort;
      function rsort(list, loose) {
        return list.sort(function (a, b) {
          return exports.rcompare(a, b, loose);
        });
      }

      exports.gt = gt;
      function gt(a, b, loose) {
        return compare(a, b, loose) > 0;
      }

      exports.lt = lt;
      function lt(a, b, loose) {
        return compare(a, b, loose) < 0;
      }

      exports.eq = eq;
      function eq(a, b, loose) {
        return compare(a, b, loose) === 0;
      }

      exports.neq = neq;
      function neq(a, b, loose) {
        return compare(a, b, loose) !== 0;
      }

      exports.gte = gte;
      function gte(a, b, loose) {
        return compare(a, b, loose) >= 0;
      }

      exports.lte = lte;
      function lte(a, b, loose) {
        return compare(a, b, loose) <= 0;
      }

      exports.cmp = cmp;
      function cmp(a, op, b, loose) {
        switch (op) {
          case "===":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a === b;

          case "!==":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a !== b;

          case "":
          case "=":
          case "==":
            return eq(a, b, loose);

          case "!=":
            return neq(a, b, loose);

          case ">":
            return gt(a, b, loose);

          case ">=":
            return gte(a, b, loose);

          case "<":
            return lt(a, b, loose);

          case "<=":
            return lte(a, b, loose);

          default:
            throw new TypeError("Invalid operator: " + op);
        }
      }

      exports.Comparator = Comparator;
      function Comparator(comp, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }

        if (!(this instanceof Comparator)) {
          return new Comparator(comp, options);
        }

        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);

        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }

        debug("comp", this);
      }

      var ANY = {};
      Comparator.prototype.parse = function (comp) {
        var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
        var m = comp.match(r);

        if (!m) {
          throw new TypeError("Invalid comparator: " + comp);
        }

        this.operator = m[1];
        if (this.operator === "=") {
          this.operator = "";
        }

        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      };

      Comparator.prototype.toString = function () {
        return this.value;
      };

      Comparator.prototype.test = function (version) {
        debug("Comparator.test", version, this.options.loose);

        if (this.semver === ANY) {
          return true;
        }

        if (typeof version === "string") {
          version = new SemVer(version, this.options);
        }

        return cmp(version, this.operator, this.semver, this.options);
      };

      Comparator.prototype.intersects = function (comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }

        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        var rangeTmp;

        if (this.operator === "") {
          rangeTmp = new Range(comp.value, options);
          return satisfies(this.value, rangeTmp, options);
        } else if (comp.operator === "") {
          rangeTmp = new Range(this.value, options);
          return satisfies(comp.semver, rangeTmp, options);
        }

        var sameDirectionIncreasing =
          (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        var sameDirectionDecreasing =
          (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        var sameSemVer = this.semver.version === comp.semver.version;
        var differentDirectionsInclusive =
          (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        var oppositeDirectionsLessThan =
          cmp(this.semver, "<", comp.semver, options) &&
          (this.operator === ">=" || this.operator === ">") &&
          (comp.operator === "<=" || comp.operator === "<");
        var oppositeDirectionsGreaterThan =
          cmp(this.semver, ">", comp.semver, options) &&
          (this.operator === "<=" || this.operator === "<") &&
          (comp.operator === ">=" || comp.operator === ">");

        return (
          sameDirectionIncreasing ||
          sameDirectionDecreasing ||
          (sameSemVer && differentDirectionsInclusive) ||
          oppositeDirectionsLessThan ||
          oppositeDirectionsGreaterThan
        );
      };

      exports.Range = Range;
      function Range(range, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }

        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }

        if (range instanceof Comparator) {
          return new Range(range.value, options);
        }

        if (!(this instanceof Range)) {
          return new Range(range, options);
        }

        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;

        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().split(/\s+/).join(" ");

        // First, split based on boolean or ||
        this.set = this.raw
          .split("||")
          .map(function (range) {
            return this.parseRange(range.trim());
          }, this)
          .filter(function (c) {
            // throw out any that are not relevant for whatever reason
            return c.length;
          });

        if (!this.set.length) {
          throw new TypeError("Invalid SemVer Range: " + this.raw);
        }

        this.format();
      }

      Range.prototype.format = function () {
        this.range = this.set
          .map(function (comps) {
            return comps.join(" ").trim();
          })
          .join("||")
          .trim();
        return this.range;
      };

      Range.prototype.toString = function () {
        return this.range;
      };

      Range.prototype.parseRange = function (range) {
        var loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
        range = range.replace(hr, hyphenReplace);
        debug("hyphen replace", range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, safeRe[COMPARATORTRIM]);

        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);

        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(safeRe[CARETTRIM], caretTrimReplace);

        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
        var set = range
          .split(" ")
          .map(function (comp) {
            return parseComparator(comp, this.options);
          }, this)
          .join(" ")
          .split(/\s+/);
        if (this.options.loose) {
          // in loose mode, throw out any that are not valid comparators
          set = set.filter(function (comp) {
            return !!comp.match(compRe);
          });
        }
        set = set.map(function (comp) {
          return new Comparator(comp, this.options);
        }, this);

        return set;
      };

      Range.prototype.intersects = function (range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }

        return this.set.some(function (thisComparators) {
          return thisComparators.every(function (thisComparator) {
            return range.set.some(function (rangeComparators) {
              return rangeComparators.every(function (rangeComparator) {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      };

      // Mostly just for testing and legacy API reasons
      exports.toComparators = toComparators;
      function toComparators(range, options) {
        return new Range(range, options).set.map(function (comp) {
          return comp
            .map(function (c) {
              return c.value;
            })
            .join(" ")
            .trim()
            .split(" ");
        });
      }

      // comprised of xranges, tildes, stars, and gtlt's at this point.
      // already replaced the hyphen ranges
      // turn into a set of JUST comparators.
      function parseComparator(comp, options) {
        debug("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug("caret", comp);
        comp = replaceTildes(comp, options);
        debug("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug("xrange", comp);
        comp = replaceStars(comp, options);
        debug("stars", comp);
        return comp;
      }

      function isX(id) {
        return !id || id.toLowerCase() === "x" || id === "*";
      }

      // ~, ~> --> * (any, kinda silly)
      // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
      // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
      // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
      // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
      // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
      function replaceTildes(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceTilde(comp, options);
          })
          .join(" ");
      }

      function replaceTilde(comp, options) {
        var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
        return comp.replace(r, function (_, M, m, p, pr) {
          debug("tilde", comp, _, M, m, p, pr);
          var ret;

          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
          } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else if (pr) {
            debug("replaceTilde pr", pr);
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          } else {
            // ~1.2.3 == >=1.2.3 <1.3.0
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }

          debug("tilde return", ret);
          return ret;
        });
      }

      // ^ --> * (any, kinda silly)
      // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
      // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
      // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
      // ^1.2.3 --> >=1.2.3 <2.0.0
      // ^1.2.0 --> >=1.2.0 <2.0.0
      function replaceCarets(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceCaret(comp, options);
          })
          .join(" ");
      }

      function replaceCaret(comp, options) {
        debug("caret", comp, options);
        var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
        return comp.replace(r, function (_, M, m, p, pr) {
          debug("caret", comp, _, M, m, p, pr);
          var ret;

          if (isX(M)) {
            ret = "";
          } else if (isX(m)) {
            ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
          } else if (isX(p)) {
            if (M === "0") {
              ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
            } else {
              ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
            }
          } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
              } else {
                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
              }
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
            }
          } else {
            debug("no pr");
            if (M === "0") {
              if (m === "0") {
                ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
              } else {
                ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
              }
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
            }
          }

          debug("caret return", ret);
          return ret;
        });
      }

      function replaceXRanges(comp, options) {
        debug("replaceXRanges", comp, options);
        return comp
          .split(/\s+/)
          .map(function (comp) {
            return replaceXRange(comp, options);
          })
          .join(" ");
      }

      function replaceXRange(comp, options) {
        comp = comp.trim();
        var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
        return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
          debug("xRange", comp, ret, gtlt, M, m, p, pr);
          var xM = isX(M);
          var xm = xM || isX(m);
          var xp = xm || isX(p);
          var anyX = xp;

          if (gtlt === "=" && anyX) {
            gtlt = "";
          }

          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              // nothing is allowed
              ret = "<0.0.0";
            } else {
              // nothing is forbidden
              ret = "*";
            }
          } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
              m = 0;
            }
            p = 0;

            if (gtlt === ">") {
              // >1 => >=2.0.0
              // >1.2 => >=1.3.0
              // >1.2.3 => >= 1.2.4
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              // <=0.7.x is actually <0.8.0, since any 0.7.x should
              // pass.  Similarly, <=7.x is actually <8.0.0, etc.
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }

            ret = gtlt + M + "." + m + "." + p;
          } else if (xm) {
            ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
          } else if (xp) {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          }

          debug("xRange return", ret);

          return ret;
        });
      }

      // Because * is AND-ed with everything else in the comparator,
      // and '' means "any version", just remove the *s entirely.
      function replaceStars(comp, options) {
        debug("replaceStars", comp, options);
        // Looseness is ignored here.  star is always as loose as it gets!
        return comp.trim().replace(safeRe[STAR], "");
      }

      // This function is passed to string.replace(safeRe[HYPHENRANGE])
      // M, m, patch, prerelease, build
      // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
      // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
      // 1.2 - 3.4 => >=1.2.0 <3.5.0
      function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = ">=" + fM + ".0.0";
        } else if (isX(fp)) {
          from = ">=" + fM + "." + fm + ".0";
        } else {
          from = ">=" + from;
        }

        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = "<" + (+tM + 1) + ".0.0";
        } else if (isX(tp)) {
          to = "<" + tM + "." + (+tm + 1) + ".0";
        } else if (tpr) {
          to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
        } else {
          to = "<=" + to;
        }

        return (from + " " + to).trim();
      }

      // if ANY of the sets match ALL of its comparators, then pass
      Range.prototype.test = function (version) {
        if (!version) {
          return false;
        }

        if (typeof version === "string") {
          version = new SemVer(version, this.options);
        }

        for (var i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      };

      function testSet(set, version, options) {
        for (var i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false;
          }
        }

        if (version.prerelease.length && !options.includePrerelease) {
          // Find the set of versions that are allowed to have prereleases
          // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
          // That should allow `1.2.3-pr.2` to pass.
          // However, `1.2.4-alpha.notready` should NOT be allowed,
          // even though it's within the range set by the comparators.
          for (i = 0; i < set.length; i++) {
            debug(set[i].semver);
            if (set[i].semver === ANY) {
              continue;
            }

            if (set[i].semver.prerelease.length > 0) {
              var allowed = set[i].semver;
              if (
                allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch
              ) {
                return true;
              }
            }
          }

          // Version has a -pre, but it's not one of the ones we like.
          return false;
        }

        return true;
      }

      exports.satisfies = satisfies;
      function satisfies(version, range, options) {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version);
      }

      exports.maxSatisfying = maxSatisfying;
      function maxSatisfying(versions, range, options) {
        var max = null;
        var maxSV = null;
        try {
          var rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
              // compare(max, v, true)
              max = v;
              maxSV = new SemVer(max, options);
            }
          }
        });
        return max;
      }

      exports.minSatisfying = minSatisfying;
      function minSatisfying(versions, range, options) {
        var min = null;
        var minSV = null;
        try {
          var rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
              // compare(min, v, true)
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      }

      exports.minVersion = minVersion;
      function minVersion(range, loose) {
        range = new Range(range, loose);

        var minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }

        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }

        minver = null;
        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i];

          comparators.forEach(function (comparator) {
            // Clone to avoid manipulating the comparator's semver object.
            var compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              /* fallthrough */
              case "":
              case ">=":
                if (!minver || gt(minver, compver)) {
                  minver = compver;
                }
                break;
              case "<":
              case "<=":
                /* Ignore maximum versions */
                break;
              /* istanbul ignore next */
              default:
                throw new Error("Unexpected operation: " + comparator.operator);
            }
          });
        }

        if (minver && range.test(minver)) {
          return minver;
        }

        return null;
      }

      exports.validRange = validRange;
      function validRange(range, options) {
        try {
          // Return '*' instead of '' so that truthiness works.
          // This will throw if it's invalid anyway
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      }

      // Determine if version is less than all the versions possible in the range
      exports.ltr = ltr;
      function ltr(version, range, options) {
        return outside(version, range, "<", options);
      }

      // Determine if version is greater than all the versions possible in the range.
      exports.gtr = gtr;
      function gtr(version, range, options) {
        return outside(version, range, ">", options);
      }

      exports.outside = outside;
      function outside(version, range, hilo, options) {
        version = new SemVer(version, options);
        range = new Range(range, options);

        var gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }

        // If it satisifes the range it is not outside
        if (satisfies(version, range, options)) {
          return false;
        }

        // From now on, variable terms are as if we're in "gtr" mode.
        // but note that everything is flipped for the "ltr" function.

        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i];

          var high = null;
          var low = null;

          comparators.forEach(function (comparator) {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });

          // If the edge version comparator has a operator then our version
          // isn't outside it
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }

          // If the lowest version comparator has an operator and our version
          // is less than it then it isn't higher than the range
          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
          }
        }
        return true;
      }

      exports.prerelease = prerelease;
      function prerelease(version, options) {
        var parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      }

      exports.intersects = intersects;
      function intersects(r1, r2, options) {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2);
      }

      exports.coerce = coerce;
      function coerce(version) {
        if (version instanceof SemVer) {
          return version;
        }

        if (typeof version !== "string") {
          return null;
        }

        var match = version.match(safeRe[COERCE]);

        if (match == null) {
          return null;
        }

        return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
      }

      /***/
    },

    /***/ 2940: /***/ (module) => {
      // Returns a wrapper function that returns a wrapped callback
      // The wrapper function should do some stuff, and return a
      // presumably different callback function.
      // This makes sure that own properties are retained, so that
      // decorations and such are not lost along the way.
      module.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb) return wrappy(fn)(cb);

        if (typeof fn !== "function") throw new TypeError("need wrapper function");

        Object.keys(fn).forEach(function (k) {
          wrapper[k] = fn[k];
        });

        return wrapper;

        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb) {
            Object.keys(cb).forEach(function (k) {
              ret[k] = cb[k];
            });
          }
          return ret;
        }
      }

      /***/
    },

    /***/ 2624: /***/ function (__unused_webpack_module, exports) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        "use strict";
        exports.stripBOM = function (str) {
          if (str[0] === "\uFEFF") {
            return str.substring(1);
          } else {
            return str;
          }
        };
      }).call(this);

      /***/
    },

    /***/ 3337: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        "use strict";
        var builder,
          defaults,
          escapeCDATA,
          requiresCDATA,
          wrapCDATA,
          hasProp = {}.hasOwnProperty;

        builder = __nccwpck_require__(2958);

        defaults = __nccwpck_require__(7251).defaults;

        requiresCDATA = function (entry) {
          return (
            typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0)
          );
        };

        wrapCDATA = function (entry) {
          return "<![CDATA[" + escapeCDATA(entry) + "]]>";
        };

        escapeCDATA = function (entry) {
          return entry.replace("]]>", "]]]]><![CDATA[>");
        };

        exports.Builder = (function () {
          function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key)) continue;
              value = opts[key];
              this.options[key] = value;
            }
          }

          Builder.prototype.buildObject = function (rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
              rootName = Object.keys(rootObj)[0];
              rootObj = rootObj[rootName];
            } else {
              rootName = this.options.rootName;
            }
            render = (function (_this) {
              return function (element, obj) {
                var attr, child, entry, index, key, value;
                if (typeof obj !== "object") {
                  if (_this.options.cdata && requiresCDATA(obj)) {
                    element.raw(wrapCDATA(obj));
                  } else {
                    element.txt(obj);
                  }
                } else if (Array.isArray(obj)) {
                  for (index in obj) {
                    if (!hasProp.call(obj, index)) continue;
                    child = obj[index];
                    for (key in child) {
                      entry = child[key];
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else {
                  for (key in obj) {
                    if (!hasProp.call(obj, key)) continue;
                    child = obj[key];
                    if (key === attrkey) {
                      if (typeof child === "object") {
                        for (attr in child) {
                          value = child[attr];
                          element = element.att(attr, value);
                        }
                      }
                    } else if (key === charkey) {
                      if (_this.options.cdata && requiresCDATA(child)) {
                        element = element.raw(wrapCDATA(child));
                      } else {
                        element = element.txt(child);
                      }
                    } else if (Array.isArray(child)) {
                      for (index in child) {
                        if (!hasProp.call(child, index)) continue;
                        entry = child[index];
                        if (typeof entry === "string") {
                          if (_this.options.cdata && requiresCDATA(entry)) {
                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                          } else {
                            element = element.ele(key, entry).up();
                          }
                        } else {
                          element = render(element.ele(key), entry).up();
                        }
                      }
                    } else if (typeof child === "object") {
                      element = render(element.ele(key), child).up();
                    } else {
                      if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                        element = element.ele(key).raw(wrapCDATA(child)).up();
                      } else {
                        if (child == null) {
                          child = "";
                        }
                        element = element.ele(key, child.toString()).up();
                      }
                    }
                  }
                }
                return element;
              };
            })(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
              headless: this.options.headless,
              allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
          };

          return Builder;
        })();
      }).call(this);

      /***/
    },

    /***/ 7251: /***/ function (__unused_webpack_module, exports) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        exports.defaults = {
          0.1: {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: "@@",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ""
          },
          0.2: {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: "$$",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: "root",
            xmldec: {
              version: "1.0",
              encoding: "UTF-8",
              standalone: true
            },
            doctype: null,
            renderOpts: {
              pretty: true,
              indent: "  ",
              newline: "\n"
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: "",
            cdata: false
          }
        };
      }).call(this);

      /***/
    },

    /***/ 3314: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        "use strict";
        var bom,
          defaults,
          defineProperty,
          events,
          isEmpty,
          processItem,
          processors,
          sax,
          setImmediate,
          bind = function (fn, me) {
            return function () {
              return fn.apply(me, arguments);
            };
          },
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        sax = __nccwpck_require__(2043);

        events = __nccwpck_require__(2361);

        bom = __nccwpck_require__(2624);

        processors = __nccwpck_require__(9236);

        setImmediate = __nccwpck_require__(9512).setImmediate;

        defaults = __nccwpck_require__(7251).defaults;

        isEmpty = function (thing) {
          return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
        };

        processItem = function (processors, item, key) {
          var i, len, process;
          for (i = 0, len = processors.length; i < len; i++) {
            process = processors[i];
            item = process(item, key);
          }
          return item;
        };

        defineProperty = function (obj, key, value) {
          var descriptor;
          descriptor = Object.create(null);
          descriptor.value = value;
          descriptor.writable = true;
          descriptor.enumerable = true;
          descriptor.configurable = true;
          return Object.defineProperty(obj, key, descriptor);
        };

        exports.Parser = (function (superClass) {
          extend(Parser, superClass);

          function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
              return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key)) continue;
              value = opts[key];
              this.options[key] = value;
            }
            if (this.options.xmlns) {
              this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
              if (!this.options.tagNameProcessors) {
                this.options.tagNameProcessors = [];
              }
              this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
          }

          Parser.prototype.processAsync = function () {
            var chunk, err;
            try {
              if (this.remaining.length <= this.options.chunkSize) {
                chunk = this.remaining;
                this.remaining = "";
                this.saxParser = this.saxParser.write(chunk);
                return this.saxParser.close();
              } else {
                chunk = this.remaining.substr(0, this.options.chunkSize);
                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                this.saxParser = this.saxParser.write(chunk);
                return setImmediate(this.processAsync);
              }
            } catch (error1) {
              err = error1;
              if (!this.saxParser.errThrown) {
                this.saxParser.errThrown = true;
                return this.emit(err);
              }
            }
          };

          Parser.prototype.assignOrPush = function (obj, key, newValue) {
            if (!(key in obj)) {
              if (!this.options.explicitArray) {
                return defineProperty(obj, key, newValue);
              } else {
                return defineProperty(obj, key, [newValue]);
              }
            } else {
              if (!(obj[key] instanceof Array)) {
                defineProperty(obj, key, [obj[key]]);
              }
              return obj[key].push(newValue);
            }
          };

          Parser.prototype.reset = function () {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
              trim: false,
              normalize: false,
              xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = (function (_this) {
              return function (error) {
                _this.saxParser.resume();
                if (!_this.saxParser.errThrown) {
                  _this.saxParser.errThrown = true;
                  return _this.emit("error", error);
                }
              };
            })(this);
            this.saxParser.onend = (function (_this) {
              return function () {
                if (!_this.saxParser.ended) {
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            })(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = (function (_this) {
              return function (node) {
                var key, newValue, obj, processedKey, ref;
                obj = {};
                obj[charkey] = "";
                if (!_this.options.ignoreAttrs) {
                  ref = node.attributes;
                  for (key in ref) {
                    if (!hasProp.call(ref, key)) continue;
                    if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                      obj[attrkey] = {};
                    }
                    newValue = _this.options.attrValueProcessors
                      ? processItem(_this.options.attrValueProcessors, node.attributes[key], key)
                      : node.attributes[key];
                    processedKey = _this.options.attrNameProcessors
                      ? processItem(_this.options.attrNameProcessors, key)
                      : key;
                    if (_this.options.mergeAttrs) {
                      _this.assignOrPush(obj, processedKey, newValue);
                    } else {
                      defineProperty(obj[attrkey], processedKey, newValue);
                    }
                  }
                }
                obj["#name"] = _this.options.tagNameProcessors
                  ? processItem(_this.options.tagNameProcessors, node.name)
                  : node.name;
                if (_this.options.xmlns) {
                  obj[_this.options.xmlnskey] = {
                    uri: node.uri,
                    local: node.local
                  };
                }
                return stack.push(obj);
              };
            })(this);
            this.saxParser.onclosetag = (function (_this) {
              return function () {
                var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                obj = stack.pop();
                nodeName = obj["#name"];
                if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                  delete obj["#name"];
                }
                if (obj.cdata === true) {
                  cdata = obj.cdata;
                  delete obj.cdata;
                }
                s = stack[stack.length - 1];
                if (obj[charkey].match(/^\s*$/) && !cdata) {
                  emptyStr = obj[charkey];
                  delete obj[charkey];
                } else {
                  if (_this.options.trim) {
                    obj[charkey] = obj[charkey].trim();
                  }
                  if (_this.options.normalize) {
                    obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  obj[charkey] = _this.options.valueProcessors
                    ? processItem(_this.options.valueProcessors, obj[charkey], nodeName)
                    : obj[charkey];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
                if (isEmpty(obj)) {
                  if (typeof _this.options.emptyTag === "function") {
                    obj = _this.options.emptyTag();
                  } else {
                    obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                  }
                }
                if (_this.options.validator != null) {
                  xpath =
                    "/" +
                    (function () {
                      var i, len, results;
                      results = [];
                      for (i = 0, len = stack.length; i < len; i++) {
                        node = stack[i];
                        results.push(node["#name"]);
                      }
                      return results;
                    })()
                      .concat(nodeName)
                      .join("/");
                  (function () {
                    var err;
                    try {
                      return (obj = _this.options.validator(xpath, s && s[nodeName], obj));
                    } catch (error1) {
                      err = error1;
                      return _this.emit("error", err);
                    }
                  })();
                }
                if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                  if (!_this.options.preserveChildrenOrder) {
                    node = {};
                    if (_this.options.attrkey in obj) {
                      node[_this.options.attrkey] = obj[_this.options.attrkey];
                      delete obj[_this.options.attrkey];
                    }
                    if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                      node[_this.options.charkey] = obj[_this.options.charkey];
                      delete obj[_this.options.charkey];
                    }
                    if (Object.getOwnPropertyNames(obj).length > 0) {
                      node[_this.options.childkey] = obj;
                    }
                    obj = node;
                  } else if (s) {
                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                    objClone = {};
                    for (key in obj) {
                      if (!hasProp.call(obj, key)) continue;
                      defineProperty(objClone, key, obj[key]);
                    }
                    s[_this.options.childkey].push(objClone);
                    delete obj["#name"];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                }
                if (stack.length > 0) {
                  return _this.assignOrPush(s, nodeName, obj);
                } else {
                  if (_this.options.explicitRoot) {
                    old = obj;
                    obj = {};
                    defineProperty(obj, nodeName, old);
                  }
                  _this.resultObject = obj;
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            })(this);
            ontext = (function (_this) {
              return function (text) {
                var charChild, s;
                s = stack[stack.length - 1];
                if (s) {
                  s[charkey] += text;
                  if (
                    _this.options.explicitChildren &&
                    _this.options.preserveChildrenOrder &&
                    _this.options.charsAsChildren &&
                    (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")
                  ) {
                    s[_this.options.childkey] = s[_this.options.childkey] || [];
                    charChild = {
                      "#name": "__text__"
                    };
                    charChild[charkey] = text;
                    if (_this.options.normalize) {
                      charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                    }
                    s[_this.options.childkey].push(charChild);
                  }
                  return s;
                }
              };
            })(this);
            this.saxParser.ontext = ontext;
            return (this.saxParser.oncdata = (function (_this) {
              return function (text) {
                var s;
                s = ontext(text);
                if (s) {
                  return (s.cdata = true);
                }
              };
            })(this));
          };

          Parser.prototype.parseString = function (str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
              this.on("end", function (result) {
                this.reset();
                return cb(null, result);
              });
              this.on("error", function (err) {
                this.reset();
                return cb(err);
              });
            }
            try {
              str = str.toString();
              if (str.trim() === "") {
                this.emit("end", null);
                return true;
              }
              str = bom.stripBOM(str);
              if (this.options.async) {
                this.remaining = str;
                setImmediate(this.processAsync);
                return this.saxParser;
              }
              return this.saxParser.write(str).close();
            } catch (error1) {
              err = error1;
              if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                this.emit("error", err);
                return (this.saxParser.errThrown = true);
              } else if (this.saxParser.ended) {
                throw err;
              }
            }
          };

          Parser.prototype.parseStringPromise = function (str) {
            return new Promise(
              (function (_this) {
                return function (resolve, reject) {
                  return _this.parseString(str, function (err, value) {
                    if (err) {
                      return reject(err);
                    } else {
                      return resolve(value);
                    }
                  });
                };
              })(this)
            );
          };

          return Parser;
        })(events);

        exports.parseString = function (str, a, b) {
          var cb, options, parser;
          if (b != null) {
            if (typeof b === "function") {
              cb = b;
            }
            if (typeof a === "object") {
              options = a;
            }
          } else {
            if (typeof a === "function") {
              cb = a;
            }
            options = {};
          }
          parser = new exports.Parser(options);
          return parser.parseString(str, cb);
        };

        exports.parseStringPromise = function (str, a) {
          var options, parser;
          if (typeof a === "object") {
            options = a;
          }
          parser = new exports.Parser(options);
          return parser.parseStringPromise(str);
        };
      }).call(this);

      /***/
    },

    /***/ 9236: /***/ function (__unused_webpack_module, exports) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        "use strict";
        var prefixMatch;

        prefixMatch = new RegExp(/(?!xmlns)^.*:/);

        exports.normalize = function (str) {
          return str.toLowerCase();
        };

        exports.firstCharLowerCase = function (str) {
          return str.charAt(0).toLowerCase() + str.slice(1);
        };

        exports.stripPrefix = function (str) {
          return str.replace(prefixMatch, "");
        };

        exports.parseNumbers = function (str) {
          if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
          }
          return str;
        };

        exports.parseBooleans = function (str) {
          if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === "true";
          }
          return str;
        };
      }).call(this);

      /***/
    },

    /***/ 6189: /***/ function (__unused_webpack_module, exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        "use strict";
        var builder,
          defaults,
          parser,
          processors,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        defaults = __nccwpck_require__(7251);

        builder = __nccwpck_require__(3337);

        parser = __nccwpck_require__(3314);

        processors = __nccwpck_require__(9236);

        exports.defaults = defaults.defaults;

        exports.processors = processors;

        exports.ValidationError = (function (superClass) {
          extend(ValidationError, superClass);

          function ValidationError(message) {
            this.message = message;
          }

          return ValidationError;
        })(Error);

        exports.Builder = builder.Builder;

        exports.Parser = parser.Parser;

        exports.parseString = parser.parseString;

        exports.parseStringPromise = parser.parseStringPromise;
      }).call(this);

      /***/
    },

    /***/ 2839: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        module.exports = {
          Disconnected: 1,
          Preceding: 2,
          Following: 4,
          Contains: 8,
          ContainedBy: 16,
          ImplementationSpecific: 32
        };
      }).call(this);

      /***/
    },

    /***/ 9267: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        module.exports = {
          Element: 1,
          Attribute: 2,
          Text: 3,
          CData: 4,
          EntityReference: 5,
          EntityDeclaration: 6,
          ProcessingInstruction: 7,
          Comment: 8,
          Document: 9,
          DocType: 10,
          DocumentFragment: 11,
          NotationDeclaration: 12,
          Declaration: 201,
          Raw: 202,
          AttributeDeclaration: 203,
          ElementDeclaration: 204,
          Dummy: 205
        };
      }).call(this);

      /***/
    },

    /***/ 8229: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var assign,
          getValue,
          isArray,
          isEmpty,
          isFunction,
          isObject,
          isPlainObject,
          slice = [].slice,
          hasProp = {}.hasOwnProperty;

        assign = function () {
          var i, key, len, source, sources, target;
          (target = arguments[0]), (sources = 2 <= arguments.length ? slice.call(arguments, 1) : []);
          if (isFunction(Object.assign)) {
            Object.assign.apply(null, arguments);
          } else {
            for (i = 0, len = sources.length; i < len; i++) {
              source = sources[i];
              if (source != null) {
                for (key in source) {
                  if (!hasProp.call(source, key)) continue;
                  target[key] = source[key];
                }
              }
            }
          }
          return target;
        };

        isFunction = function (val) {
          return !!val && Object.prototype.toString.call(val) === "[object Function]";
        };

        isObject = function (val) {
          var ref;
          return !!val && ((ref = typeof val) === "function" || ref === "object");
        };

        isArray = function (val) {
          if (isFunction(Array.isArray)) {
            return Array.isArray(val);
          } else {
            return Object.prototype.toString.call(val) === "[object Array]";
          }
        };

        isEmpty = function (val) {
          var key;
          if (isArray(val)) {
            return !val.length;
          } else {
            for (key in val) {
              if (!hasProp.call(val, key)) continue;
              return false;
            }
            return true;
          }
        };

        isPlainObject = function (val) {
          var ctor, proto;
          return (
            isObject(val) &&
            (proto = Object.getPrototypeOf(val)) &&
            (ctor = proto.constructor) &&
            typeof ctor === "function" &&
            ctor instanceof ctor &&
            Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object)
          );
        };

        getValue = function (obj) {
          if (isFunction(obj.valueOf)) {
            return obj.valueOf();
          } else {
            return obj;
          }
        };

        module.exports.assign = assign;

        module.exports.isFunction = isFunction;

        module.exports.isObject = isObject;

        module.exports.isArray = isArray;

        module.exports.isEmpty = isEmpty;

        module.exports.isPlainObject = isPlainObject;

        module.exports.getValue = getValue;
      }).call(this);

      /***/
    },

    /***/ 9766: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        module.exports = {
          None: 0,
          OpenTag: 1,
          InsideTag: 2,
          CloseTag: 3
        };
      }).call(this);

      /***/
    },

    /***/ 8376: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType, XMLAttribute, XMLNode;

        NodeType = __nccwpck_require__(9267);

        XMLNode = __nccwpck_require__(7608);

        module.exports = XMLAttribute = (function () {
          function XMLAttribute(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
          }

          Object.defineProperty(XMLAttribute.prototype, "nodeType", {
            get: function () {
              return this.type;
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "ownerElement", {
            get: function () {
              return this.parent;
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "textContent", {
            get: function () {
              return this.value;
            },
            set: function (value) {
              return (this.value = value || "");
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "namespaceURI", {
            get: function () {
              return "";
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "prefix", {
            get: function () {
              return "";
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "localName", {
            get: function () {
              return this.name;
            }
          });

          Object.defineProperty(XMLAttribute.prototype, "specified", {
            get: function () {
              return true;
            }
          });

          XMLAttribute.prototype.clone = function () {
            return Object.create(this);
          };

          XMLAttribute.prototype.toString = function (options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
          };

          XMLAttribute.prototype.debugInfo = function (name) {
            name = name || this.name;
            if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else {
              return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
            }
          };

          XMLAttribute.prototype.isEqualNode = function (node) {
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.value !== this.value) {
              return false;
            }
            return true;
          };

          return XMLAttribute;
        })();
      }).call(this);

      /***/
    },

    /***/ 333: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLCData,
          XMLCharacterData,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLCharacterData = __nccwpck_require__(7709);

        module.exports = XMLCData = (function (superClass) {
          extend(XMLCData, superClass);

          function XMLCData(parent, text) {
            XMLCData.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing CDATA text. " + this.debugInfo());
            }
            this.name = "#cdata-section";
            this.type = NodeType.CData;
            this.value = this.stringify.cdata(text);
          }

          XMLCData.prototype.clone = function () {
            return Object.create(this);
          };

          XMLCData.prototype.toString = function (options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
          };

          return XMLCData;
        })(XMLCharacterData);
      }).call(this);

      /***/
    },

    /***/ 7709: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLCharacterData,
          XMLNode,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLNode = __nccwpck_require__(7608);

        module.exports = XMLCharacterData = (function (superClass) {
          extend(XMLCharacterData, superClass);

          function XMLCharacterData(parent) {
            XMLCharacterData.__super__.constructor.call(this, parent);
            this.value = "";
          }

          Object.defineProperty(XMLCharacterData.prototype, "data", {
            get: function () {
              return this.value;
            },
            set: function (value) {
              return (this.value = value || "");
            }
          });

          Object.defineProperty(XMLCharacterData.prototype, "length", {
            get: function () {
              return this.value.length;
            }
          });

          Object.defineProperty(XMLCharacterData.prototype, "textContent", {
            get: function () {
              return this.value;
            },
            set: function (value) {
              return (this.value = value || "");
            }
          });

          XMLCharacterData.prototype.clone = function () {
            return Object.create(this);
          };

          XMLCharacterData.prototype.substringData = function (offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLCharacterData.prototype.appendData = function (arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLCharacterData.prototype.insertData = function (offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLCharacterData.prototype.deleteData = function (offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLCharacterData.prototype.replaceData = function (offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLCharacterData.prototype.isEqualNode = function (node) {
            if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.data !== this.data) {
              return false;
            }
            return true;
          };

          return XMLCharacterData;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 4407: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLCharacterData,
          XMLComment,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLCharacterData = __nccwpck_require__(7709);

        module.exports = XMLComment = (function (superClass) {
          extend(XMLComment, superClass);

          function XMLComment(parent, text) {
            XMLComment.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing comment text. " + this.debugInfo());
            }
            this.name = "#comment";
            this.type = NodeType.Comment;
            this.value = this.stringify.comment(text);
          }

          XMLComment.prototype.clone = function () {
            return Object.create(this);
          };

          XMLComment.prototype.toString = function (options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
          };

          return XMLComment;
        })(XMLCharacterData);
      }).call(this);

      /***/
    },

    /***/ 7465: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;

        XMLDOMErrorHandler = __nccwpck_require__(6744);

        XMLDOMStringList = __nccwpck_require__(7028);

        module.exports = XMLDOMConfiguration = (function () {
          function XMLDOMConfiguration() {
            var clonedSelf;
            this.defaultParams = {
              "canonical-form": false,
              "cdata-sections": false,
              comments: false,
              "datatype-normalization": false,
              "element-content-whitespace": true,
              entities: true,
              "error-handler": new XMLDOMErrorHandler(),
              infoset: true,
              "validate-if-schema": false,
              namespaces: true,
              "namespace-declarations": true,
              "normalize-characters": false,
              "schema-location": "",
              "schema-type": "",
              "split-cdata-sections": true,
              validate: false,
              "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
          }

          Object.defineProperty(XMLDOMConfiguration.prototype, "parameterNames", {
            get: function () {
              return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
          });

          XMLDOMConfiguration.prototype.getParameter = function (name) {
            if (this.params.hasOwnProperty(name)) {
              return this.params[name];
            } else {
              return null;
            }
          };

          XMLDOMConfiguration.prototype.canSetParameter = function (name, value) {
            return true;
          };

          XMLDOMConfiguration.prototype.setParameter = function (name, value) {
            if (value != null) {
              return (this.params[name] = value);
            } else {
              return delete this.params[name];
            }
          };

          return XMLDOMConfiguration;
        })();
      }).call(this);

      /***/
    },

    /***/ 6744: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLDOMErrorHandler;

        module.exports = XMLDOMErrorHandler = (function () {
          function XMLDOMErrorHandler() {}

          XMLDOMErrorHandler.prototype.handleError = function (error) {
            throw new Error(error);
          };

          return XMLDOMErrorHandler;
        })();
      }).call(this);

      /***/
    },

    /***/ 8310: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLDOMImplementation;

        module.exports = XMLDOMImplementation = (function () {
          function XMLDOMImplementation() {}

          XMLDOMImplementation.prototype.hasFeature = function (feature, version) {
            return true;
          };

          XMLDOMImplementation.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
          };

          XMLDOMImplementation.prototype.createDocument = function (namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
          };

          XMLDOMImplementation.prototype.createHTMLDocument = function (title) {
            throw new Error("This DOM method is not implemented.");
          };

          XMLDOMImplementation.prototype.getFeature = function (feature, version) {
            throw new Error("This DOM method is not implemented.");
          };

          return XMLDOMImplementation;
        })();
      }).call(this);

      /***/
    },

    /***/ 7028: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLDOMStringList;

        module.exports = XMLDOMStringList = (function () {
          function XMLDOMStringList(arr) {
            this.arr = arr || [];
          }

          Object.defineProperty(XMLDOMStringList.prototype, "length", {
            get: function () {
              return this.arr.length;
            }
          });

          XMLDOMStringList.prototype.item = function (index) {
            return this.arr[index] || null;
          };

          XMLDOMStringList.prototype.contains = function (str) {
            return this.arr.indexOf(str) !== -1;
          };

          return XMLDOMStringList;
        })();
      }).call(this);

      /***/
    },

    /***/ 1015: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDTDAttList,
          XMLNode,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDTDAttList = (function (superClass) {
          extend(XMLDTDAttList, superClass);

          function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList.__super__.constructor.call(this, parent);
            if (elementName == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (attributeName == null) {
              throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            }
            if (!attributeType) {
              throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            }
            if (!defaultValueType) {
              throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            }
            if (defaultValueType.indexOf("#") !== 0) {
              defaultValueType = "#" + defaultValueType;
            }
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
              throw new Error(
                "Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " +
                  this.debugInfo(elementName)
              );
            }
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            }
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) {
              this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            }
            this.defaultValueType = defaultValueType;
          }

          XMLDTDAttList.prototype.toString = function (options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
          };

          return XMLDTDAttList;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 2421: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDTDElement,
          XMLNode,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDTDElement = (function (superClass) {
          extend(XMLDTDElement, superClass);

          function XMLDTDElement(parent, name, value) {
            XMLDTDElement.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (!value) {
              value = "(#PCDATA)";
            }
            if (Array.isArray(value)) {
              value = "(" + value.join(",") + ")";
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
          }

          XMLDTDElement.prototype.toString = function (options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
          };

          return XMLDTDElement;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 53: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDTDEntity,
          XMLNode,
          isObject,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        isObject = __nccwpck_require__(8229).isObject;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDTDEntity = (function (superClass) {
          extend(XMLDTDEntity, superClass);

          function XMLDTDEntity(parent, pe, name, value) {
            XMLDTDEntity.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            }
            if (value == null) {
              throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            }
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType.EntityDeclaration;
            if (!isObject(value)) {
              this.value = this.stringify.dtdEntityValue(value);
              this.internal = true;
            } else {
              if (!value.pubID && !value.sysID) {
                throw new Error(
                  "Public and/or system identifiers are required for an external entity. " + this.debugInfo(name)
                );
              }
              if (value.pubID && !value.sysID) {
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
              }
              this.internal = false;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
              if (value.nData != null) {
                this.nData = this.stringify.dtdNData(value.nData);
              }
              if (this.pe && this.nData) {
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
              }
            }
          }

          Object.defineProperty(XMLDTDEntity.prototype, "publicId", {
            get: function () {
              return this.pubID;
            }
          });

          Object.defineProperty(XMLDTDEntity.prototype, "systemId", {
            get: function () {
              return this.sysID;
            }
          });

          Object.defineProperty(XMLDTDEntity.prototype, "notationName", {
            get: function () {
              return this.nData || null;
            }
          });

          Object.defineProperty(XMLDTDEntity.prototype, "inputEncoding", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDTDEntity.prototype, "xmlEncoding", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDTDEntity.prototype, "xmlVersion", {
            get: function () {
              return null;
            }
          });

          XMLDTDEntity.prototype.toString = function (options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
          };

          return XMLDTDEntity;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 2837: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDTDNotation,
          XMLNode,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDTDNotation = (function (superClass) {
          extend(XMLDTDNotation, superClass);

          function XMLDTDNotation(parent, name, value) {
            XMLDTDNotation.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            }
            if (!value.pubID && !value.sysID) {
              throw new Error(
                "Public or system identifiers are required for an external entity. " + this.debugInfo(name)
              );
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.NotationDeclaration;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
          }

          Object.defineProperty(XMLDTDNotation.prototype, "publicId", {
            get: function () {
              return this.pubID;
            }
          });

          Object.defineProperty(XMLDTDNotation.prototype, "systemId", {
            get: function () {
              return this.sysID;
            }
          });

          XMLDTDNotation.prototype.toString = function (options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
          };

          return XMLDTDNotation;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 6364: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDeclaration,
          XMLNode,
          isObject,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        isObject = __nccwpck_require__(8229).isObject;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDeclaration = (function (superClass) {
          extend(XMLDeclaration, superClass);

          function XMLDeclaration(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration.__super__.constructor.call(this, parent);
            if (isObject(version)) {
              (ref = version), (version = ref.version), (encoding = ref.encoding), (standalone = ref.standalone);
            }
            if (!version) {
              version = "1.0";
            }
            this.type = NodeType.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) {
              this.encoding = this.stringify.xmlEncoding(encoding);
            }
            if (standalone != null) {
              this.standalone = this.stringify.xmlStandalone(standalone);
            }
          }

          XMLDeclaration.prototype.toString = function (options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
          };

          return XMLDeclaration;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 1801: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDTDAttList,
          XMLDTDElement,
          XMLDTDEntity,
          XMLDTDNotation,
          XMLDocType,
          XMLNamedNodeMap,
          XMLNode,
          isObject,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        isObject = __nccwpck_require__(8229).isObject;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        XMLDTDAttList = __nccwpck_require__(1015);

        XMLDTDEntity = __nccwpck_require__(53);

        XMLDTDElement = __nccwpck_require__(2421);

        XMLDTDNotation = __nccwpck_require__(2837);

        XMLNamedNodeMap = __nccwpck_require__(4361);

        module.exports = XMLDocType = (function (superClass) {
          extend(XMLDocType, superClass);

          function XMLDocType(parent, pubID, sysID) {
            var child, i, len, ref, ref1, ref2;
            XMLDocType.__super__.constructor.call(this, parent);
            this.type = NodeType.DocType;
            if (parent.children) {
              ref = parent.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.Element) {
                  this.name = child.name;
                  break;
                }
              }
            }
            this.documentObject = parent;
            if (isObject(pubID)) {
              (ref1 = pubID), (pubID = ref1.pubID), (sysID = ref1.sysID);
            }
            if (sysID == null) {
              (ref2 = [pubID, sysID]), (sysID = ref2[0]), (pubID = ref2[1]);
            }
            if (pubID != null) {
              this.pubID = this.stringify.dtdPubID(pubID);
            }
            if (sysID != null) {
              this.sysID = this.stringify.dtdSysID(sysID);
            }
          }

          Object.defineProperty(XMLDocType.prototype, "entities", {
            get: function () {
              var child, i, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.EntityDeclaration && !child.pe) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });

          Object.defineProperty(XMLDocType.prototype, "notations", {
            get: function () {
              var child, i, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.NotationDeclaration) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });

          Object.defineProperty(XMLDocType.prototype, "publicId", {
            get: function () {
              return this.pubID;
            }
          });

          Object.defineProperty(XMLDocType.prototype, "systemId", {
            get: function () {
              return this.sysID;
            }
          });

          Object.defineProperty(XMLDocType.prototype, "internalSubset", {
            get: function () {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          XMLDocType.prototype.element = function (name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
          };

          XMLDocType.prototype.attList = function (
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          ) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
          };

          XMLDocType.prototype.entity = function (name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
          };

          XMLDocType.prototype.pEntity = function (name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
          };

          XMLDocType.prototype.notation = function (name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
          };

          XMLDocType.prototype.toString = function (options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
          };

          XMLDocType.prototype.ele = function (name, value) {
            return this.element(name, value);
          };

          XMLDocType.prototype.att = function (
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          ) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
          };

          XMLDocType.prototype.ent = function (name, value) {
            return this.entity(name, value);
          };

          XMLDocType.prototype.pent = function (name, value) {
            return this.pEntity(name, value);
          };

          XMLDocType.prototype.not = function (name, value) {
            return this.notation(name, value);
          };

          XMLDocType.prototype.up = function () {
            return this.root() || this.documentObject;
          };

          XMLDocType.prototype.isEqualNode = function (node) {
            if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.name !== this.name) {
              return false;
            }
            if (node.publicId !== this.publicId) {
              return false;
            }
            if (node.systemId !== this.systemId) {
              return false;
            }
            return true;
          };

          return XMLDocType;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 3730: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDOMConfiguration,
          XMLDOMImplementation,
          XMLDocument,
          XMLNode,
          XMLStringWriter,
          XMLStringifier,
          isPlainObject,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        isPlainObject = __nccwpck_require__(8229).isPlainObject;

        XMLDOMImplementation = __nccwpck_require__(8310);

        XMLDOMConfiguration = __nccwpck_require__(7465);

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        XMLStringifier = __nccwpck_require__(8594);

        XMLStringWriter = __nccwpck_require__(5913);

        module.exports = XMLDocument = (function (superClass) {
          extend(XMLDocument, superClass);

          function XMLDocument(options) {
            XMLDocument.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.stringify = new XMLStringifier(options);
          }

          Object.defineProperty(XMLDocument.prototype, "implementation", {
            value: new XMLDOMImplementation()
          });

          Object.defineProperty(XMLDocument.prototype, "doctype", {
            get: function () {
              var child, i, len, ref;
              ref = this.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                if (child.type === NodeType.DocType) {
                  return child;
                }
              }
              return null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "documentElement", {
            get: function () {
              return this.rootObject || null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "inputEncoding", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "strictErrorChecking", {
            get: function () {
              return false;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "xmlEncoding", {
            get: function () {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].encoding;
              } else {
                return null;
              }
            }
          });

          Object.defineProperty(XMLDocument.prototype, "xmlStandalone", {
            get: function () {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].standalone === "yes";
              } else {
                return false;
              }
            }
          });

          Object.defineProperty(XMLDocument.prototype, "xmlVersion", {
            get: function () {
              if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
                return this.children[0].version;
              } else {
                return "1.0";
              }
            }
          });

          Object.defineProperty(XMLDocument.prototype, "URL", {
            get: function () {
              return this.documentURI;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "origin", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "compatMode", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "characterSet", {
            get: function () {
              return null;
            }
          });

          Object.defineProperty(XMLDocument.prototype, "contentType", {
            get: function () {
              return null;
            }
          });

          XMLDocument.prototype.end = function (writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) {
              writer = this.options.writer;
            } else if (isPlainObject(writer)) {
              writerOptions = writer;
              writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
          };

          XMLDocument.prototype.toString = function (options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
          };

          XMLDocument.prototype.createElement = function (tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createDocumentFragment = function () {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createTextNode = function (data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createComment = function (data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createCDATASection = function (data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createProcessingInstruction = function (target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createAttribute = function (name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createEntityReference = function (name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.getElementsByTagName = function (tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.importNode = function (importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createElementNS = function (namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createAttributeNS = function (namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.getElementById = function (elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.adoptNode = function (source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.normalizeDocument = function () {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.renameNode = function (node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.getElementsByClassName = function (classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createEvent = function (eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createRange = function () {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createNodeIterator = function (root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLDocument.prototype.createTreeWalker = function (root, whatToShow, filter) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          return XMLDocument;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 7356: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          WriterState,
          XMLAttribute,
          XMLCData,
          XMLComment,
          XMLDTDAttList,
          XMLDTDElement,
          XMLDTDEntity,
          XMLDTDNotation,
          XMLDeclaration,
          XMLDocType,
          XMLDocument,
          XMLDocumentCB,
          XMLElement,
          XMLProcessingInstruction,
          XMLRaw,
          XMLStringWriter,
          XMLStringifier,
          XMLText,
          getValue,
          isFunction,
          isObject,
          isPlainObject,
          ref,
          hasProp = {}.hasOwnProperty;

        (ref = __nccwpck_require__(8229)),
          (isObject = ref.isObject),
          (isFunction = ref.isFunction),
          (isPlainObject = ref.isPlainObject),
          (getValue = ref.getValue);

        NodeType = __nccwpck_require__(9267);

        XMLDocument = __nccwpck_require__(3730);

        XMLElement = __nccwpck_require__(9437);

        XMLCData = __nccwpck_require__(333);

        XMLComment = __nccwpck_require__(4407);

        XMLRaw = __nccwpck_require__(6329);

        XMLText = __nccwpck_require__(1318);

        XMLProcessingInstruction = __nccwpck_require__(6939);

        XMLDeclaration = __nccwpck_require__(6364);

        XMLDocType = __nccwpck_require__(1801);

        XMLDTDAttList = __nccwpck_require__(1015);

        XMLDTDEntity = __nccwpck_require__(53);

        XMLDTDElement = __nccwpck_require__(2421);

        XMLDTDNotation = __nccwpck_require__(2837);

        XMLAttribute = __nccwpck_require__(8376);

        XMLStringifier = __nccwpck_require__(8594);

        XMLStringWriter = __nccwpck_require__(5913);

        WriterState = __nccwpck_require__(9766);

        module.exports = XMLDocumentCB = (function () {
          function XMLDocumentCB(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType.Document;
            options || (options = {});
            writerOptions = {};
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            } else if (isPlainObject(options.writer)) {
              writerOptions = options.writer;
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function () {};
            this.onEndCallback = onEnd || function () {};
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {};
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
          }

          XMLDocumentCB.prototype.createChildNode = function (node) {
            var att, attName, attributes, child, i, len, ref1, ref2;
            switch (node.type) {
              case NodeType.CData:
                this.cdata(node.value);
                break;
              case NodeType.Comment:
                this.comment(node.value);
                break;
              case NodeType.Element:
                attributes = {};
                ref1 = node.attribs;
                for (attName in ref1) {
                  if (!hasProp.call(ref1, attName)) continue;
                  att = ref1[attName];
                  attributes[attName] = att.value;
                }
                this.node(node.name, attributes);
                break;
              case NodeType.Dummy:
                this.dummy();
                break;
              case NodeType.Raw:
                this.raw(node.value);
                break;
              case NodeType.Text:
                this.text(node.value);
                break;
              case NodeType.ProcessingInstruction:
                this.instruction(node.target, node.value);
                break;
              default:
                throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for (i = 0, len = ref2.length; i < len; i++) {
              child = ref2[i];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
            return this;
          };

          XMLDocumentCB.prototype.dummy = function () {
            return this;
          };

          XMLDocumentCB.prototype.node = function (name, attributes, text) {
            var ref1;
            if (name == null) {
              throw new Error("Missing node name.");
            }
            if (this.root && this.currentLevel === -1) {
              throw new Error("Document can only have one root node. " + this.debugInfo(name));
            }
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              (ref1 = [attributes, text]), (text = ref1[0]), (attributes = ref1[1]);
            }
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) {
              this.text(text);
            }
            return this;
          };

          XMLDocumentCB.prototype.element = function (name, attributes, text) {
            var child, i, len, oldValidationFlag, ref1, root;
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              this.dtdElement.apply(this, arguments);
            } else {
              if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root = new XMLDocument(this.options).element("TEMP_ROOT");
                root.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root.children;
                for (i = 0, len = ref1.length; i < len; i++) {
                  child = ref1[i];
                  this.createChildNode(child);
                  if (child.type === NodeType.Element) {
                    this.up();
                  }
                }
              } else {
                this.node(name, attributes, text);
              }
            }
            return this;
          };

          XMLDocumentCB.prototype.attribute = function (name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) {
              throw new Error(
                "att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name)
              );
            }
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };

          XMLDocumentCB.prototype.text = function (value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.cdata = function (value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.comment = function (value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.raw = function (value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.instruction = function (target, value) {
            var i, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (i = 0, len = target.length; i < len; i++) {
                insTarget = target[i];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              node = new XMLProcessingInstruction(this, target, value);
              this.onData(
                this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1),
                this.currentLevel + 1
              );
            }
            return this;
          };

          XMLDocumentCB.prototype.declaration = function (version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) {
              throw new Error("declaration() must be the first node.");
            }
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(
              this.writer.declaration(node, this.writerOptions, this.currentLevel + 1),
              this.currentLevel + 1
            );
            return this;
          };

          XMLDocumentCB.prototype.doctype = function (root, pubID, sysID) {
            this.openCurrent();
            if (root == null) {
              throw new Error("Missing root node name.");
            }
            if (this.root) {
              throw new Error("dtd() must come before the root node.");
            }
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
          };

          XMLDocumentCB.prototype.dtdElement = function (name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.attList = function (
            elementName,
            attributeName,
            attributeType,
            defaultValueType,
            defaultValue
          ) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.entity = function (name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.pEntity = function (name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };

          XMLDocumentCB.prototype.notation = function (name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(
              this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1),
              this.currentLevel + 1
            );
            return this;
          };

          XMLDocumentCB.prototype.up = function () {
            if (this.currentLevel < 0) {
              throw new Error("The document node has no parent.");
            }
            if (this.currentNode) {
              if (this.currentNode.children) {
                this.closeNode(this.currentNode);
              } else {
                this.openNode(this.currentNode);
              }
              this.currentNode = null;
            } else {
              this.closeNode(this.openTags[this.currentLevel]);
            }
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
          };

          XMLDocumentCB.prototype.end = function () {
            while (this.currentLevel >= 0) {
              this.up();
            }
            return this.onEnd();
          };

          XMLDocumentCB.prototype.openCurrent = function () {
            if (this.currentNode) {
              this.currentNode.children = true;
              return this.openNode(this.currentNode);
            }
          };

          XMLDocumentCB.prototype.openNode = function (node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
              if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
                this.root = node;
              }
              chunk = "";
              if (node.type === NodeType.Element) {
                this.writerOptions.state = WriterState.OpenTag;
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
                ref1 = node.attribs;
                for (name in ref1) {
                  if (!hasProp.call(ref1, name)) continue;
                  att = ref1[name];
                  chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                }
                chunk +=
                  (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.OpenTag;
                chunk =
                  this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
                if (node.pubID && node.sysID) {
                  chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  chunk += ' SYSTEM "' + node.sysID + '"';
                }
                if (node.children) {
                  chunk += " [";
                  this.writerOptions.state = WriterState.InsideTag;
                } else {
                  this.writerOptions.state = WriterState.CloseTag;
                  chunk += ">";
                }
                chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.onData(chunk, this.currentLevel);
              return (node.isOpen = true);
            }
          };

          XMLDocumentCB.prototype.closeNode = function (node) {
            var chunk;
            if (!node.isClosed) {
              chunk = "";
              this.writerOptions.state = WriterState.CloseTag;
              if (node.type === NodeType.Element) {
                chunk =
                  this.writer.indent(node, this.writerOptions, this.currentLevel) +
                  "</" +
                  node.name +
                  ">" +
                  this.writer.endline(node, this.writerOptions, this.currentLevel);
              } else {
                chunk =
                  this.writer.indent(node, this.writerOptions, this.currentLevel) +
                  "]>" +
                  this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.writerOptions.state = WriterState.None;
              this.onData(chunk, this.currentLevel);
              return (node.isClosed = true);
            }
          };

          XMLDocumentCB.prototype.onData = function (chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
          };

          XMLDocumentCB.prototype.onEnd = function () {
            this.documentCompleted = true;
            return this.onEndCallback();
          };

          XMLDocumentCB.prototype.debugInfo = function (name) {
            if (name == null) {
              return "";
            } else {
              return "node: <" + name + ">";
            }
          };

          XMLDocumentCB.prototype.ele = function () {
            return this.element.apply(this, arguments);
          };

          XMLDocumentCB.prototype.nod = function (name, attributes, text) {
            return this.node(name, attributes, text);
          };

          XMLDocumentCB.prototype.txt = function (value) {
            return this.text(value);
          };

          XMLDocumentCB.prototype.dat = function (value) {
            return this.cdata(value);
          };

          XMLDocumentCB.prototype.com = function (value) {
            return this.comment(value);
          };

          XMLDocumentCB.prototype.ins = function (target, value) {
            return this.instruction(target, value);
          };

          XMLDocumentCB.prototype.dec = function (version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };

          XMLDocumentCB.prototype.dtd = function (root, pubID, sysID) {
            return this.doctype(root, pubID, sysID);
          };

          XMLDocumentCB.prototype.e = function (name, attributes, text) {
            return this.element(name, attributes, text);
          };

          XMLDocumentCB.prototype.n = function (name, attributes, text) {
            return this.node(name, attributes, text);
          };

          XMLDocumentCB.prototype.t = function (value) {
            return this.text(value);
          };

          XMLDocumentCB.prototype.d = function (value) {
            return this.cdata(value);
          };

          XMLDocumentCB.prototype.c = function (value) {
            return this.comment(value);
          };

          XMLDocumentCB.prototype.r = function (value) {
            return this.raw(value);
          };

          XMLDocumentCB.prototype.i = function (target, value) {
            return this.instruction(target, value);
          };

          XMLDocumentCB.prototype.att = function () {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };

          XMLDocumentCB.prototype.a = function () {
            if (this.currentNode && this.currentNode.type === NodeType.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };

          XMLDocumentCB.prototype.ent = function (name, value) {
            return this.entity(name, value);
          };

          XMLDocumentCB.prototype.pent = function (name, value) {
            return this.pEntity(name, value);
          };

          XMLDocumentCB.prototype.not = function (name, value) {
            return this.notation(name, value);
          };

          return XMLDocumentCB;
        })();
      }).call(this);

      /***/
    },

    /***/ 3590: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLDummy,
          XMLNode,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        module.exports = XMLDummy = (function (superClass) {
          extend(XMLDummy, superClass);

          function XMLDummy(parent) {
            XMLDummy.__super__.constructor.call(this, parent);
            this.type = NodeType.Dummy;
          }

          XMLDummy.prototype.clone = function () {
            return Object.create(this);
          };

          XMLDummy.prototype.toString = function (options) {
            return "";
          };

          return XMLDummy;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 9437: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLAttribute,
          XMLElement,
          XMLNamedNodeMap,
          XMLNode,
          getValue,
          isFunction,
          isObject,
          ref,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        (ref = __nccwpck_require__(8229)),
          (isObject = ref.isObject),
          (isFunction = ref.isFunction),
          (getValue = ref.getValue);

        XMLNode = __nccwpck_require__(7608);

        NodeType = __nccwpck_require__(9267);

        XMLAttribute = __nccwpck_require__(8376);

        XMLNamedNodeMap = __nccwpck_require__(4361);

        module.exports = XMLElement = (function (superClass) {
          extend(XMLElement, superClass);

          function XMLElement(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing element name. " + this.debugInfo());
            }
            this.name = this.stringify.name(name);
            this.type = NodeType.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) {
              this.attribute(attributes);
            }
            if (parent.type === NodeType.Document) {
              this.isRoot = true;
              this.documentObject = parent;
              parent.rootObject = this;
              if (parent.children) {
                ref1 = parent.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  if (child.type === NodeType.DocType) {
                    child.name = this.name;
                    break;
                  }
                }
              }
            }
          }

          Object.defineProperty(XMLElement.prototype, "tagName", {
            get: function () {
              return this.name;
            }
          });

          Object.defineProperty(XMLElement.prototype, "namespaceURI", {
            get: function () {
              return "";
            }
          });

          Object.defineProperty(XMLElement.prototype, "prefix", {
            get: function () {
              return "";
            }
          });

          Object.defineProperty(XMLElement.prototype, "localName", {
            get: function () {
              return this.name;
            }
          });

          Object.defineProperty(XMLElement.prototype, "id", {
            get: function () {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          Object.defineProperty(XMLElement.prototype, "className", {
            get: function () {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          Object.defineProperty(XMLElement.prototype, "classList", {
            get: function () {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          Object.defineProperty(XMLElement.prototype, "attributes", {
            get: function () {
              if (!this.attributeMap || !this.attributeMap.nodes) {
                this.attributeMap = new XMLNamedNodeMap(this.attribs);
              }
              return this.attributeMap;
            }
          });

          XMLElement.prototype.clone = function () {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) {
              clonedSelf.documentObject = null;
            }
            clonedSelf.attribs = {};
            ref1 = this.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName)) continue;
              att = ref1[attName];
              clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function (child) {
              var clonedChild;
              clonedChild = child.clone();
              clonedChild.parent = clonedSelf;
              return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
          };

          XMLElement.prototype.attribute = function (name, value) {
            var attName, attValue;
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };

          XMLElement.prototype.removeAttribute = function (name) {
            var attName, j, len;
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo());
            }
            name = getValue(name);
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                attName = name[j];
                delete this.attribs[attName];
              }
            } else {
              delete this.attribs[name];
            }
            return this;
          };

          XMLElement.prototype.toString = function (options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
          };

          XMLElement.prototype.att = function (name, value) {
            return this.attribute(name, value);
          };

          XMLElement.prototype.a = function (name, value) {
            return this.attribute(name, value);
          };

          XMLElement.prototype.getAttribute = function (name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].value;
            } else {
              return null;
            }
          };

          XMLElement.prototype.setAttribute = function (name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getAttributeNode = function (name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name];
            } else {
              return null;
            }
          };

          XMLElement.prototype.setAttributeNode = function (newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.removeAttributeNode = function (oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getElementsByTagName = function (name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getAttributeNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.setAttributeNS = function (namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.removeAttributeNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getAttributeNodeNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.setAttributeNodeNS = function (newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.hasAttribute = function (name) {
            return this.attribs.hasOwnProperty(name);
          };

          XMLElement.prototype.hasAttributeNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.setIdAttribute = function (name, isId) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].isId;
            } else {
              return isId;
            }
          };

          XMLElement.prototype.setIdAttributeNS = function (namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.setIdAttributeNode = function (idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getElementsByTagName = function (tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getElementsByTagNameNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.getElementsByClassName = function (classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLElement.prototype.isEqualNode = function (node) {
            var i, j, ref1;
            if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.attribs.length !== this.attribs.length) {
              return false;
            }
            for (
              i = j = 0, ref1 = this.attribs.length - 1;
              0 <= ref1 ? j <= ref1 : j >= ref1;
              i = 0 <= ref1 ? ++j : --j
            ) {
              if (!this.attribs[i].isEqualNode(node.attribs[i])) {
                return false;
              }
            }
            return true;
          };

          return XMLElement;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 4361: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLNamedNodeMap;

        module.exports = XMLNamedNodeMap = (function () {
          function XMLNamedNodeMap(nodes) {
            this.nodes = nodes;
          }

          Object.defineProperty(XMLNamedNodeMap.prototype, "length", {
            get: function () {
              return Object.keys(this.nodes).length || 0;
            }
          });

          XMLNamedNodeMap.prototype.clone = function () {
            return (this.nodes = null);
          };

          XMLNamedNodeMap.prototype.getNamedItem = function (name) {
            return this.nodes[name];
          };

          XMLNamedNodeMap.prototype.setNamedItem = function (node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
          };

          XMLNamedNodeMap.prototype.removeNamedItem = function (name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
          };

          XMLNamedNodeMap.prototype.item = function (index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
          };

          XMLNamedNodeMap.prototype.getNamedItemNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };

          XMLNamedNodeMap.prototype.setNamedItemNS = function (node) {
            throw new Error("This DOM method is not implemented.");
          };

          XMLNamedNodeMap.prototype.removeNamedItemNS = function (namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };

          return XMLNamedNodeMap;
        })();
      }).call(this);

      /***/
    },

    /***/ 7608: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var DocumentPosition,
          NodeType,
          XMLCData,
          XMLComment,
          XMLDeclaration,
          XMLDocType,
          XMLDummy,
          XMLElement,
          XMLNamedNodeMap,
          XMLNode,
          XMLNodeList,
          XMLProcessingInstruction,
          XMLRaw,
          XMLText,
          getValue,
          isEmpty,
          isFunction,
          isObject,
          ref1,
          hasProp = {}.hasOwnProperty;

        (ref1 = __nccwpck_require__(8229)),
          (isObject = ref1.isObject),
          (isFunction = ref1.isFunction),
          (isEmpty = ref1.isEmpty),
          (getValue = ref1.getValue);

        XMLElement = null;

        XMLCData = null;

        XMLComment = null;

        XMLDeclaration = null;

        XMLDocType = null;

        XMLRaw = null;

        XMLText = null;

        XMLProcessingInstruction = null;

        XMLDummy = null;

        NodeType = null;

        XMLNodeList = null;

        XMLNamedNodeMap = null;

        DocumentPosition = null;

        module.exports = XMLNode = (function () {
          function XMLNode(parent1) {
            this.parent = parent1;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
              XMLElement = __nccwpck_require__(9437);
              XMLCData = __nccwpck_require__(333);
              XMLComment = __nccwpck_require__(4407);
              XMLDeclaration = __nccwpck_require__(6364);
              XMLDocType = __nccwpck_require__(1801);
              XMLRaw = __nccwpck_require__(6329);
              XMLText = __nccwpck_require__(1318);
              XMLProcessingInstruction = __nccwpck_require__(6939);
              XMLDummy = __nccwpck_require__(3590);
              NodeType = __nccwpck_require__(9267);
              XMLNodeList = __nccwpck_require__(6768);
              XMLNamedNodeMap = __nccwpck_require__(4361);
              DocumentPosition = __nccwpck_require__(2839);
            }
          }

          Object.defineProperty(XMLNode.prototype, "nodeName", {
            get: function () {
              return this.name;
            }
          });

          Object.defineProperty(XMLNode.prototype, "nodeType", {
            get: function () {
              return this.type;
            }
          });

          Object.defineProperty(XMLNode.prototype, "nodeValue", {
            get: function () {
              return this.value;
            }
          });

          Object.defineProperty(XMLNode.prototype, "parentNode", {
            get: function () {
              return this.parent;
            }
          });

          Object.defineProperty(XMLNode.prototype, "childNodes", {
            get: function () {
              if (!this.childNodeList || !this.childNodeList.nodes) {
                this.childNodeList = new XMLNodeList(this.children);
              }
              return this.childNodeList;
            }
          });

          Object.defineProperty(XMLNode.prototype, "firstChild", {
            get: function () {
              return this.children[0] || null;
            }
          });

          Object.defineProperty(XMLNode.prototype, "lastChild", {
            get: function () {
              return this.children[this.children.length - 1] || null;
            }
          });

          Object.defineProperty(XMLNode.prototype, "previousSibling", {
            get: function () {
              var i;
              i = this.parent.children.indexOf(this);
              return this.parent.children[i - 1] || null;
            }
          });

          Object.defineProperty(XMLNode.prototype, "nextSibling", {
            get: function () {
              var i;
              i = this.parent.children.indexOf(this);
              return this.parent.children[i + 1] || null;
            }
          });

          Object.defineProperty(XMLNode.prototype, "ownerDocument", {
            get: function () {
              return this.document() || null;
            }
          });

          Object.defineProperty(XMLNode.prototype, "textContent", {
            get: function () {
              var child, j, len, ref2, str;
              if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
                str = "";
                ref2 = this.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                  child = ref2[j];
                  if (child.textContent) {
                    str += child.textContent;
                  }
                }
                return str;
              } else {
                return null;
              }
            },
            set: function (value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          XMLNode.prototype.setParent = function (parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
              this.options = parent.options;
              this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              results.push(child.setParent(this));
            }
            return results;
          };

          XMLNode.prototype.element = function (name, attributes, text) {
            var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) {
              (ref2 = [{}, null]), (attributes = ref2[0]), (text = ref2[1]);
            }
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              (ref3 = [attributes, text]), (text = ref3[0]), (attributes = ref3[1]);
            }
            if (name != null) {
              name = getValue(name);
            }
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                item = name[j];
                lastChild = this.element(item);
              }
            } else if (isFunction(name)) {
              lastChild = this.element(name.apply());
            } else if (isObject(name)) {
              for (key in name) {
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) {
                  val = val.apply();
                }
                if (
                  !this.options.ignoreDecorators &&
                  this.stringify.convertAttKey &&
                  key.indexOf(this.stringify.convertAttKey) === 0
                ) {
                  lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                  lastChild = this.dummy();
                } else if (isObject(val) && isEmpty(val)) {
                  lastChild = this.element(key);
                } else if (!this.options.keepNullNodes && val == null) {
                  lastChild = this.dummy();
                } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                  for (k = 0, len1 = val.length; k < len1; k++) {
                    item = val[k];
                    childNode = {};
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                  }
                } else if (isObject(val)) {
                  if (
                    !this.options.ignoreDecorators &&
                    this.stringify.convertTextKey &&
                    key.indexOf(this.stringify.convertTextKey) === 0
                  ) {
                    lastChild = this.element(val);
                  } else {
                    lastChild = this.element(key);
                    lastChild.element(val);
                  }
                } else {
                  lastChild = this.element(key, val);
                }
              }
            } else if (!this.options.keepNullNodes && text === null) {
              lastChild = this.dummy();
            } else {
              if (
                !this.options.ignoreDecorators &&
                this.stringify.convertTextKey &&
                name.indexOf(this.stringify.convertTextKey) === 0
              ) {
                lastChild = this.text(text);
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertCDataKey &&
                name.indexOf(this.stringify.convertCDataKey) === 0
              ) {
                lastChild = this.cdata(text);
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertCommentKey &&
                name.indexOf(this.stringify.convertCommentKey) === 0
              ) {
                lastChild = this.comment(text);
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertRawKey &&
                name.indexOf(this.stringify.convertRawKey) === 0
              ) {
                lastChild = this.raw(text);
              } else if (
                !this.options.ignoreDecorators &&
                this.stringify.convertPIKey &&
                name.indexOf(this.stringify.convertPIKey) === 0
              ) {
                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
              } else {
                lastChild = this.node(name, attributes, text);
              }
            }
            if (lastChild == null) {
              throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            }
            return lastChild;
          };

          XMLNode.prototype.insertBefore = function (name, attributes, text) {
            var child, i, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
              newChild = name;
              refChild = attributes;
              newChild.setParent(this);
              if (refChild) {
                i = children.indexOf(refChild);
                removed = children.splice(i);
                children.push(newChild);
                Array.prototype.push.apply(children, removed);
              } else {
                children.push(newChild);
              }
              return newChild;
            } else {
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
              }
              i = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            }
          };

          XMLNode.prototype.insertAfter = function (name, attributes, text) {
            var child, i, removed;
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          };

          XMLNode.prototype.remove = function () {
            var i, ref2;
            if (this.isRoot) {
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            }
            i = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [i, i - i + 1].concat((ref2 = []))), ref2;
            return this.parent;
          };

          XMLNode.prototype.node = function (name, attributes, text) {
            var child, ref2;
            if (name != null) {
              name = getValue(name);
            }
            attributes || (attributes = {});
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              (ref2 = [attributes, text]), (text = ref2[0]), (attributes = ref2[1]);
            }
            child = new XMLElement(this, name, attributes);
            if (text != null) {
              child.text(text);
            }
            this.children.push(child);
            return child;
          };

          XMLNode.prototype.text = function (value) {
            var child;
            if (isObject(value)) {
              this.element(value);
            }
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
          };

          XMLNode.prototype.cdata = function (value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
          };

          XMLNode.prototype.comment = function (value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
          };

          XMLNode.prototype.commentBefore = function (value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };

          XMLNode.prototype.commentAfter = function (value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };

          XMLNode.prototype.raw = function (value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
          };

          XMLNode.prototype.dummy = function () {
            var child;
            child = new XMLDummy(this);
            return child;
          };

          XMLNode.prototype.instruction = function (target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (j = 0, len = target.length; j < len; j++) {
                insTarget = target[j];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              instruction = new XMLProcessingInstruction(this, target, value);
              this.children.push(instruction);
            }
            return this;
          };

          XMLNode.prototype.instructionBefore = function (target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };

          XMLNode.prototype.instructionAfter = function (target, value) {
            var child, i, removed;
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };

          XMLNode.prototype.declaration = function (version, encoding, standalone) {
            var doc, xmldec;
            doc = this.document();
            xmldec = new XMLDeclaration(doc, version, encoding, standalone);
            if (doc.children.length === 0) {
              doc.children.unshift(xmldec);
            } else if (doc.children[0].type === NodeType.Declaration) {
              doc.children[0] = xmldec;
            } else {
              doc.children.unshift(xmldec);
            }
            return doc.root() || doc;
          };

          XMLNode.prototype.dtd = function (pubID, sysID) {
            var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
            doc = this.document();
            doctype = new XMLDocType(doc, pubID, sysID);
            ref2 = doc.children;
            for (i = j = 0, len = ref2.length; j < len; i = ++j) {
              child = ref2[i];
              if (child.type === NodeType.DocType) {
                doc.children[i] = doctype;
                return doctype;
              }
            }
            ref3 = doc.children;
            for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
              child = ref3[i];
              if (child.isRoot) {
                doc.children.splice(i, 0, doctype);
                return doctype;
              }
            }
            doc.children.push(doctype);
            return doctype;
          };

          XMLNode.prototype.up = function () {
            if (this.isRoot) {
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            }
            return this.parent;
          };

          XMLNode.prototype.root = function () {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node.rootObject;
              } else if (node.isRoot) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };

          XMLNode.prototype.document = function () {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType.Document) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };

          XMLNode.prototype.end = function (options) {
            return this.document().end(options);
          };

          XMLNode.prototype.prev = function () {
            var i;
            i = this.parent.children.indexOf(this);
            if (i < 1) {
              throw new Error("Already at the first node. " + this.debugInfo());
            }
            return this.parent.children[i - 1];
          };

          XMLNode.prototype.next = function () {
            var i;
            i = this.parent.children.indexOf(this);
            if (i === -1 || i === this.parent.children.length - 1) {
              throw new Error("Already at the last node. " + this.debugInfo());
            }
            return this.parent.children[i + 1];
          };

          XMLNode.prototype.importDocument = function (doc) {
            var clonedRoot;
            clonedRoot = doc.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
          };

          XMLNode.prototype.debugInfo = function (name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
              return "";
            } else if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
              return "node: <" + name + ">";
            } else {
              return "node: <" + name + ">, parent: <" + this.parent.name + ">";
            }
          };

          XMLNode.prototype.ele = function (name, attributes, text) {
            return this.element(name, attributes, text);
          };

          XMLNode.prototype.nod = function (name, attributes, text) {
            return this.node(name, attributes, text);
          };

          XMLNode.prototype.txt = function (value) {
            return this.text(value);
          };

          XMLNode.prototype.dat = function (value) {
            return this.cdata(value);
          };

          XMLNode.prototype.com = function (value) {
            return this.comment(value);
          };

          XMLNode.prototype.ins = function (target, value) {
            return this.instruction(target, value);
          };

          XMLNode.prototype.doc = function () {
            return this.document();
          };

          XMLNode.prototype.dec = function (version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };

          XMLNode.prototype.e = function (name, attributes, text) {
            return this.element(name, attributes, text);
          };

          XMLNode.prototype.n = function (name, attributes, text) {
            return this.node(name, attributes, text);
          };

          XMLNode.prototype.t = function (value) {
            return this.text(value);
          };

          XMLNode.prototype.d = function (value) {
            return this.cdata(value);
          };

          XMLNode.prototype.c = function (value) {
            return this.comment(value);
          };

          XMLNode.prototype.r = function (value) {
            return this.raw(value);
          };

          XMLNode.prototype.i = function (target, value) {
            return this.instruction(target, value);
          };

          XMLNode.prototype.u = function () {
            return this.up();
          };

          XMLNode.prototype.importXMLBuilder = function (doc) {
            return this.importDocument(doc);
          };

          XMLNode.prototype.replaceChild = function (newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.removeChild = function (oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.appendChild = function (newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.hasChildNodes = function () {
            return this.children.length !== 0;
          };

          XMLNode.prototype.cloneNode = function (deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.normalize = function () {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.isSupported = function (feature, version) {
            return true;
          };

          XMLNode.prototype.hasAttributes = function () {
            return this.attribs.length !== 0;
          };

          XMLNode.prototype.compareDocumentPosition = function (other) {
            var ref, res;
            ref = this;
            if (ref === other) {
              return 0;
            } else if (this.document() !== other.document()) {
              res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
              if (Math.random() < 0.5) {
                res |= DocumentPosition.Preceding;
              } else {
                res |= DocumentPosition.Following;
              }
              return res;
            } else if (ref.isAncestor(other)) {
              return DocumentPosition.Contains | DocumentPosition.Preceding;
            } else if (ref.isDescendant(other)) {
              return DocumentPosition.Contains | DocumentPosition.Following;
            } else if (ref.isPreceding(other)) {
              return DocumentPosition.Preceding;
            } else {
              return DocumentPosition.Following;
            }
          };

          XMLNode.prototype.isSameNode = function (other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.lookupPrefix = function (namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.isDefaultNamespace = function (namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.lookupNamespaceURI = function (prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.isEqualNode = function (node) {
            var i, j, ref2;
            if (node.nodeType !== this.nodeType) {
              return false;
            }
            if (node.children.length !== this.children.length) {
              return false;
            }
            for (
              i = j = 0, ref2 = this.children.length - 1;
              0 <= ref2 ? j <= ref2 : j >= ref2;
              i = 0 <= ref2 ? ++j : --j
            ) {
              if (!this.children[i].isEqualNode(node.children[i])) {
                return false;
              }
            }
            return true;
          };

          XMLNode.prototype.getFeature = function (feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.setUserData = function (key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.getUserData = function (key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLNode.prototype.contains = function (other) {
            if (!other) {
              return false;
            }
            return other === this || this.isDescendant(other);
          };

          XMLNode.prototype.isDescendant = function (node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (node === child) {
                return true;
              }
              isDescendantChild = child.isDescendant(node);
              if (isDescendantChild) {
                return true;
              }
            }
            return false;
          };

          XMLNode.prototype.isAncestor = function (node) {
            return node.isDescendant(this);
          };

          XMLNode.prototype.isPreceding = function (node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos < thisPos;
            }
          };

          XMLNode.prototype.isFollowing = function (node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos > thisPos;
            }
          };

          XMLNode.prototype.treePosition = function (node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function (childNode) {
              pos++;
              if (!found && childNode === node) {
                return (found = true);
              }
            });
            if (found) {
              return pos;
            } else {
              return -1;
            }
          };

          XMLNode.prototype.foreachTreeNode = function (node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if ((res = func(child))) {
                return res;
              } else {
                res = this.foreachTreeNode(child, func);
                if (res) {
                  return res;
                }
              }
            }
          };

          return XMLNode;
        })();
      }).call(this);

      /***/
    },

    /***/ 6768: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLNodeList;

        module.exports = XMLNodeList = (function () {
          function XMLNodeList(nodes) {
            this.nodes = nodes;
          }

          Object.defineProperty(XMLNodeList.prototype, "length", {
            get: function () {
              return this.nodes.length || 0;
            }
          });

          XMLNodeList.prototype.clone = function () {
            return (this.nodes = null);
          };

          XMLNodeList.prototype.item = function (index) {
            return this.nodes[index] || null;
          };

          return XMLNodeList;
        })();
      }).call(this);

      /***/
    },

    /***/ 6939: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLCharacterData,
          XMLProcessingInstruction,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLCharacterData = __nccwpck_require__(7709);

        module.exports = XMLProcessingInstruction = (function (superClass) {
          extend(XMLProcessingInstruction, superClass);

          function XMLProcessingInstruction(parent, target, value) {
            XMLProcessingInstruction.__super__.constructor.call(this, parent);
            if (target == null) {
              throw new Error("Missing instruction target. " + this.debugInfo());
            }
            this.type = NodeType.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) {
              this.value = this.stringify.insValue(value);
            }
          }

          XMLProcessingInstruction.prototype.clone = function () {
            return Object.create(this);
          };

          XMLProcessingInstruction.prototype.toString = function (options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
          };

          XMLProcessingInstruction.prototype.isEqualNode = function (node) {
            if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.target !== this.target) {
              return false;
            }
            return true;
          };

          return XMLProcessingInstruction;
        })(XMLCharacterData);
      }).call(this);

      /***/
    },

    /***/ 6329: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLNode,
          XMLRaw,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLNode = __nccwpck_require__(7608);

        module.exports = XMLRaw = (function (superClass) {
          extend(XMLRaw, superClass);

          function XMLRaw(parent, text) {
            XMLRaw.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing raw text. " + this.debugInfo());
            }
            this.type = NodeType.Raw;
            this.value = this.stringify.raw(text);
          }

          XMLRaw.prototype.clone = function () {
            return Object.create(this);
          };

          XMLRaw.prototype.toString = function (options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
          };

          return XMLRaw;
        })(XMLNode);
      }).call(this);

      /***/
    },

    /***/ 8601: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          WriterState,
          XMLStreamWriter,
          XMLWriterBase,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLWriterBase = __nccwpck_require__(6752);

        WriterState = __nccwpck_require__(9766);

        module.exports = XMLStreamWriter = (function (superClass) {
          extend(XMLStreamWriter, superClass);

          function XMLStreamWriter(stream, options) {
            this.stream = stream;
            XMLStreamWriter.__super__.constructor.call(this, options);
          }

          XMLStreamWriter.prototype.endline = function (node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) {
              return "";
            } else {
              return XMLStreamWriter.__super__.endline.call(this, node, options, level);
            }
          };

          XMLStreamWriter.prototype.document = function (doc, options) {
            var child, i, j, k, len, len1, ref, ref1, results;
            ref = doc.children;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              child = ref[i];
              child.isLastRootNode = i === doc.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc.children;
            results = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              child = ref1[k];
              results.push(this.writeChildNode(child, options, 0));
            }
            return results;
          };

          XMLStreamWriter.prototype.attribute = function (att, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));
          };

          XMLStreamWriter.prototype.cdata = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.comment = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.declaration = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.docType = function (node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write("<!DOCTYPE " + node.root().name);
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.children.length > 0) {
              this.stream.write(" [");
              this.stream.write(this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (j = 0, len = ref.length; j < len; j++) {
                child = ref[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write("]");
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + ">");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };

          XMLStreamWriter.prototype.element = function (node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + "<" + node.name);
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (
              childNodeCount === 0 ||
              node.children.every(function (e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
              })
            ) {
              if (options.allowEmpty) {
                this.stream.write(">");
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node.name + ">");
              } else {
                options.state = WriterState.CloseTag;
                this.stream.write(options.spaceBeforeSlash + "/>");
              }
            } else if (
              options.pretty &&
              childNodeCount === 1 &&
              (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) &&
              firstChildNode.value != null
            ) {
              this.stream.write(">");
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              this.stream.write(">" + this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref1 = node.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };

          XMLStreamWriter.prototype.processingInstruction = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.raw = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.text = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.dtdAttList = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.dtdElement = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.dtdEntity = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));
          };

          XMLStreamWriter.prototype.dtdNotation = function (node, options, level) {
            return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));
          };

          return XMLStreamWriter;
        })(XMLWriterBase);
      }).call(this);

      /***/
    },

    /***/ 5913: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLStringWriter,
          XMLWriterBase,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        XMLWriterBase = __nccwpck_require__(6752);

        module.exports = XMLStringWriter = (function (superClass) {
          extend(XMLStringWriter, superClass);

          function XMLStringWriter(options) {
            XMLStringWriter.__super__.constructor.call(this, options);
          }

          XMLStringWriter.prototype.document = function (doc, options) {
            var child, i, len, r, ref;
            options = this.filterOptions(options);
            r = "";
            ref = doc.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r.slice(-options.newline.length) === options.newline) {
              r = r.slice(0, -options.newline.length);
            }
            return r;
          };

          return XMLStringWriter;
        })(XMLWriterBase);
      }).call(this);

      /***/
    },

    /***/ 8594: /***/ function (module) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var XMLStringifier,
          bind = function (fn, me) {
            return function () {
              return fn.apply(me, arguments);
            };
          },
          hasProp = {}.hasOwnProperty;

        module.exports = XMLStringifier = (function () {
          function XMLStringifier(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {});
            this.options = options;
            if (!this.options.version) {
              this.options.version = "1.0";
            }
            ref = options.stringify || {};
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this[key] = value;
            }
          }

          XMLStringifier.prototype.name = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalName("" + val || "");
          };

          XMLStringifier.prototype.text = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.textEscape("" + val || ""));
          };

          XMLStringifier.prototype.cdata = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
          };

          XMLStringifier.prototype.comment = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/--/)) {
              throw new Error("Comment text cannot contain double-hypen: " + val);
            }
            return this.assertLegalChar(val);
          };

          XMLStringifier.prototype.raw = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return "" + val || "";
          };

          XMLStringifier.prototype.attValue = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.attEscape((val = "" + val || "")));
          };

          XMLStringifier.prototype.insTarget = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.insValue = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/\?>/)) {
              throw new Error("Invalid processing instruction value: " + val);
            }
            return this.assertLegalChar(val);
          };

          XMLStringifier.prototype.xmlVersion = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) {
              throw new Error("Invalid version number: " + val);
            }
            return val;
          };

          XMLStringifier.prototype.xmlEncoding = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
              throw new Error("Invalid encoding: " + val);
            }
            return this.assertLegalChar(val);
          };

          XMLStringifier.prototype.xmlStandalone = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            if (val) {
              return "yes";
            } else {
              return "no";
            }
          };

          XMLStringifier.prototype.dtdPubID = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdSysID = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdElementValue = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdAttType = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdAttDefault = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdEntityValue = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.dtdNData = function (val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };

          XMLStringifier.prototype.convertAttKey = "@";

          XMLStringifier.prototype.convertPIKey = "?";

          XMLStringifier.prototype.convertTextKey = "#text";

          XMLStringifier.prototype.convertCDataKey = "#cdata";

          XMLStringifier.prototype.convertCommentKey = "#comment";

          XMLStringifier.prototype.convertRawKey = "#raw";

          XMLStringifier.prototype.assertLegalChar = function (str) {
            var regex, res;
            if (this.options.noValidation) {
              return str;
            }
            regex = "";
            if (this.options.version === "1.0") {
              regex =
                /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if ((res = str.match(regex))) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            } else if (this.options.version === "1.1") {
              regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if ((res = str.match(regex))) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            }
            return str;
          };

          XMLStringifier.prototype.assertLegalName = function (str) {
            var regex;
            if (this.options.noValidation) {
              return str;
            }
            this.assertLegalChar(str);
            regex =
              /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) {
              throw new Error("Invalid character in name");
            }
            return str;
          };

          XMLStringifier.prototype.textEscape = function (str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          };

          XMLStringifier.prototype.attEscape = function (str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str
              .replace(ampregex, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/"/g, "&quot;")
              .replace(/\t/g, "&#x9;")
              .replace(/\n/g, "&#xA;")
              .replace(/\r/g, "&#xD;");
          };

          return XMLStringifier;
        })();
      }).call(this);

      /***/
    },

    /***/ 1318: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          XMLCharacterData,
          XMLText,
          extend = function (child, parent) {
            for (var key in parent) {
              if (hasProp.call(parent, key)) child[key] = parent[key];
            }
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
          },
          hasProp = {}.hasOwnProperty;

        NodeType = __nccwpck_require__(9267);

        XMLCharacterData = __nccwpck_require__(7709);

        module.exports = XMLText = (function (superClass) {
          extend(XMLText, superClass);

          function XMLText(parent, text) {
            XMLText.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing element text. " + this.debugInfo());
            }
            this.name = "#text";
            this.type = NodeType.Text;
            this.value = this.stringify.text(text);
          }

          Object.defineProperty(XMLText.prototype, "isElementContentWhitespace", {
            get: function () {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });

          Object.defineProperty(XMLText.prototype, "wholeText", {
            get: function () {
              var next, prev, str;
              str = "";
              prev = this.previousSibling;
              while (prev) {
                str = prev.data + str;
                prev = prev.previousSibling;
              }
              str += this.data;
              next = this.nextSibling;
              while (next) {
                str = str + next.data;
                next = next.nextSibling;
              }
              return str;
            }
          });

          XMLText.prototype.clone = function () {
            return Object.create(this);
          };

          XMLText.prototype.toString = function (options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
          };

          XMLText.prototype.splitText = function (offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          XMLText.prototype.replaceWholeText = function (content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };

          return XMLText;
        })(XMLCharacterData);
      }).call(this);

      /***/
    },

    /***/ 6752: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          WriterState,
          XMLCData,
          XMLComment,
          XMLDTDAttList,
          XMLDTDElement,
          XMLDTDEntity,
          XMLDTDNotation,
          XMLDeclaration,
          XMLDocType,
          XMLDummy,
          XMLElement,
          XMLProcessingInstruction,
          XMLRaw,
          XMLText,
          XMLWriterBase,
          assign,
          hasProp = {}.hasOwnProperty;

        assign = __nccwpck_require__(8229).assign;

        NodeType = __nccwpck_require__(9267);

        XMLDeclaration = __nccwpck_require__(6364);

        XMLDocType = __nccwpck_require__(1801);

        XMLCData = __nccwpck_require__(333);

        XMLComment = __nccwpck_require__(4407);

        XMLElement = __nccwpck_require__(9437);

        XMLRaw = __nccwpck_require__(6329);

        XMLText = __nccwpck_require__(1318);

        XMLProcessingInstruction = __nccwpck_require__(6939);

        XMLDummy = __nccwpck_require__(3590);

        XMLDTDAttList = __nccwpck_require__(1015);

        XMLDTDElement = __nccwpck_require__(2421);

        XMLDTDEntity = __nccwpck_require__(53);

        XMLDTDNotation = __nccwpck_require__(2837);

        WriterState = __nccwpck_require__(9766);

        module.exports = XMLWriterBase = (function () {
          function XMLWriterBase(options) {
            var key, ref, value;
            options || (options = {});
            this.options = options;
            ref = options.writer || {};
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this["_" + key] = this[key];
              this[key] = value;
            }
          }

          XMLWriterBase.prototype.filterOptions = function (options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {});
            options = assign({}, this.options, options);
            filteredOptions = {
              writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes =
              (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null
                ? ref3
                : 0;
            filteredOptions.spaceBeforeSlash =
              (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
            if (filteredOptions.spaceBeforeSlash === true) {
              filteredOptions.spaceBeforeSlash = " ";
            }
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {};
            filteredOptions.state = WriterState.None;
            return filteredOptions;
          };

          XMLWriterBase.prototype.indent = function (node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else if (options.pretty) {
              indentLevel = (level || 0) + options.offset + 1;
              if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
              }
            }
            return "";
          };

          XMLWriterBase.prototype.endline = function (node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else {
              return options.newline;
            }
          };

          XMLWriterBase.prototype.attribute = function (att, options, level) {
            var r;
            this.openAttribute(att, options, level);
            r = " " + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r;
          };

          XMLWriterBase.prototype.cdata = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<![CDATA[";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += "]]>" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.comment = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!-- ";
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += " -->" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.declaration = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?xml";
            options.state = WriterState.InsideTag;
            r += ' version="' + node.version + '"';
            if (node.encoding != null) {
              r += ' encoding="' + node.encoding + '"';
            }
            if (node.standalone != null) {
              r += ' standalone="' + node.standalone + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.docType = function (node, options, level) {
            var child, i, len, r, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            r += "<!DOCTYPE " + node.root().name;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children.length > 0) {
              r += " [";
              r += this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (i = 0, len = ref.length; i < len; i++) {
                child = ref[i];
                r += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r += "]";
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.element = function (node, options, level) {
            var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r = "";
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r += this.indent(node, options, level) + "<" + node.name;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              r += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (
              childNodeCount === 0 ||
              node.children.every(function (e) {
                return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
              })
            ) {
              if (options.allowEmpty) {
                r += ">";
                options.state = WriterState.CloseTag;
                r += "</" + node.name + ">" + this.endline(node, options, level);
              } else {
                options.state = WriterState.CloseTag;
                r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
              }
            } else if (
              options.pretty &&
              childNodeCount === 1 &&
              (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) &&
              firstChildNode.value != null
            ) {
              r += ">";
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              r += this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              if (options.dontPrettyTextNodes) {
                ref1 = node.children;
                for (i = 0, len = ref1.length; i < len; i++) {
                  child = ref1[i];
                  if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                    options.suppressPrettyCount++;
                    prettySuppressed = true;
                    break;
                  }
                }
              }
              r += ">" + this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref2 = node.children;
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                child = ref2[j];
                r += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r += this.indent(node, options, level) + "</" + node.name + ">";
              if (prettySuppressed) {
                options.suppressPrettyCount--;
              }
              r += this.endline(node, options, level);
              options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.writeChildNode = function (node, options, level) {
            switch (node.type) {
              case NodeType.CData:
                return this.cdata(node, options, level);
              case NodeType.Comment:
                return this.comment(node, options, level);
              case NodeType.Element:
                return this.element(node, options, level);
              case NodeType.Raw:
                return this.raw(node, options, level);
              case NodeType.Text:
                return this.text(node, options, level);
              case NodeType.ProcessingInstruction:
                return this.processingInstruction(node, options, level);
              case NodeType.Dummy:
                return "";
              case NodeType.Declaration:
                return this.declaration(node, options, level);
              case NodeType.DocType:
                return this.docType(node, options, level);
              case NodeType.AttributeDeclaration:
                return this.dtdAttList(node, options, level);
              case NodeType.ElementDeclaration:
                return this.dtdElement(node, options, level);
              case NodeType.EntityDeclaration:
                return this.dtdEntity(node, options, level);
              case NodeType.NotationDeclaration:
                return this.dtdNotation(node, options, level);
              default:
                throw new Error("Unknown XML node type: " + node.constructor.name);
            }
          };

          XMLWriterBase.prototype.processingInstruction = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<?";
            options.state = WriterState.InsideTag;
            r += node.target;
            if (node.value) {
              r += " " + node.value;
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + "?>";
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.raw = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.text = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r += node.value;
            options.state = WriterState.CloseTag;
            r += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.dtdAttList = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ATTLIST";
            options.state = WriterState.InsideTag;
            r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
            if (node.defaultValueType !== "#DEFAULT") {
              r += " " + node.defaultValueType;
            }
            if (node.defaultValue) {
              r += ' "' + node.defaultValue + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.dtdElement = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ELEMENT";
            options.state = WriterState.InsideTag;
            r += " " + node.name + " " + node.value;
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.dtdEntity = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!ENTITY";
            options.state = WriterState.InsideTag;
            if (node.pe) {
              r += " %";
            }
            r += " " + node.name;
            if (node.value) {
              r += ' "' + node.value + '"';
            } else {
              if (node.pubID && node.sysID) {
                r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                r += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.nData) {
                r += " NDATA " + node.nData;
              }
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.dtdNotation = function (node, options, level) {
            var r;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r = this.indent(node, options, level) + "<!NOTATION";
            options.state = WriterState.InsideTag;
            r += " " + node.name;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.pubID) {
              r += ' PUBLIC "' + node.pubID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            options.state = WriterState.CloseTag;
            r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r;
          };

          XMLWriterBase.prototype.openNode = function (node, options, level) {};

          XMLWriterBase.prototype.closeNode = function (node, options, level) {};

          XMLWriterBase.prototype.openAttribute = function (att, options, level) {};

          XMLWriterBase.prototype.closeAttribute = function (att, options, level) {};

          return XMLWriterBase;
        })();
      }).call(this);

      /***/
    },

    /***/ 2958: /***/ function (module, __unused_webpack_exports, __nccwpck_require__) {
      // Generated by CoffeeScript 1.12.7
      (function () {
        var NodeType,
          WriterState,
          XMLDOMImplementation,
          XMLDocument,
          XMLDocumentCB,
          XMLStreamWriter,
          XMLStringWriter,
          assign,
          isFunction,
          ref;

        (ref = __nccwpck_require__(8229)), (assign = ref.assign), (isFunction = ref.isFunction);

        XMLDOMImplementation = __nccwpck_require__(8310);

        XMLDocument = __nccwpck_require__(3730);

        XMLDocumentCB = __nccwpck_require__(7356);

        XMLStringWriter = __nccwpck_require__(5913);

        XMLStreamWriter = __nccwpck_require__(8601);

        NodeType = __nccwpck_require__(9267);

        WriterState = __nccwpck_require__(9766);

        module.exports.create = function (name, xmldec, doctype, options) {
          var doc, root;
          if (name == null) {
            throw new Error("Root element needs a name.");
          }
          options = assign({}, xmldec, doctype, options);
          doc = new XMLDocument(options);
          root = doc.element(name);
          if (!options.headless) {
            doc.declaration(options);
            if (options.pubID != null || options.sysID != null) {
              doc.dtd(options);
            }
          }
          return root;
        };

        module.exports.begin = function (options, onData, onEnd) {
          var ref1;
          if (isFunction(options)) {
            (ref1 = [options, onData]), (onData = ref1[0]), (onEnd = ref1[1]);
            options = {};
          }
          if (onData) {
            return new XMLDocumentCB(options, onData, onEnd);
          } else {
            return new XMLDocument(options);
          }
        };

        module.exports.stringWriter = function (options) {
          return new XMLStringWriter(options);
        };

        module.exports.streamWriter = function (stream, options) {
          return new XMLStreamWriter(stream, options);
        };

        module.exports.implementation = new XMLDOMImplementation();

        module.exports.nodeType = NodeType;

        module.exports.writerState = WriterState;
      }).call(this);

      /***/
    },

    /***/ 9352: /***/ (module) => {
      module.exports = eval("require")("proxy-agent");

      /***/
    },

    /***/ 9491: /***/ (module) => {
      "use strict";
      module.exports = require("assert");

      /***/
    },

    /***/ 4300: /***/ (module) => {
      "use strict";
      module.exports = require("buffer");

      /***/
    },

    /***/ 2081: /***/ (module) => {
      "use strict";
      module.exports = require("child_process");

      /***/
    },

    /***/ 2057: /***/ (module) => {
      "use strict";
      module.exports = require("constants");

      /***/
    },

    /***/ 6113: /***/ (module) => {
      "use strict";
      module.exports = require("crypto");

      /***/
    },

    /***/ 9523: /***/ (module) => {
      "use strict";
      module.exports = require("dns");

      /***/
    },

    /***/ 2361: /***/ (module) => {
      "use strict";
      module.exports = require("events");

      /***/
    },

    /***/ 7147: /***/ (module) => {
      "use strict";
      module.exports = require("fs");

      /***/
    },

    /***/ 3685: /***/ (module) => {
      "use strict";
      module.exports = require("http");

      /***/
    },

    /***/ 5687: /***/ (module) => {
      "use strict";
      module.exports = require("https");

      /***/
    },

    /***/ 1808: /***/ (module) => {
      "use strict";
      module.exports = require("net");

      /***/
    },

    /***/ 2037: /***/ (module) => {
      "use strict";
      module.exports = require("os");

      /***/
    },

    /***/ 1017: /***/ (module) => {
      "use strict";
      module.exports = require("path");

      /***/
    },

    /***/ 3477: /***/ (module) => {
      "use strict";
      module.exports = require("querystring");

      /***/
    },

    /***/ 2781: /***/ (module) => {
      "use strict";
      module.exports = require("stream");

      /***/
    },

    /***/ 1576: /***/ (module) => {
      "use strict";
      module.exports = require("string_decoder");

      /***/
    },

    /***/ 9512: /***/ (module) => {
      "use strict";
      module.exports = require("timers");

      /***/
    },

    /***/ 4404: /***/ (module) => {
      "use strict";
      module.exports = require("tls");

      /***/
    },

    /***/ 6224: /***/ (module) => {
      "use strict";
      module.exports = require("tty");

      /***/
    },

    /***/ 7310: /***/ (module) => {
      "use strict";
      module.exports = require("url");

      /***/
    },

    /***/ 3837: /***/ (module) => {
      "use strict";
      module.exports = require("util");

      /***/
    },

    /***/ 9796: /***/ (module) => {
      "use strict";
      module.exports = require("zlib");

      /***/
    },

    /***/ 2818: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"name":"ali-oss","version":"6.18.1","description":"aliyun oss(object storage service) node client","main":"./lib/client.js","files":["lib","shims","dist"],"browser":{"./lib/client.js":"./dist/aliyun-oss-sdk.js","mime":"mime/lite","urllib":"./shims/xhr.js","utility":"./shims/utility.js","crypto":"./shims/crypto/crypto.js","debug":"./shims/debug","fs":false,"child_process":false,"is-type-of":"./shims/is-type-of.js"},"scripts":{"build-change-log":"standard-version","test":"npm run tsc && mocha -t 120000 -r should -r dotenv/config test/node/*.test.js test/node/**/*.test.js","test-cov":"npm run tsc && nyc --reporter=lcov node_modules/.bin/_mocha -t 120000 -r should test/node/*.test.js test/node/**/*.test.js","jshint":"jshint .","build-test":"MINIFY=1 node browser-build.js > test/browser/build/aliyun-oss-sdk.min.js && node -r dotenv/config task/browser-test-build.js > test/browser/build/tests.js","browser-test":"npm run build-test && karma start","build-dist":"npm run tsc && node browser-build.js > dist/aliyun-oss-sdk.js && MINIFY=1 node browser-build.js > dist/aliyun-oss-sdk.min.js","publish-to-npm":"node publish-npm-check.js && npm publish","publish-to-cdn":"node publish.js","snyk-protect":"snyk-protect","lint-staged":"lint-staged","detect-secrets":"node task/detect-secrets","tsc":"npm run tsc:clean && npm run tsc:build","tsc:build":"tsc -b tsconfig.json tsconfig-cjs.json","tsc:watch":"tsc -b tsconfig.json tsconfig-cjs.json --watch","tsc:clean":"tsc -b tsconfig.json tsconfig-cjs.json --clean ","prepare":"husky install"},"git-pre-hooks":{"pre-release":"npm run build-dist","post-release":["npm run publish-to-npm","npm run publish-to-cdn"]},"homepage":"https://github.com/ali-sdk/ali-oss","bugs":{"url":"https://github.com/ali-sdk/ali-oss/issues"},"publishConfig":{"registry":"https://registry.npmjs.org/","access":"public"},"repository":{"type":"git","url":"https://github.com/ali-sdk/ali-oss.git"},"keywords":["oss","client","file","aliyun"],"author":"dead_horse","license":"MIT","engines":{"node":">=8"},"devDependencies":{"@babel/core":"^7.11.6","@babel/plugin-transform-regenerator":"^7.10.4","@babel/plugin-transform-runtime":"^7.11.5","@babel/preset-env":"^7.11.5","@babel/runtime":"^7.11.2","@commitlint/cli":"^17.6.7","@commitlint/config-conventional":"^16.2.4","@octokit/core":"^5.0.0","@semantic-release/exec":"^6.0.3","@semantic-release/git":"^10.0.1","@semantic-release/npm":"^10.0.5","@snyk/protect":"^1.1196.0","@types/node":"^14.0.12","@typescript-eslint/eslint-plugin":"^5.0.0","@typescript-eslint/parser":"^5.0.0","aliasify":"^2.0.0","axios":"0.27.2","babelify":"^10.0.0","beautify-benchmark":"^0.2.4","benchmark":"^2.1.1","bluebird":"^3.1.5","browserify":"^17.0.0","core-js":"^3.6.5","crypto-js":"^3.1.9-1","dotenv":"^8.2.0","eslint":"^8.44.0","eslint-config-airbnb":"^19.0.4","eslint-config-ali":"^13.0.0","eslint-config-prettier":"^8.8.0","eslint-plugin-import":"^2.21.1","eslint-plugin-jsx-a11y":"^6.0.3","eslint-plugin-prettier":"^4.2.1","filereader":"^0.10.3","form-data":"^4.0.0","git-pre-hooks":"^1.2.0","husky":"^7.0.4","immediate":"^3.3.0","karma":"^6.3.4","karma-browserify":"^8.1.0","karma-chrome-launcher":"^2.2.0","karma-firefox-launcher":"^1.0.1","karma-ie-launcher":"^1.0.0","karma-mocha":"^2.0.1","karma-safari-launcher":"^1.0.0","lint-staged":"^12.4.1","mm":"^2.0.0","mocha":"^9.1.2","nyc":"^15.1.0","prettier":"^3.0.0","promise-polyfill":"^6.0.2","puppeteer":"19.0.0","semantic-release":"^21.1.1","should":"^11.0.0","sinon":"^15.2.0","standard-version":"^9.3.1","stream-equal":"^1.1.0","timemachine":"^0.3.0","typescript":"^3.9.5","uglify-js":"^3.14.2","watchify":"^4.0.0"},"dependencies":{"address":"^1.2.2","agentkeepalive":"^3.4.1","bowser":"^1.6.0","copy-to":"^2.0.1","dateformat":"^2.0.0","debug":"^4.3.4","destroy":"^1.0.4","end-or-error":"^1.0.1","get-ready":"^1.0.0","humanize-ms":"^1.2.0","is-type-of":"^1.4.0","js-base64":"^2.5.2","jstoxml":"^2.0.0","merge-descriptors":"^1.0.1","mime":"^2.4.5","platform":"^1.3.1","pump":"^3.0.0","sdk-base":"^2.0.1","stream-http":"2.8.2","stream-wormhole":"^1.0.4","urllib":"2.41.0","utility":"^1.18.0","xml2js":"^0.6.2"},"snyk":true,"lint-staged":{"**/!(dist)/*":["npm run detect-secrets --"],"**/*.{js,ts}":["eslint --cache --fix --ext .js,.ts","prettier --write","git add"]}}'
      );

      /***/
    },

    /***/ 3480: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]'
      );

      /***/
    },

    /***/ 3336: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]'
      );

      /***/
    },

    /***/ 7348: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]'
      );

      /***/
    },

    /***/ 4284: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]'
      );

      /***/
    },

    /***/ 1532: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]'
      );

      /***/
    },

    /***/ 6258: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}'
      );

      /***/
    },

    /***/ 4346: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]'
      );

      /***/
    },

    /***/ 7014: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]'
      );

      /***/
    },

    /***/ 855: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"100":"Continue","101":"Switching Protocols","102":"Processing","103":"Early Hints","200":"OK","201":"Created","202":"Accepted","203":"Non-Authoritative Information","204":"No Content","205":"Reset Content","206":"Partial Content","207":"Multi-Status","208":"Already Reported","226":"IM Used","300":"Multiple Choices","301":"Moved Permanently","302":"Found","303":"See Other","304":"Not Modified","305":"Use Proxy","306":"(Unused)","307":"Temporary Redirect","308":"Permanent Redirect","400":"Bad Request","401":"Unauthorized","402":"Payment Required","403":"Forbidden","404":"Not Found","405":"Method Not Allowed","406":"Not Acceptable","407":"Proxy Authentication Required","408":"Request Timeout","409":"Conflict","410":"Gone","411":"Length Required","412":"Precondition Failed","413":"Payload Too Large","414":"URI Too Long","415":"Unsupported Media Type","416":"Range Not Satisfiable","417":"Expectation Failed","418":"I\'m a teapot","421":"Misdirected Request","422":"Unprocessable Entity","423":"Locked","424":"Failed Dependency","425":"Unordered Collection","426":"Upgrade Required","428":"Precondition Required","429":"Too Many Requests","431":"Request Header Fields Too Large","451":"Unavailable For Legal Reasons","500":"Internal Server Error","501":"Not Implemented","502":"Bad Gateway","503":"Service Unavailable","504":"Gateway Timeout","505":"HTTP Version Not Supported","506":"Variant Also Negotiates","507":"Insufficient Storage","508":"Loop Detected","509":"Bandwidth Limit Exceeded","510":"Not Extended","511":"Network Authentication Required"}'
      );

      /***/
    },

    /***/ 7164: /***/ (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"name":"urllib","version":"2.41.0","publishConfig":{"tag":"latest-2"},"description":"Help in opening URLs (mostly HTTP) in a complex world  basic and digest authentication, redirections, cookies and more.","keywords":["urllib","http","urlopen","curl","wget","request","https"],"author":"fengmk2 <fengmk2@gmail.com> (https://fengmk2.com)","homepage":"https://github.com/node-modules/urllib","main":"lib/index.js","types":"lib/index.d.ts","files":["lib"],"repository":{"type":"git","url":"git://github.com/node-modules/urllib.git"},"scripts":{"tsd":"node test/tsd.js","test-local":"mocha -t 30000 test/*.test.js","test":"npm run lint && npm run test-local","test-cov":"istanbul cover node_modules/mocha/bin/_mocha -- -t 30000 test/*.test.js","ci":"npm run lint && npm run tsd && npm run test-cov","lint":"jshint .","contributor":"git-contributor"},"dependencies":{"any-promise":"^1.3.0","content-type":"^1.0.2","debug":"^2.6.9","default-user-agent":"^1.0.0","digest-header":"^1.0.0","ee-first":"~1.1.1","formstream":"^1.1.0","humanize-ms":"^1.2.0","iconv-lite":"^0.4.15","ip":"^1.1.5","pump":"^3.0.0","qs":"^6.4.0","statuses":"^1.3.1","utility":"^1.16.1"},"peerDependencies":{"proxy-agent":"^5.0.0"},"peerDependenciesMeta":{"proxy-agent":{"optional":true}},"devDependencies":{"@types/mocha":"^5.2.5","@types/node":"^10.12.18","agentkeepalive":"^4.0.0","benchmark":"^2.1.4","bluebird":"*","busboy":"^0.2.14","co":"*","coffee":"1","egg-ci":"^1.15.0","git-contributor":"^1.0.10","http-proxy":"^1.16.2","istanbul":"*","jshint":"*","mkdirp":"^0.5.1","mocha":"3","muk":"^0.5.3","pedding":"^1.1.0","proxy-agent":"^5.0.0","semver":"5","spy":"^1.0.0","tar":"^4.4.8","through2":"^2.0.3","tsd":"^0.18.0","typescript":"^4.4.4"},"engines":{"node":">= 0.10.0"},"ci":{"type":"github","os":{"github":"linux, windows, macos"},"version":"8, 10, 12, 14, 16"},"license":"MIT"}'
      );

      /***/
    }

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __nccwpck_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ loaded: false,
      /******/ exports: {}
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ var threw = true;
    /******/ try {
      /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
      /******/ threw = false;
      /******/
    } finally {
      /******/ if (threw) delete __webpack_module_cache__[moduleId];
      /******/
    }
    /******/
    /******/ // Flag the module as loaded
    /******/ module.loaded = true;
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/async module */
  /******/ (() => {
    /******/ var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
    /******/ var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
    /******/ var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
    /******/ var resolveQueue = (queue) => {
      /******/ if (queue && !queue.d) {
        /******/ queue.d = 1;
        /******/ queue.forEach((fn) => fn.r--);
        /******/ queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
        /******/
      }
      /******/
    };
    /******/ var wrapDeps = (deps) =>
      deps.map((dep) => {
        /******/ if (dep !== null && typeof dep === "object") {
          /******/ if (dep[webpackQueues]) return dep;
          /******/ if (dep.then) {
            /******/ var queue = [];
            /******/ queue.d = 0;
            /******/ dep.then(
              (r) => {
                /******/ obj[webpackExports] = r;
                /******/ resolveQueue(queue);
                /******/
              },
              (e) => {
                /******/ obj[webpackError] = e;
                /******/ resolveQueue(queue);
                /******/
              }
            );
            /******/ var obj = {};
            /******/ obj[webpackQueues] = (fn) => fn(queue);
            /******/ return obj;
            /******/
          }
          /******/
        }
        /******/ var ret = {};
        /******/ ret[webpackQueues] = (x) => {};
        /******/ ret[webpackExports] = dep;
        /******/ return ret;
        /******/
      });
    /******/ __nccwpck_require__.a = (module, body, hasAwait) => {
      /******/ var queue;
      /******/ hasAwait && ((queue = []).d = 1);
      /******/ var depQueues = new Set();
      /******/ var exports = module.exports;
      /******/ var currentDeps;
      /******/ var outerResolve;
      /******/ var reject;
      /******/ var promise = new Promise((resolve, rej) => {
        /******/ reject = rej;
        /******/ outerResolve = resolve;
        /******/
      });
      /******/ promise[webpackExports] = exports;
      /******/ promise[webpackQueues] = (fn) => (
        queue && fn(queue), depQueues.forEach(fn), promise["catch"]((x) => {})
      );
      /******/ module.exports = promise;
      /******/ body(
        (deps) => {
          /******/ currentDeps = wrapDeps(deps);
          /******/ var fn;
          /******/ var getResult = () =>
            currentDeps.map((d) => {
              /******/ if (d[webpackError]) throw d[webpackError];
              /******/ return d[webpackExports];
              /******/
            });
          /******/ var promise = new Promise((resolve) => {
            /******/ fn = () => resolve(getResult);
            /******/ fn.r = 0;
            /******/ var fnQueue = (q) =>
              q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn)));
            /******/ currentDeps.map((dep) => dep[webpackQueues](fnQueue));
            /******/
          });
          /******/ return fn.r ? promise : getResult();
          /******/
        },
        (err) => (err ? reject((promise[webpackError] = err)) : outerResolve(exports), resolveQueue(queue))
      );
      /******/ queue && (queue.d = 0);
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __nccwpck_require__.n = (module) => {
      /******/ var getter = module && module.__esModule ? /******/ () => module["default"] : /******/ () => module;
      /******/ __nccwpck_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/create fake namespace object */
  /******/ (() => {
    /******/ var getProto = Object.getPrototypeOf ? (obj) => Object.getPrototypeOf(obj) : (obj) => obj.__proto__;
    /******/ var leafPrototypes;
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 16: return value when it's Promise-like
    /******/ // mode & 8|1: behave like require
    /******/ __nccwpck_require__.t = function (value, mode) {
      /******/ if (mode & 1) value = this(value);
      /******/ if (mode & 8) return value;
      /******/ if (typeof value === "object" && value) {
        /******/ if (mode & 4 && value.__esModule) return value;
        /******/ if (mode & 16 && typeof value.then === "function") return value;
        /******/
      }
      /******/ var ns = Object.create(null);
      /******/ __nccwpck_require__.r(ns);
      /******/ var def = {};
      /******/ leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
      /******/ for (
        var current = mode & 2 && value;
        typeof current == "object" && !~leafPrototypes.indexOf(current);
        current = getProto(current)
      ) {
        /******/ Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => value[key]));
        /******/
      }
      /******/ def["default"] = () => value;
      /******/ __nccwpck_require__.d(ns, def);
      /******/ return ns;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __nccwpck_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
          /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __nccwpck_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __nccwpck_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/node module decorator */
  /******/ (() => {
    /******/ __nccwpck_require__.nmd = (module) => {
      /******/ module.paths = [];
      /******/ if (!module.children) module.children = [];
      /******/ return module;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/compat */
  /******/
  /******/ if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module used 'module' so it can't be inlined
  /******/ var __webpack_exports__ = __nccwpck_require__(3109);
  /******/ module.exports = __webpack_exports__;
  /******/
  /******/
})();
